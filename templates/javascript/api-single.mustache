import {
  createAuth,
  createTransporter,
  getAlgoliaAgent,
  shuffle,
} from '@experimental-api-clients-automation/client-common';
import type {
  CreateClientOptions,
  Headers,
  Host,
  Request,
  RequestOptions,
  QueryParameters,
} from '@experimental-api-clients-automation/client-common';

{{#imports}}
import { {{classname}} } from '{{filename}}';
{{/imports}}

export * from '../model';
export const apiClientVersion = '{{packageVersion}}';

{{#operations}}
{{#description}}
/**
* {{&description}}
*/
{{/description}}

{{#hasRegionalHost}}
export type Region = {{#allowedRegions}}'{{.}}'{{^-last}}|{{/-last}}{{/allowedRegions}};
{{/hasRegionalHost}}

{{^hasRegionalHost}}
function getDefaultHosts(appId: string): Host[] {
  return (
    [
      {
        url: `${appId}-dsn.algolia.net`,
        accept: 'read',
        protocol: 'https',
      },
      {
        url: `${appId}.algolia.net`,
        accept: 'write',
        protocol: 'https',
      },
    ] as Host[]
  ).concat(
    shuffle([
      {
        url: `${appId}-1.algolianet.com`,
        accept: 'readWrite',
        protocol: 'https',
      },
      {
        url: `${appId}-2.algolianet.com`,
        accept: 'readWrite',
        protocol: 'https',
      },
      {
        url: `${appId}-3.algolianet.com`,
        accept: 'readWrite',
        protocol: 'https',
      },
    ])
  );
}
{{/hasRegionalHost}}

{{#hasRegionalHost}}
function getDefaultHosts(region{{#fallbackToAliasHost}}?{{/fallbackToAliasHost}}: Region): Host[] {
  const url = {{#fallbackToAliasHost}}!region ? '{{{hostWithFallback}}}' : {{/fallbackToAliasHost}} '{{{host}}}'.replace('{region}', region);

  return [{ url, accept: 'readWrite', protocol: 'https' }];
}
{{/hasRegionalHost}}

// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
export function create{{capitalizedApiName}}(options: CreateClientOptions{{#hasRegionalHost}} & {region{{#fallbackToAliasHost}}?{{/fallbackToAliasHost}}: Region }{{/hasRegionalHost}}) {
  const auth = createAuth(options.appId, options.apiKey, options.authMode);
  const transporter = createTransporter({
    hosts: options?.hosts ?? getDefaultHosts({{^hasRegionalHost}}options.appId{{/hasRegionalHost}}{{#hasRegionalHost}}options.region{{/hasRegionalHost}}),
    hostsCache: options.hostsCache,
    requestsCache: options.requestsCache,
    responsesCache: options.responsesCache,
    baseHeaders: {
      'content-type': 'application/x-www-form-urlencoded',
      ...auth.headers(),
    },
    baseQueryParameters: auth.queryParameters(),
    algoliaAgent: getAlgoliaAgent({
      algoliaAgents: options.algoliaAgents,
      client: '{{{algoliaAgent}}}',
      version: apiClientVersion,
    }),
    timeouts: options.timeouts,
    requester: options.requester,
  });

  function addAlgoliaAgent(segment: string, version?: string): void {
    transporter.algoliaAgent.add({ segment, version });
  }

  return {
    addAlgoliaAgent,
    {{#operation}}
    /**
    {{#notes}}
    * {{&notes}}
    {{/notes}}
    {{#summary}}
    * @summary {{&summary}}
    {{/summary}}
    {{#vendorExtensions}}
      {{#x-create-wrapping-object}}
      * @param {{nickname}} - The {{nickname}} object.
      {{#allParams}}
      * @param {{nickname}}.{{paramName}} - {{^description}}The {{paramName}} object.{{/description}}{{#description}}{{{description}}}{{/description}}
      {{/allParams}}
      {{/x-create-wrapping-object}}
      {{#x-is-single-body-param}}
        {{#bodyParams}}
          * @param {{paramName}} - {{^description}}The {{paramName}} object.{{/description}}{{#description}}{{{description}}}{{/description}}
        {{/bodyParams}}
      {{/x-is-single-body-param}}
    {{/vendorExtensions}}
    * @param requestOptions - The requestOptions to send along with the query, they will be merged with the transporter requestOptions.
    */
    {{nickname}}(
      {{#vendorExtensions}}
        {{#x-create-wrapping-object}}
          {
            {{#allParams}}
              {{paramName}},
            {{/allParams}}
          }: {{#lambda.titlecase}}{{nickname}}{{/lambda.titlecase}}Props,
        {{/x-create-wrapping-object}}
        {{#x-is-single-body-param}}
          {{#bodyParams}}
            {{paramName}}: {{{dataType}}},
          {{/bodyParams}}
        {{/x-is-single-body-param}}
      {{/vendorExtensions}}
      requestOptions?: RequestOptions
        ) : Promise<{{{returnType}}}> {
      {{#allParams}}
      {{#required}}
      if ({{#isBoolean}}{{paramName}} === null || {{paramName}} === undefined{{/isBoolean}}{{^isBoolean}}!{{paramName}}{{/isBoolean}}) {
        throw new Error('Parameter `{{paramName}}` is required when calling `{{nickname}}`.');
      }

      {{#vars}}
      {{#required}}
      if ({{#isBoolean}}{{paramName}}.{{baseName}} === null || {{paramName}}.{{baseName}} === undefined{{/isBoolean}}{{^isBoolean}}!{{paramName}}.{{baseName}}{{/isBoolean}}) {
        throw new Error('Parameter `{{paramName}}.{{baseName}}` is required when calling `{{nickname}}`.');
      }
      {{/required}}
      {{/vars}}

      {{/required}}
      {{/allParams}}

      const requestPath = '{{{path}}}'{{#vendorExtensions}}{{#pathParams}}.replace(
      {{=<% %>=}}'{<%baseName%>}'<%={{ }}=%>,{{#x-is-custom-request}}{{paramName}}{{/x-is-custom-request}}{{^x-is-custom-request}}encodeURIComponent({{paramName}}){{/x-is-custom-request}}
      ){{/pathParams}}{{/vendorExtensions}};
      const headers: Headers = {};
      const queryParameters: QueryParameters = {{#vendorExtensions.x-is-custom-request}}parameters || {{/vendorExtensions.x-is-custom-request}}{};

      {{^vendorExtensions.x-is-custom-request}}{{#queryParams}}
      if ({{paramName}} !== undefined) {
        queryParameters['{{baseName}}'] = {{paramName}}.toString();
      }

      {{/queryParams}}{{/vendorExtensions.x-is-custom-request}}

      {{#headerParams}}
      if ({{paramName}} !== undefined) {
        headers['{{baseName}}'] = {{paramName}}.toString();
      }
      {{/headerParams}}

      const request: Request = {
        method: '{{httpMethod}}',
        path: requestPath,
        {{#bodyParam}}
        data: {{paramName}},
        {{/bodyParam}}
      };

      return transporter.request(request, {
        queryParameters,
        headers,
      }, requestOptions);
    },

    {{/operation}}
  };
}

export type {{capitalizedApiName}} = ReturnType<typeof create{{capitalizedApiName}}>;

{{#operation}}
{{#vendorExtensions.x-create-wrapping-object}}
export type {{#lambda.titlecase}}{{nickname}}{{/lambda.titlecase}}Props = {
  {{#allParams}}
    {{#description}}
    /**
    * {{{description}}}
    */
    {{/description}}
    {{paramName}}{{^required}}?{{/required}}: {{{dataType}}};
  {{/allParams}}
}
{{/vendorExtensions.x-create-wrapping-object}}

{{/operation}}

{{/operations}}
