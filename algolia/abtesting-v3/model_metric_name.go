// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package abtestingV3

import (
	"encoding/json"
	"fmt"
)

// MetricName the model 'MetricName'.
type MetricName string

// List of MetricName.
const (
	METRIC_NAME_SEARCH_COUNT           MetricName = "search_count"
	METRIC_NAME_TRACKED_SEARCH_COUNT   MetricName = "tracked_search_count"
	METRIC_NAME_USER_COUNT             MetricName = "user_count"
	METRIC_NAME_TRACKED_USER_COUNT     MetricName = "tracked_user_count"
	METRIC_NAME_NO_RESULT_COUNT        MetricName = "no_result_count"
	METRIC_NAME_ADD_TO_CART_COUNT      MetricName = "add_to_cart_count"
	METRIC_NAME_PURCHASE_COUNT         MetricName = "purchase_count"
	METRIC_NAME_CLICKED_SEARCH_COUNT   MetricName = "clicked_search_count"
	METRIC_NAME_CONVERTED_SEARCH_COUNT MetricName = "converted_search_count"
	METRIC_NAME_CLICK_THROUGH_RATE     MetricName = "click_through_rate"
	METRIC_NAME_CONVERSION_RATE        MetricName = "conversion_rate"
	METRIC_NAME_ADD_TO_CART_RATE       MetricName = "add_to_cart_rate"
	METRIC_NAME_PURCHASE_RATE          MetricName = "purchase_rate"
	METRIC_NAME_AVERAGE_CLICK_POSITION MetricName = "average_click_position"
	METRIC_NAME_REVENUE                MetricName = "revenue"
)

// All allowed values of MetricName enum.
var AllowedMetricNameEnumValues = []MetricName{
	"search_count",
	"tracked_search_count",
	"user_count",
	"tracked_user_count",
	"no_result_count",
	"add_to_cart_count",
	"purchase_count",
	"clicked_search_count",
	"converted_search_count",
	"click_through_rate",
	"conversion_rate",
	"add_to_cart_rate",
	"purchase_rate",
	"average_click_position",
	"revenue",
}

// NewMetricNameFromValue returns a pointer to a valid MetricName.
// for the value passed as argument, or an error if the value passed is not allowed by the enum.
func NewMetricNameFromValue(v string) (*MetricName, error) {
	ev := MetricName(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for MetricName: valid values are %v", v, AllowedMetricNameEnumValues)
	}
}

func (v *MetricName) UnmarshalJSON(src []byte) error {
	var value string

	err := json.Unmarshal(src, &value)
	if err != nil {
		return fmt.Errorf("failed to unmarshal value '%s' for enum 'MetricName': %w", string(src), err)
	}

	enumTypeValue := MetricName(value)
	for _, existing := range AllowedMetricNameEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue

			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid MetricName", value)
}

// IsValid return true if the value is valid for the enum, false otherwise.
func (v MetricName) IsValid() bool {
	for _, existing := range AllowedMetricNameEnumValues {
		if existing == v {
			return true
		}
	}

	return false
}

// Ptr returns reference to MetricName value.
func (v MetricName) Ptr() *MetricName {
	return &v
}
