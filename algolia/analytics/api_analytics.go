// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package analytics

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/call"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       name,
		value:      parameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

type ApiDelRequest struct {
	path       string
	parameters map[string]interface{}
}

func (r *ApiDelRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok { //path
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok { //parameters
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// Query parameters to be applied to the current query.
func (r ApiDelRequest) WithParameters(parameters map[string]interface{}) ApiDelRequest {
	r.parameters = parameters
	return r
}

// @return ApiDelRequest
func (c *APIClient) NewApiDelRequest(path string) ApiDelRequest {
	return ApiDelRequest{
		path: path,
	}
}

// Del wraps DelWithContext using context.Background.
func (c *APIClient) Del(r ApiDelRequest, opts ...Option) (map[string]interface{}, error) {
	return c.DelWithContext(context.Background(), r, opts...)
}

// @return map[string]interface{}
func (c *APIClient) DelWithContext(ctx context.Context, r ApiDelRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetRequest struct {
	path       string
	parameters map[string]interface{}
}

func (r *ApiGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok { //path
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok { //parameters
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// Query parameters to be applied to the current query.
func (r ApiGetRequest) WithParameters(parameters map[string]interface{}) ApiGetRequest {
	r.parameters = parameters
	return r
}

// @return ApiGetRequest
func (c *APIClient) NewApiGetRequest(path string) ApiGetRequest {
	return ApiGetRequest{
		path: path,
	}
}

// Get wraps GetWithContext using context.Background.
func (c *APIClient) Get(r ApiGetRequest, opts ...Option) (map[string]interface{}, error) {
	return c.GetWithContext(context.Background(), r, opts...)
}

// @return map[string]interface{}
func (c *APIClient) GetWithContext(ctx context.Context, r ApiGetRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetAverageClickPositionRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

func (r *ApiGetAverageClickPositionRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetAverageClickPositionRequest) WithIndex(index string) ApiGetAverageClickPositionRequest {
	r.index = index
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetAverageClickPositionRequest) WithStartDate(startDate string) ApiGetAverageClickPositionRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetAverageClickPositionRequest) WithEndDate(endDate string) ApiGetAverageClickPositionRequest {
	r.endDate = endDate
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetAverageClickPositionRequest) WithTags(tags string) ApiGetAverageClickPositionRequest {
	r.tags = tags
	return r
}

// @return ApiGetAverageClickPositionRequest
func (c *APIClient) NewApiGetAverageClickPositionRequest() ApiGetAverageClickPositionRequest {
	return ApiGetAverageClickPositionRequest{}
}

// GetAverageClickPosition wraps GetAverageClickPositionWithContext using context.Background.
func (c *APIClient) GetAverageClickPosition(r ApiGetAverageClickPositionRequest, opts ...Option) (*GetAverageClickPositionResponse, error) {
	return c.GetAverageClickPositionWithContext(context.Background(), r, opts...)
}

// @return GetAverageClickPositionResponse
func (c *APIClient) GetAverageClickPositionWithContext(ctx context.Context, r ApiGetAverageClickPositionRequest, opts ...Option) (*GetAverageClickPositionResponse, error) {
	var (
		postBody    any
		returnValue *GetAverageClickPositionResponse
	)

	requestPath := "/2/clicks/averageClickPosition"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetClickPositionsRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

func (r *ApiGetClickPositionsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetClickPositionsRequest) WithIndex(index string) ApiGetClickPositionsRequest {
	r.index = index
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetClickPositionsRequest) WithStartDate(startDate string) ApiGetClickPositionsRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetClickPositionsRequest) WithEndDate(endDate string) ApiGetClickPositionsRequest {
	r.endDate = endDate
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetClickPositionsRequest) WithTags(tags string) ApiGetClickPositionsRequest {
	r.tags = tags
	return r
}

// @return ApiGetClickPositionsRequest
func (c *APIClient) NewApiGetClickPositionsRequest() ApiGetClickPositionsRequest {
	return ApiGetClickPositionsRequest{}
}

// GetClickPositions wraps GetClickPositionsWithContext using context.Background.
func (c *APIClient) GetClickPositions(r ApiGetClickPositionsRequest, opts ...Option) (*GetClickPositionsResponse, error) {
	return c.GetClickPositionsWithContext(context.Background(), r, opts...)
}

// @return GetClickPositionsResponse
func (c *APIClient) GetClickPositionsWithContext(ctx context.Context, r ApiGetClickPositionsRequest, opts ...Option) (*GetClickPositionsResponse, error) {
	var (
		postBody    any
		returnValue *GetClickPositionsResponse
	)

	requestPath := "/2/clicks/positions"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetClickThroughRateRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

func (r *ApiGetClickThroughRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetClickThroughRateRequest) WithIndex(index string) ApiGetClickThroughRateRequest {
	r.index = index
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetClickThroughRateRequest) WithStartDate(startDate string) ApiGetClickThroughRateRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetClickThroughRateRequest) WithEndDate(endDate string) ApiGetClickThroughRateRequest {
	r.endDate = endDate
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetClickThroughRateRequest) WithTags(tags string) ApiGetClickThroughRateRequest {
	r.tags = tags
	return r
}

// @return ApiGetClickThroughRateRequest
func (c *APIClient) NewApiGetClickThroughRateRequest() ApiGetClickThroughRateRequest {
	return ApiGetClickThroughRateRequest{}
}

// GetClickThroughRate wraps GetClickThroughRateWithContext using context.Background.
func (c *APIClient) GetClickThroughRate(r ApiGetClickThroughRateRequest, opts ...Option) (*GetClickThroughRateResponse, error) {
	return c.GetClickThroughRateWithContext(context.Background(), r, opts...)
}

// @return GetClickThroughRateResponse
func (c *APIClient) GetClickThroughRateWithContext(ctx context.Context, r ApiGetClickThroughRateRequest, opts ...Option) (*GetClickThroughRateResponse, error) {
	var (
		postBody    any
		returnValue *GetClickThroughRateResponse
	)

	requestPath := "/2/clicks/clickThroughRate"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetConversationRateRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

func (r *ApiGetConversationRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetConversationRateRequest) WithIndex(index string) ApiGetConversationRateRequest {
	r.index = index
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetConversationRateRequest) WithStartDate(startDate string) ApiGetConversationRateRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetConversationRateRequest) WithEndDate(endDate string) ApiGetConversationRateRequest {
	r.endDate = endDate
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetConversationRateRequest) WithTags(tags string) ApiGetConversationRateRequest {
	r.tags = tags
	return r
}

// @return ApiGetConversationRateRequest
func (c *APIClient) NewApiGetConversationRateRequest() ApiGetConversationRateRequest {
	return ApiGetConversationRateRequest{}
}

// GetConversationRate wraps GetConversationRateWithContext using context.Background.
func (c *APIClient) GetConversationRate(r ApiGetConversationRateRequest, opts ...Option) (*GetConversationRateResponse, error) {
	return c.GetConversationRateWithContext(context.Background(), r, opts...)
}

// @return GetConversationRateResponse
func (c *APIClient) GetConversationRateWithContext(ctx context.Context, r ApiGetConversationRateRequest, opts ...Option) (*GetConversationRateResponse, error) {
	var (
		postBody    any
		returnValue *GetConversationRateResponse
	)

	requestPath := "/2/conversions/conversionRate"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetNoClickRateRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

func (r *ApiGetNoClickRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetNoClickRateRequest) WithIndex(index string) ApiGetNoClickRateRequest {
	r.index = index
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetNoClickRateRequest) WithStartDate(startDate string) ApiGetNoClickRateRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetNoClickRateRequest) WithEndDate(endDate string) ApiGetNoClickRateRequest {
	r.endDate = endDate
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetNoClickRateRequest) WithTags(tags string) ApiGetNoClickRateRequest {
	r.tags = tags
	return r
}

// @return ApiGetNoClickRateRequest
func (c *APIClient) NewApiGetNoClickRateRequest() ApiGetNoClickRateRequest {
	return ApiGetNoClickRateRequest{}
}

// GetNoClickRate wraps GetNoClickRateWithContext using context.Background.
func (c *APIClient) GetNoClickRate(r ApiGetNoClickRateRequest, opts ...Option) (*GetNoClickRateResponse, error) {
	return c.GetNoClickRateWithContext(context.Background(), r, opts...)
}

// @return GetNoClickRateResponse
func (c *APIClient) GetNoClickRateWithContext(ctx context.Context, r ApiGetNoClickRateRequest, opts ...Option) (*GetNoClickRateResponse, error) {
	var (
		postBody    any
		returnValue *GetNoClickRateResponse
	)

	requestPath := "/2/searches/noClickRate"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetNoResultsRateRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

func (r *ApiGetNoResultsRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetNoResultsRateRequest) WithIndex(index string) ApiGetNoResultsRateRequest {
	r.index = index
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetNoResultsRateRequest) WithStartDate(startDate string) ApiGetNoResultsRateRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetNoResultsRateRequest) WithEndDate(endDate string) ApiGetNoResultsRateRequest {
	r.endDate = endDate
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetNoResultsRateRequest) WithTags(tags string) ApiGetNoResultsRateRequest {
	r.tags = tags
	return r
}

// @return ApiGetNoResultsRateRequest
func (c *APIClient) NewApiGetNoResultsRateRequest() ApiGetNoResultsRateRequest {
	return ApiGetNoResultsRateRequest{}
}

// GetNoResultsRate wraps GetNoResultsRateWithContext using context.Background.
func (c *APIClient) GetNoResultsRate(r ApiGetNoResultsRateRequest, opts ...Option) (*GetNoResultsRateResponse, error) {
	return c.GetNoResultsRateWithContext(context.Background(), r, opts...)
}

// @return GetNoResultsRateResponse
func (c *APIClient) GetNoResultsRateWithContext(ctx context.Context, r ApiGetNoResultsRateRequest, opts ...Option) (*GetNoResultsRateResponse, error) {
	var (
		postBody    any
		returnValue *GetNoResultsRateResponse
	)

	requestPath := "/2/searches/noResultRate"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetSearchesCountRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

func (r *ApiGetSearchesCountRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetSearchesCountRequest) WithIndex(index string) ApiGetSearchesCountRequest {
	r.index = index
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetSearchesCountRequest) WithStartDate(startDate string) ApiGetSearchesCountRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetSearchesCountRequest) WithEndDate(endDate string) ApiGetSearchesCountRequest {
	r.endDate = endDate
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetSearchesCountRequest) WithTags(tags string) ApiGetSearchesCountRequest {
	r.tags = tags
	return r
}

// @return ApiGetSearchesCountRequest
func (c *APIClient) NewApiGetSearchesCountRequest() ApiGetSearchesCountRequest {
	return ApiGetSearchesCountRequest{}
}

// GetSearchesCount wraps GetSearchesCountWithContext using context.Background.
func (c *APIClient) GetSearchesCount(r ApiGetSearchesCountRequest, opts ...Option) (*GetSearchesCountResponse, error) {
	return c.GetSearchesCountWithContext(context.Background(), r, opts...)
}

// @return GetSearchesCountResponse
func (c *APIClient) GetSearchesCountWithContext(ctx context.Context, r ApiGetSearchesCountRequest, opts ...Option) (*GetSearchesCountResponse, error) {
	var (
		postBody    any
		returnValue *GetSearchesCountResponse
	)

	requestPath := "/2/searches/count"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetSearchesNoClicksRequest struct {
	index     string
	startDate string
	endDate   string
	limit     int32
	offset    int32
	tags      string
}

func (r *ApiGetSearchesNoClicksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["limit"]; ok { //limit
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["offset"]; ok { //offset
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetSearchesNoClicksRequest) WithIndex(index string) ApiGetSearchesNoClicksRequest {
	r.index = index
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetSearchesNoClicksRequest) WithStartDate(startDate string) ApiGetSearchesNoClicksRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetSearchesNoClicksRequest) WithEndDate(endDate string) ApiGetSearchesNoClicksRequest {
	r.endDate = endDate
	return r
}

// Number of records to return. Limit is the size of the page.
func (r ApiGetSearchesNoClicksRequest) WithLimit(limit int32) ApiGetSearchesNoClicksRequest {
	r.limit = limit
	return r
}

// Position of the starting record. Used for paging. 0 is the first record.
func (r ApiGetSearchesNoClicksRequest) WithOffset(offset int32) ApiGetSearchesNoClicksRequest {
	r.offset = offset
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetSearchesNoClicksRequest) WithTags(tags string) ApiGetSearchesNoClicksRequest {
	r.tags = tags
	return r
}

// @return ApiGetSearchesNoClicksRequest
func (c *APIClient) NewApiGetSearchesNoClicksRequest() ApiGetSearchesNoClicksRequest {
	return ApiGetSearchesNoClicksRequest{}
}

// GetSearchesNoClicks wraps GetSearchesNoClicksWithContext using context.Background.
func (c *APIClient) GetSearchesNoClicks(r ApiGetSearchesNoClicksRequest, opts ...Option) (*GetSearchesNoClicksResponse, error) {
	return c.GetSearchesNoClicksWithContext(context.Background(), r, opts...)
}

// @return GetSearchesNoClicksResponse
func (c *APIClient) GetSearchesNoClicksWithContext(ctx context.Context, r ApiGetSearchesNoClicksRequest, opts ...Option) (*GetSearchesNoClicksResponse, error) {
	var (
		postBody    any
		returnValue *GetSearchesNoClicksResponse
	)

	requestPath := "/2/searches/noClicks"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !isNilorEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetSearchesNoResultsRequest struct {
	index     string
	startDate string
	endDate   string
	limit     int32
	offset    int32
	tags      string
}

func (r *ApiGetSearchesNoResultsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["limit"]; ok { //limit
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["offset"]; ok { //offset
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetSearchesNoResultsRequest) WithIndex(index string) ApiGetSearchesNoResultsRequest {
	r.index = index
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetSearchesNoResultsRequest) WithStartDate(startDate string) ApiGetSearchesNoResultsRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetSearchesNoResultsRequest) WithEndDate(endDate string) ApiGetSearchesNoResultsRequest {
	r.endDate = endDate
	return r
}

// Number of records to return. Limit is the size of the page.
func (r ApiGetSearchesNoResultsRequest) WithLimit(limit int32) ApiGetSearchesNoResultsRequest {
	r.limit = limit
	return r
}

// Position of the starting record. Used for paging. 0 is the first record.
func (r ApiGetSearchesNoResultsRequest) WithOffset(offset int32) ApiGetSearchesNoResultsRequest {
	r.offset = offset
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetSearchesNoResultsRequest) WithTags(tags string) ApiGetSearchesNoResultsRequest {
	r.tags = tags
	return r
}

// @return ApiGetSearchesNoResultsRequest
func (c *APIClient) NewApiGetSearchesNoResultsRequest() ApiGetSearchesNoResultsRequest {
	return ApiGetSearchesNoResultsRequest{}
}

// GetSearchesNoResults wraps GetSearchesNoResultsWithContext using context.Background.
func (c *APIClient) GetSearchesNoResults(r ApiGetSearchesNoResultsRequest, opts ...Option) (*GetSearchesNoResultsResponse, error) {
	return c.GetSearchesNoResultsWithContext(context.Background(), r, opts...)
}

// @return GetSearchesNoResultsResponse
func (c *APIClient) GetSearchesNoResultsWithContext(ctx context.Context, r ApiGetSearchesNoResultsRequest, opts ...Option) (*GetSearchesNoResultsResponse, error) {
	var (
		postBody    any
		returnValue *GetSearchesNoResultsResponse
	)

	requestPath := "/2/searches/noResults"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !isNilorEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetStatusRequest struct {
	index string
}

func (r *ApiGetStatusRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetStatusRequest) WithIndex(index string) ApiGetStatusRequest {
	r.index = index
	return r
}

// @return ApiGetStatusRequest
func (c *APIClient) NewApiGetStatusRequest() ApiGetStatusRequest {
	return ApiGetStatusRequest{}
}

// GetStatus wraps GetStatusWithContext using context.Background.
func (c *APIClient) GetStatus(r ApiGetStatusRequest, opts ...Option) (*GetStatusResponse, error) {
	return c.GetStatusWithContext(context.Background(), r, opts...)
}

// @return GetStatusResponse
func (c *APIClient) GetStatusWithContext(ctx context.Context, r ApiGetStatusRequest, opts ...Option) (*GetStatusResponse, error) {
	var (
		postBody    any
		returnValue *GetStatusResponse
	)

	requestPath := "/2/status"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetTopCountriesRequest struct {
	index     string
	startDate string
	endDate   string
	limit     int32
	offset    int32
	tags      string
}

func (r *ApiGetTopCountriesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["limit"]; ok { //limit
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["offset"]; ok { //offset
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetTopCountriesRequest) WithIndex(index string) ApiGetTopCountriesRequest {
	r.index = index
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetTopCountriesRequest) WithStartDate(startDate string) ApiGetTopCountriesRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetTopCountriesRequest) WithEndDate(endDate string) ApiGetTopCountriesRequest {
	r.endDate = endDate
	return r
}

// Number of records to return. Limit is the size of the page.
func (r ApiGetTopCountriesRequest) WithLimit(limit int32) ApiGetTopCountriesRequest {
	r.limit = limit
	return r
}

// Position of the starting record. Used for paging. 0 is the first record.
func (r ApiGetTopCountriesRequest) WithOffset(offset int32) ApiGetTopCountriesRequest {
	r.offset = offset
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetTopCountriesRequest) WithTags(tags string) ApiGetTopCountriesRequest {
	r.tags = tags
	return r
}

// @return ApiGetTopCountriesRequest
func (c *APIClient) NewApiGetTopCountriesRequest() ApiGetTopCountriesRequest {
	return ApiGetTopCountriesRequest{}
}

// GetTopCountries wraps GetTopCountriesWithContext using context.Background.
func (c *APIClient) GetTopCountries(r ApiGetTopCountriesRequest, opts ...Option) (*GetTopCountriesResponse, error) {
	return c.GetTopCountriesWithContext(context.Background(), r, opts...)
}

// @return GetTopCountriesResponse
func (c *APIClient) GetTopCountriesWithContext(ctx context.Context, r ApiGetTopCountriesRequest, opts ...Option) (*GetTopCountriesResponse, error) {
	var (
		postBody    any
		returnValue *GetTopCountriesResponse
	)

	requestPath := "/2/countries"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !isNilorEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetTopFilterAttributesRequest struct {
	index     string
	search    string
	startDate string
	endDate   string
	limit     int32
	offset    int32
	tags      string
}

func (r *ApiGetTopFilterAttributesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["search"]; ok { //search
		err = json.Unmarshal(v, &r.search)
		if err != nil {
			err = json.Unmarshal(b, &r.search)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["limit"]; ok { //limit
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["offset"]; ok { //offset
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetTopFilterAttributesRequest) WithIndex(index string) ApiGetTopFilterAttributesRequest {
	r.index = index
	return r
}

// The query term to search for. Must match the exact user input.
func (r ApiGetTopFilterAttributesRequest) WithSearch(search string) ApiGetTopFilterAttributesRequest {
	r.search = search
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetTopFilterAttributesRequest) WithStartDate(startDate string) ApiGetTopFilterAttributesRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetTopFilterAttributesRequest) WithEndDate(endDate string) ApiGetTopFilterAttributesRequest {
	r.endDate = endDate
	return r
}

// Number of records to return. Limit is the size of the page.
func (r ApiGetTopFilterAttributesRequest) WithLimit(limit int32) ApiGetTopFilterAttributesRequest {
	r.limit = limit
	return r
}

// Position of the starting record. Used for paging. 0 is the first record.
func (r ApiGetTopFilterAttributesRequest) WithOffset(offset int32) ApiGetTopFilterAttributesRequest {
	r.offset = offset
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetTopFilterAttributesRequest) WithTags(tags string) ApiGetTopFilterAttributesRequest {
	r.tags = tags
	return r
}

// @return ApiGetTopFilterAttributesRequest
func (c *APIClient) NewApiGetTopFilterAttributesRequest() ApiGetTopFilterAttributesRequest {
	return ApiGetTopFilterAttributesRequest{}
}

// GetTopFilterAttributes wraps GetTopFilterAttributesWithContext using context.Background.
func (c *APIClient) GetTopFilterAttributes(r ApiGetTopFilterAttributesRequest, opts ...Option) (*GetTopFilterAttributesResponse, error) {
	return c.GetTopFilterAttributesWithContext(context.Background(), r, opts...)
}

// @return GetTopFilterAttributesResponse
func (c *APIClient) GetTopFilterAttributesWithContext(ctx context.Context, r ApiGetTopFilterAttributesRequest, opts ...Option) (*GetTopFilterAttributesResponse, error) {
	var (
		postBody    any
		returnValue *GetTopFilterAttributesResponse
	)

	requestPath := "/2/filters"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.search) {
		queryParams.Set("search", parameterToString(r.search))
	}
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !isNilorEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetTopFilterForAttributeRequest struct {
	attribute string
	index     string
	search    string
	startDate string
	endDate   string
	limit     int32
	offset    int32
	tags      string
}

func (r *ApiGetTopFilterForAttributeRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["attribute"]; ok { //attribute
		err = json.Unmarshal(v, &r.attribute)
		if err != nil {
			err = json.Unmarshal(b, &r.attribute)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["search"]; ok { //search
		err = json.Unmarshal(v, &r.search)
		if err != nil {
			err = json.Unmarshal(b, &r.search)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["limit"]; ok { //limit
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["offset"]; ok { //offset
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetTopFilterForAttributeRequest) WithIndex(index string) ApiGetTopFilterForAttributeRequest {
	r.index = index
	return r
}

// The query term to search for. Must match the exact user input.
func (r ApiGetTopFilterForAttributeRequest) WithSearch(search string) ApiGetTopFilterForAttributeRequest {
	r.search = search
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetTopFilterForAttributeRequest) WithStartDate(startDate string) ApiGetTopFilterForAttributeRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetTopFilterForAttributeRequest) WithEndDate(endDate string) ApiGetTopFilterForAttributeRequest {
	r.endDate = endDate
	return r
}

// Number of records to return. Limit is the size of the page.
func (r ApiGetTopFilterForAttributeRequest) WithLimit(limit int32) ApiGetTopFilterForAttributeRequest {
	r.limit = limit
	return r
}

// Position of the starting record. Used for paging. 0 is the first record.
func (r ApiGetTopFilterForAttributeRequest) WithOffset(offset int32) ApiGetTopFilterForAttributeRequest {
	r.offset = offset
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetTopFilterForAttributeRequest) WithTags(tags string) ApiGetTopFilterForAttributeRequest {
	r.tags = tags
	return r
}

// @return ApiGetTopFilterForAttributeRequest
func (c *APIClient) NewApiGetTopFilterForAttributeRequest(attribute string) ApiGetTopFilterForAttributeRequest {
	return ApiGetTopFilterForAttributeRequest{
		attribute: attribute,
	}
}

// GetTopFilterForAttribute wraps GetTopFilterForAttributeWithContext using context.Background.
func (c *APIClient) GetTopFilterForAttribute(r ApiGetTopFilterForAttributeRequest, opts ...Option) (*GetTopFilterForAttributeResponse, error) {
	return c.GetTopFilterForAttributeWithContext(context.Background(), r, opts...)
}

// @return GetTopFilterForAttributeResponse
func (c *APIClient) GetTopFilterForAttributeWithContext(ctx context.Context, r ApiGetTopFilterForAttributeRequest, opts ...Option) (*GetTopFilterForAttributeResponse, error) {
	var (
		postBody    any
		returnValue *GetTopFilterForAttributeResponse
	)

	requestPath := "/2/filters/{attribute}"
	requestPath = strings.Replace(requestPath, "{"+"attribute"+"}", url.PathEscape(parameterToString(r.attribute)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.search) {
		queryParams.Set("search", parameterToString(r.search))
	}
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !isNilorEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetTopFiltersNoResultsRequest struct {
	index     string
	search    string
	startDate string
	endDate   string
	limit     int32
	offset    int32
	tags      string
}

func (r *ApiGetTopFiltersNoResultsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["search"]; ok { //search
		err = json.Unmarshal(v, &r.search)
		if err != nil {
			err = json.Unmarshal(b, &r.search)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["limit"]; ok { //limit
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["offset"]; ok { //offset
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetTopFiltersNoResultsRequest) WithIndex(index string) ApiGetTopFiltersNoResultsRequest {
	r.index = index
	return r
}

// The query term to search for. Must match the exact user input.
func (r ApiGetTopFiltersNoResultsRequest) WithSearch(search string) ApiGetTopFiltersNoResultsRequest {
	r.search = search
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetTopFiltersNoResultsRequest) WithStartDate(startDate string) ApiGetTopFiltersNoResultsRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetTopFiltersNoResultsRequest) WithEndDate(endDate string) ApiGetTopFiltersNoResultsRequest {
	r.endDate = endDate
	return r
}

// Number of records to return. Limit is the size of the page.
func (r ApiGetTopFiltersNoResultsRequest) WithLimit(limit int32) ApiGetTopFiltersNoResultsRequest {
	r.limit = limit
	return r
}

// Position of the starting record. Used for paging. 0 is the first record.
func (r ApiGetTopFiltersNoResultsRequest) WithOffset(offset int32) ApiGetTopFiltersNoResultsRequest {
	r.offset = offset
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetTopFiltersNoResultsRequest) WithTags(tags string) ApiGetTopFiltersNoResultsRequest {
	r.tags = tags
	return r
}

// @return ApiGetTopFiltersNoResultsRequest
func (c *APIClient) NewApiGetTopFiltersNoResultsRequest() ApiGetTopFiltersNoResultsRequest {
	return ApiGetTopFiltersNoResultsRequest{}
}

// GetTopFiltersNoResults wraps GetTopFiltersNoResultsWithContext using context.Background.
func (c *APIClient) GetTopFiltersNoResults(r ApiGetTopFiltersNoResultsRequest, opts ...Option) (*GetTopFiltersNoResultsResponse, error) {
	return c.GetTopFiltersNoResultsWithContext(context.Background(), r, opts...)
}

// @return GetTopFiltersNoResultsResponse
func (c *APIClient) GetTopFiltersNoResultsWithContext(ctx context.Context, r ApiGetTopFiltersNoResultsRequest, opts ...Option) (*GetTopFiltersNoResultsResponse, error) {
	var (
		postBody    any
		returnValue *GetTopFiltersNoResultsResponse
	)

	requestPath := "/2/filters/noResults"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.search) {
		queryParams.Set("search", parameterToString(r.search))
	}
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !isNilorEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetTopHitsRequest struct {
	index          string
	search         string
	clickAnalytics bool
	startDate      string
	endDate        string
	limit          int32
	offset         int32
	tags           string
}

func (r *ApiGetTopHitsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["search"]; ok { //search
		err = json.Unmarshal(v, &r.search)
		if err != nil {
			err = json.Unmarshal(b, &r.search)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["clickAnalytics"]; ok { //clickAnalytics
		err = json.Unmarshal(v, &r.clickAnalytics)
		if err != nil {
			err = json.Unmarshal(b, &r.clickAnalytics)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["limit"]; ok { //limit
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["offset"]; ok { //offset
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetTopHitsRequest) WithIndex(index string) ApiGetTopHitsRequest {
	r.index = index
	return r
}

// The query term to search for. Must match the exact user input.
func (r ApiGetTopHitsRequest) WithSearch(search string) ApiGetTopHitsRequest {
	r.search = search
	return r
}

// Whether to include the click-through and conversion rates for a search.
func (r ApiGetTopHitsRequest) WithClickAnalytics(clickAnalytics bool) ApiGetTopHitsRequest {
	r.clickAnalytics = clickAnalytics
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetTopHitsRequest) WithStartDate(startDate string) ApiGetTopHitsRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetTopHitsRequest) WithEndDate(endDate string) ApiGetTopHitsRequest {
	r.endDate = endDate
	return r
}

// Number of records to return. Limit is the size of the page.
func (r ApiGetTopHitsRequest) WithLimit(limit int32) ApiGetTopHitsRequest {
	r.limit = limit
	return r
}

// Position of the starting record. Used for paging. 0 is the first record.
func (r ApiGetTopHitsRequest) WithOffset(offset int32) ApiGetTopHitsRequest {
	r.offset = offset
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetTopHitsRequest) WithTags(tags string) ApiGetTopHitsRequest {
	r.tags = tags
	return r
}

// @return ApiGetTopHitsRequest
func (c *APIClient) NewApiGetTopHitsRequest() ApiGetTopHitsRequest {
	return ApiGetTopHitsRequest{}
}

// GetTopHits wraps GetTopHitsWithContext using context.Background.
func (c *APIClient) GetTopHits(r ApiGetTopHitsRequest, opts ...Option) (*GetTopHitsResponse, error) {
	return c.GetTopHitsWithContext(context.Background(), r, opts...)
}

// @return GetTopHitsResponse
func (c *APIClient) GetTopHitsWithContext(ctx context.Context, r ApiGetTopHitsRequest, opts ...Option) (*GetTopHitsResponse, error) {
	var (
		postBody    any
		returnValue *GetTopHitsResponse
	)

	requestPath := "/2/hits"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.search) {
		queryParams.Set("search", parameterToString(r.search))
	}
	if !isNilorEmpty(r.clickAnalytics) {
		queryParams.Set("clickAnalytics", parameterToString(r.clickAnalytics))
	}
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !isNilorEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetTopSearchesRequest struct {
	index          string
	clickAnalytics bool
	startDate      string
	endDate        string
	orderBy        *OrderBy
	direction      *Direction
	limit          int32
	offset         int32
	tags           string
}

func (r *ApiGetTopSearchesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["clickAnalytics"]; ok { //clickAnalytics
		err = json.Unmarshal(v, &r.clickAnalytics)
		if err != nil {
			err = json.Unmarshal(b, &r.clickAnalytics)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["orderBy"]; ok { //orderBy
		err = json.Unmarshal(v, &r.orderBy)
		if err != nil {
			err = json.Unmarshal(b, &r.orderBy)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["direction"]; ok { //direction
		err = json.Unmarshal(v, &r.direction)
		if err != nil {
			err = json.Unmarshal(b, &r.direction)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["limit"]; ok { //limit
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["offset"]; ok { //offset
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetTopSearchesRequest) WithIndex(index string) ApiGetTopSearchesRequest {
	r.index = index
	return r
}

// Whether to include the click-through and conversion rates for a search.
func (r ApiGetTopSearchesRequest) WithClickAnalytics(clickAnalytics bool) ApiGetTopSearchesRequest {
	r.clickAnalytics = clickAnalytics
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetTopSearchesRequest) WithStartDate(startDate string) ApiGetTopSearchesRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetTopSearchesRequest) WithEndDate(endDate string) ApiGetTopSearchesRequest {
	r.endDate = endDate
	return r
}

// Reorder the results.
func (r ApiGetTopSearchesRequest) WithOrderBy(orderBy *OrderBy) ApiGetTopSearchesRequest {
	r.orderBy = orderBy
	return r
}

// The sorting of the result.
func (r ApiGetTopSearchesRequest) WithDirection(direction *Direction) ApiGetTopSearchesRequest {
	r.direction = direction
	return r
}

// Number of records to return. Limit is the size of the page.
func (r ApiGetTopSearchesRequest) WithLimit(limit int32) ApiGetTopSearchesRequest {
	r.limit = limit
	return r
}

// Position of the starting record. Used for paging. 0 is the first record.
func (r ApiGetTopSearchesRequest) WithOffset(offset int32) ApiGetTopSearchesRequest {
	r.offset = offset
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetTopSearchesRequest) WithTags(tags string) ApiGetTopSearchesRequest {
	r.tags = tags
	return r
}

// @return ApiGetTopSearchesRequest
func (c *APIClient) NewApiGetTopSearchesRequest() ApiGetTopSearchesRequest {
	return ApiGetTopSearchesRequest{}
}

// GetTopSearches wraps GetTopSearchesWithContext using context.Background.
func (c *APIClient) GetTopSearches(r ApiGetTopSearchesRequest, opts ...Option) (*GetTopSearchesResponse, error) {
	return c.GetTopSearchesWithContext(context.Background(), r, opts...)
}

// @return GetTopSearchesResponse
func (c *APIClient) GetTopSearchesWithContext(ctx context.Context, r ApiGetTopSearchesRequest, opts ...Option) (*GetTopSearchesResponse, error) {
	var (
		postBody    any
		returnValue *GetTopSearchesResponse
	)

	requestPath := "/2/searches"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.clickAnalytics) {
		queryParams.Set("clickAnalytics", parameterToString(r.clickAnalytics))
	}
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.orderBy) {
		queryParams.Set("orderBy", parameterToString(*r.orderBy))
	}
	if !isNilorEmpty(r.direction) {
		queryParams.Set("direction", parameterToString(*r.direction))
	}
	if !isNilorEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !isNilorEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetUsersCountRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

func (r *ApiGetUsersCountRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["index"]; ok { //index
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok { //startDate
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok { //endDate
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["tags"]; ok { //tags
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The index name to target.
func (r ApiGetUsersCountRequest) WithIndex(index string) ApiGetUsersCountRequest {
	r.index = index
	return r
}

// The lower bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetUsersCountRequest) WithStartDate(startDate string) ApiGetUsersCountRequest {
	r.startDate = startDate
	return r
}

// The upper bound timestamp (a date, a string like \&quot;2006-01-02\&quot;) of the period to analyze.
func (r ApiGetUsersCountRequest) WithEndDate(endDate string) ApiGetUsersCountRequest {
	r.endDate = endDate
	return r
}

// Filter metrics on the provided tags. Each tag must correspond to an analyticsTags set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it should be URL encoded.
func (r ApiGetUsersCountRequest) WithTags(tags string) ApiGetUsersCountRequest {
	r.tags = tags
	return r
}

// @return ApiGetUsersCountRequest
func (c *APIClient) NewApiGetUsersCountRequest() ApiGetUsersCountRequest {
	return ApiGetUsersCountRequest{}
}

// GetUsersCount wraps GetUsersCountWithContext using context.Background.
func (c *APIClient) GetUsersCount(r ApiGetUsersCountRequest, opts ...Option) (*GetUsersCountResponse, error) {
	return c.GetUsersCountWithContext(context.Background(), r, opts...)
}

// @return GetUsersCountResponse
func (c *APIClient) GetUsersCountWithContext(ctx context.Context, r ApiGetUsersCountRequest, opts ...Option) (*GetUsersCountResponse, error) {
	var (
		postBody    any
		returnValue *GetUsersCountResponse
	)

	requestPath := "/2/users/count"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("index is required and must be specified")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !isNilorEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiPostRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

func (r *ApiPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok { //path
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok { //parameters
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok { //body
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// Query parameters to be applied to the current query.
func (r ApiPostRequest) WithParameters(parameters map[string]interface{}) ApiPostRequest {
	r.parameters = parameters
	return r
}

// The parameters to send with the custom request.
func (r ApiPostRequest) WithBody(body map[string]interface{}) ApiPostRequest {
	r.body = body
	return r
}

// @return ApiPostRequest
func (c *APIClient) NewApiPostRequest(path string) ApiPostRequest {
	return ApiPostRequest{
		path: path,
	}
}

// Post wraps PostWithContext using context.Background.
func (c *APIClient) Post(r ApiPostRequest, opts ...Option) (map[string]interface{}, error) {
	return c.PostWithContext(context.Background(), r, opts...)
}

// @return map[string]interface{}
func (c *APIClient) PostWithContext(ctx context.Context, r ApiPostRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiPutRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

func (r *ApiPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok { //path
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok { //parameters
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok { //body
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// Query parameters to be applied to the current query.
func (r ApiPutRequest) WithParameters(parameters map[string]interface{}) ApiPutRequest {
	r.parameters = parameters
	return r
}

// The parameters to send with the custom request.
func (r ApiPutRequest) WithBody(body map[string]interface{}) ApiPutRequest {
	r.body = body
	return r
}

// @return ApiPutRequest
func (c *APIClient) NewApiPutRequest(path string) ApiPutRequest {
	return ApiPutRequest{
		path: path,
	}
}

// Put wraps PutWithContext using context.Background.
func (c *APIClient) Put(r ApiPutRequest, opts ...Option) (map[string]interface{}, error) {
	return c.PutWithContext(context.Background(), r, opts...)
}

// @return map[string]interface{}
func (c *APIClient) PutWithContext(ctx context.Context, r ApiPutRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
