// File generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation.
package analytics

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       name,
		value:      parameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

func (r *ApiCustomDeleteRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomDeleteRequest represents the request with all the parameters for the API call.
type ApiCustomDeleteRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiCustomDeleteRequest creates an instance of the ApiCustomDeleteRequest to be used for the API call.
func (c *APIClient) NewApiCustomDeleteRequest(path string) ApiCustomDeleteRequest {
	return ApiCustomDeleteRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomDeleteRequest and returns the request for chaining.
func (r ApiCustomDeleteRequest) WithParameters(parameters map[string]interface{}) ApiCustomDeleteRequest {
	r.parameters = parameters
	return r
}

/*
CustomDelete Wraps CustomDeleteWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomDelete(r ApiCustomDeleteRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomDeleteWithContext(context.Background(), r, opts...)
}

/*
CustomDelete

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomDeleteWithContext(ctx context.Context, r ApiCustomDeleteRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomGetRequest represents the request with all the parameters for the API call.
type ApiCustomGetRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiCustomGetRequest creates an instance of the ApiCustomGetRequest to be used for the API call.
func (c *APIClient) NewApiCustomGetRequest(path string) ApiCustomGetRequest {
	return ApiCustomGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomGetRequest and returns the request for chaining.
func (r ApiCustomGetRequest) WithParameters(parameters map[string]interface{}) ApiCustomGetRequest {
	r.parameters = parameters
	return r
}

/*
CustomGet Wraps CustomGetWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomGet(r ApiCustomGetRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomGetWithContext(context.Background(), r, opts...)
}

/*
CustomGet

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomGetWithContext(ctx context.Context, r ApiCustomGetRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPostRequest represents the request with all the parameters for the API call.
type ApiCustomPostRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiCustomPostRequest creates an instance of the ApiCustomPostRequest to be used for the API call.
func (c *APIClient) NewApiCustomPostRequest(path string) ApiCustomPostRequest {
	return ApiCustomPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithParameters(parameters map[string]interface{}) ApiCustomPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithBody(body map[string]interface{}) ApiCustomPostRequest {
	r.body = body
	return r
}

/*
CustomPost Wraps CustomPostWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPost(r ApiCustomPostRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomPostWithContext(context.Background(), r, opts...)
}

/*
CustomPost

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPostWithContext(ctx context.Context, r ApiCustomPostRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPutRequest represents the request with all the parameters for the API call.
type ApiCustomPutRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiCustomPutRequest creates an instance of the ApiCustomPutRequest to be used for the API call.
func (c *APIClient) NewApiCustomPutRequest(path string) ApiCustomPutRequest {
	return ApiCustomPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithParameters(parameters map[string]interface{}) ApiCustomPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithBody(body map[string]interface{}) ApiCustomPutRequest {
	r.body = body
	return r
}

/*
CustomPut Wraps CustomPutWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPut(r ApiCustomPutRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomPutWithContext(context.Background(), r, opts...)
}

/*
CustomPut

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPutWithContext(ctx context.Context, r ApiCustomPutRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetAverageClickPositionRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetAverageClickPositionRequest represents the request with all the parameters for the API call.
type ApiGetAverageClickPositionRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

// NewApiGetAverageClickPositionRequest creates an instance of the ApiGetAverageClickPositionRequest to be used for the API call.
func (c *APIClient) NewApiGetAverageClickPositionRequest(index string) ApiGetAverageClickPositionRequest {
	return ApiGetAverageClickPositionRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetAverageClickPositionRequest and returns the request for chaining.
func (r ApiGetAverageClickPositionRequest) WithStartDate(startDate string) ApiGetAverageClickPositionRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetAverageClickPositionRequest and returns the request for chaining.
func (r ApiGetAverageClickPositionRequest) WithEndDate(endDate string) ApiGetAverageClickPositionRequest {
	r.endDate = endDate
	return r
}

// WithTags adds the tags to the ApiGetAverageClickPositionRequest and returns the request for chaining.
func (r ApiGetAverageClickPositionRequest) WithTags(tags string) ApiGetAverageClickPositionRequest {
	r.tags = tags
	return r
}

/*
GetAverageClickPosition Wraps GetAverageClickPositionWithContext using context.Background.

Return the average click position for the complete time range and for individual days.
> **Note**: If all `positions` have a `clickCount` of `0` or `null`, it means Algolia didn't receive any click events for tracked searches. A _tracked_ search is a search request where the `clickAnalytics` parameter is `true`.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetAverageClickPositionRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetAverageClickPositionResponse
*/
func (c *APIClient) GetAverageClickPosition(r ApiGetAverageClickPositionRequest, opts ...Option) (*GetAverageClickPositionResponse, error) {
	return c.GetAverageClickPositionWithContext(context.Background(), r, opts...)
}

/*
GetAverageClickPosition

Return the average click position for the complete time range and for individual days.
> **Note**: If all `positions` have a `clickCount` of `0` or `null`, it means Algolia didn't receive any click events for tracked searches. A _tracked_ search is a search request where the `clickAnalytics` parameter is `true`.

Request can be constructed by NewApiGetAverageClickPositionRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetAverageClickPositionResponse
*/
func (c *APIClient) GetAverageClickPositionWithContext(ctx context.Context, r ApiGetAverageClickPositionRequest, opts ...Option) (*GetAverageClickPositionResponse, error) {
	var (
		postBody    any
		returnValue *GetAverageClickPositionResponse
	)

	requestPath := "/2/clicks/averageClickPosition"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetAverageClickPosition`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetClickPositionsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetClickPositionsRequest represents the request with all the parameters for the API call.
type ApiGetClickPositionsRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

// NewApiGetClickPositionsRequest creates an instance of the ApiGetClickPositionsRequest to be used for the API call.
func (c *APIClient) NewApiGetClickPositionsRequest(index string) ApiGetClickPositionsRequest {
	return ApiGetClickPositionsRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetClickPositionsRequest and returns the request for chaining.
func (r ApiGetClickPositionsRequest) WithStartDate(startDate string) ApiGetClickPositionsRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetClickPositionsRequest and returns the request for chaining.
func (r ApiGetClickPositionsRequest) WithEndDate(endDate string) ApiGetClickPositionsRequest {
	r.endDate = endDate
	return r
}

// WithTags adds the tags to the ApiGetClickPositionsRequest and returns the request for chaining.
func (r ApiGetClickPositionsRequest) WithTags(tags string) ApiGetClickPositionsRequest {
	r.tags = tags
	return r
}

/*
GetClickPositions Wraps GetClickPositionsWithContext using context.Background.

Show the number of clicks events and their associated position in the search results.

> **Note**: If all `positions` have a `clickCount` of `0` or `null`, it means Algolia didn't receive any click events for tracked searches. A _tracked_ search is a search request where the `clickAnalytics` parameter is `true`.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetClickPositionsRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetClickPositionsResponse
*/
func (c *APIClient) GetClickPositions(r ApiGetClickPositionsRequest, opts ...Option) (*GetClickPositionsResponse, error) {
	return c.GetClickPositionsWithContext(context.Background(), r, opts...)
}

/*
GetClickPositions

Show the number of clicks events and their associated position in the search results.

> **Note**: If all `positions` have a `clickCount` of `0` or `null`, it means Algolia didn't receive any click events for tracked searches. A _tracked_ search is a search request where the `clickAnalytics` parameter is `true`.

Request can be constructed by NewApiGetClickPositionsRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetClickPositionsResponse
*/
func (c *APIClient) GetClickPositionsWithContext(ctx context.Context, r ApiGetClickPositionsRequest, opts ...Option) (*GetClickPositionsResponse, error) {
	var (
		postBody    any
		returnValue *GetClickPositionsResponse
	)

	requestPath := "/2/clicks/positions"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetClickPositions`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetClickThroughRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetClickThroughRateRequest represents the request with all the parameters for the API call.
type ApiGetClickThroughRateRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

// NewApiGetClickThroughRateRequest creates an instance of the ApiGetClickThroughRateRequest to be used for the API call.
func (c *APIClient) NewApiGetClickThroughRateRequest(index string) ApiGetClickThroughRateRequest {
	return ApiGetClickThroughRateRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetClickThroughRateRequest and returns the request for chaining.
func (r ApiGetClickThroughRateRequest) WithStartDate(startDate string) ApiGetClickThroughRateRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetClickThroughRateRequest and returns the request for chaining.
func (r ApiGetClickThroughRateRequest) WithEndDate(endDate string) ApiGetClickThroughRateRequest {
	r.endDate = endDate
	return r
}

// WithTags adds the tags to the ApiGetClickThroughRateRequest and returns the request for chaining.
func (r ApiGetClickThroughRateRequest) WithTags(tags string) ApiGetClickThroughRateRequest {
	r.tags = tags
	return r
}

/*
GetClickThroughRate Wraps GetClickThroughRateWithContext using context.Background.

Returns a [click-through rate (CTR)](https://www.algolia.com/doc/guides/search-analytics/concepts/metrics/#click-through-rate).

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetClickThroughRateRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetClickThroughRateResponse
*/
func (c *APIClient) GetClickThroughRate(r ApiGetClickThroughRateRequest, opts ...Option) (*GetClickThroughRateResponse, error) {
	return c.GetClickThroughRateWithContext(context.Background(), r, opts...)
}

/*
GetClickThroughRate

Returns a [click-through rate (CTR)](https://www.algolia.com/doc/guides/search-analytics/concepts/metrics/#click-through-rate).

Request can be constructed by NewApiGetClickThroughRateRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetClickThroughRateResponse
*/
func (c *APIClient) GetClickThroughRateWithContext(ctx context.Context, r ApiGetClickThroughRateRequest, opts ...Option) (*GetClickThroughRateResponse, error) {
	var (
		postBody    any
		returnValue *GetClickThroughRateResponse
	)

	requestPath := "/2/clicks/clickThroughRate"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetClickThroughRate`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetConversationRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetConversationRateRequest represents the request with all the parameters for the API call.
type ApiGetConversationRateRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

// NewApiGetConversationRateRequest creates an instance of the ApiGetConversationRateRequest to be used for the API call.
func (c *APIClient) NewApiGetConversationRateRequest(index string) ApiGetConversationRateRequest {
	return ApiGetConversationRateRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetConversationRateRequest and returns the request for chaining.
func (r ApiGetConversationRateRequest) WithStartDate(startDate string) ApiGetConversationRateRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetConversationRateRequest and returns the request for chaining.
func (r ApiGetConversationRateRequest) WithEndDate(endDate string) ApiGetConversationRateRequest {
	r.endDate = endDate
	return r
}

// WithTags adds the tags to the ApiGetConversationRateRequest and returns the request for chaining.
func (r ApiGetConversationRateRequest) WithTags(tags string) ApiGetConversationRateRequest {
	r.tags = tags
	return r
}

/*
GetConversationRate Wraps GetConversationRateWithContext using context.Background.

Return a [conversion rate](https://www.algolia.com/doc/guides/search-analytics/concepts/metrics/#conversion-rate).

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetConversationRateRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetConversationRateResponse
*/
func (c *APIClient) GetConversationRate(r ApiGetConversationRateRequest, opts ...Option) (*GetConversationRateResponse, error) {
	return c.GetConversationRateWithContext(context.Background(), r, opts...)
}

/*
GetConversationRate

Return a [conversion rate](https://www.algolia.com/doc/guides/search-analytics/concepts/metrics/#conversion-rate).

Request can be constructed by NewApiGetConversationRateRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetConversationRateResponse
*/
func (c *APIClient) GetConversationRateWithContext(ctx context.Context, r ApiGetConversationRateRequest, opts ...Option) (*GetConversationRateResponse, error) {
	var (
		postBody    any
		returnValue *GetConversationRateResponse
	)

	requestPath := "/2/conversions/conversionRate"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetConversationRate`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetNoClickRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetNoClickRateRequest represents the request with all the parameters for the API call.
type ApiGetNoClickRateRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

// NewApiGetNoClickRateRequest creates an instance of the ApiGetNoClickRateRequest to be used for the API call.
func (c *APIClient) NewApiGetNoClickRateRequest(index string) ApiGetNoClickRateRequest {
	return ApiGetNoClickRateRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetNoClickRateRequest and returns the request for chaining.
func (r ApiGetNoClickRateRequest) WithStartDate(startDate string) ApiGetNoClickRateRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetNoClickRateRequest and returns the request for chaining.
func (r ApiGetNoClickRateRequest) WithEndDate(endDate string) ApiGetNoClickRateRequest {
	r.endDate = endDate
	return r
}

// WithTags adds the tags to the ApiGetNoClickRateRequest and returns the request for chaining.
func (r ApiGetNoClickRateRequest) WithTags(tags string) ApiGetNoClickRateRequest {
	r.tags = tags
	return r
}

/*
GetNoClickRate Wraps GetNoClickRateWithContext using context.Background.

Returns the rate at which searches don't lead to any clicks. The endpoint returns a value for the complete given time range, as well as a value per day. It also returns the count of searches and searches without clicks.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetNoClickRateRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetNoClickRateResponse
*/
func (c *APIClient) GetNoClickRate(r ApiGetNoClickRateRequest, opts ...Option) (*GetNoClickRateResponse, error) {
	return c.GetNoClickRateWithContext(context.Background(), r, opts...)
}

/*
GetNoClickRate

Returns the rate at which searches don't lead to any clicks. The endpoint returns a value for the complete given time range, as well as a value per day. It also returns the count of searches and searches without clicks.

Request can be constructed by NewApiGetNoClickRateRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetNoClickRateResponse
*/
func (c *APIClient) GetNoClickRateWithContext(ctx context.Context, r ApiGetNoClickRateRequest, opts ...Option) (*GetNoClickRateResponse, error) {
	var (
		postBody    any
		returnValue *GetNoClickRateResponse
	)

	requestPath := "/2/searches/noClickRate"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetNoClickRate`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetNoResultsRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetNoResultsRateRequest represents the request with all the parameters for the API call.
type ApiGetNoResultsRateRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

// NewApiGetNoResultsRateRequest creates an instance of the ApiGetNoResultsRateRequest to be used for the API call.
func (c *APIClient) NewApiGetNoResultsRateRequest(index string) ApiGetNoResultsRateRequest {
	return ApiGetNoResultsRateRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetNoResultsRateRequest and returns the request for chaining.
func (r ApiGetNoResultsRateRequest) WithStartDate(startDate string) ApiGetNoResultsRateRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetNoResultsRateRequest and returns the request for chaining.
func (r ApiGetNoResultsRateRequest) WithEndDate(endDate string) ApiGetNoResultsRateRequest {
	r.endDate = endDate
	return r
}

// WithTags adds the tags to the ApiGetNoResultsRateRequest and returns the request for chaining.
func (r ApiGetNoResultsRateRequest) WithTags(tags string) ApiGetNoResultsRateRequest {
	r.tags = tags
	return r
}

/*
GetNoResultsRate Wraps GetNoResultsRateWithContext using context.Background.

Returns the rate at which searches didn't return any results.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetNoResultsRateRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetNoResultsRateResponse
*/
func (c *APIClient) GetNoResultsRate(r ApiGetNoResultsRateRequest, opts ...Option) (*GetNoResultsRateResponse, error) {
	return c.GetNoResultsRateWithContext(context.Background(), r, opts...)
}

/*
GetNoResultsRate

Returns the rate at which searches didn't return any results.

Request can be constructed by NewApiGetNoResultsRateRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetNoResultsRateResponse
*/
func (c *APIClient) GetNoResultsRateWithContext(ctx context.Context, r ApiGetNoResultsRateRequest, opts ...Option) (*GetNoResultsRateResponse, error) {
	var (
		postBody    any
		returnValue *GetNoResultsRateResponse
	)

	requestPath := "/2/searches/noResultRate"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetNoResultsRate`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSearchesCountRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSearchesCountRequest represents the request with all the parameters for the API call.
type ApiGetSearchesCountRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

// NewApiGetSearchesCountRequest creates an instance of the ApiGetSearchesCountRequest to be used for the API call.
func (c *APIClient) NewApiGetSearchesCountRequest(index string) ApiGetSearchesCountRequest {
	return ApiGetSearchesCountRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetSearchesCountRequest and returns the request for chaining.
func (r ApiGetSearchesCountRequest) WithStartDate(startDate string) ApiGetSearchesCountRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetSearchesCountRequest and returns the request for chaining.
func (r ApiGetSearchesCountRequest) WithEndDate(endDate string) ApiGetSearchesCountRequest {
	r.endDate = endDate
	return r
}

// WithTags adds the tags to the ApiGetSearchesCountRequest and returns the request for chaining.
func (r ApiGetSearchesCountRequest) WithTags(tags string) ApiGetSearchesCountRequest {
	r.tags = tags
	return r
}

/*
GetSearchesCount Wraps GetSearchesCountWithContext using context.Background.

Returns the number of searches within a time range.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetSearchesCountRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetSearchesCountResponse
*/
func (c *APIClient) GetSearchesCount(r ApiGetSearchesCountRequest, opts ...Option) (*GetSearchesCountResponse, error) {
	return c.GetSearchesCountWithContext(context.Background(), r, opts...)
}

/*
GetSearchesCount

Returns the number of searches within a time range.

Request can be constructed by NewApiGetSearchesCountRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetSearchesCountResponse
*/
func (c *APIClient) GetSearchesCountWithContext(ctx context.Context, r ApiGetSearchesCountRequest, opts ...Option) (*GetSearchesCountResponse, error) {
	var (
		postBody    any
		returnValue *GetSearchesCountResponse
	)

	requestPath := "/2/searches/count"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetSearchesCount`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSearchesNoClicksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSearchesNoClicksRequest represents the request with all the parameters for the API call.
type ApiGetSearchesNoClicksRequest struct {
	index     string
	startDate string
	endDate   string
	limit     int32
	offset    int32
	tags      string
}

// NewApiGetSearchesNoClicksRequest creates an instance of the ApiGetSearchesNoClicksRequest to be used for the API call.
func (c *APIClient) NewApiGetSearchesNoClicksRequest(index string) ApiGetSearchesNoClicksRequest {
	return ApiGetSearchesNoClicksRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetSearchesNoClicksRequest and returns the request for chaining.
func (r ApiGetSearchesNoClicksRequest) WithStartDate(startDate string) ApiGetSearchesNoClicksRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetSearchesNoClicksRequest and returns the request for chaining.
func (r ApiGetSearchesNoClicksRequest) WithEndDate(endDate string) ApiGetSearchesNoClicksRequest {
	r.endDate = endDate
	return r
}

// WithLimit adds the limit to the ApiGetSearchesNoClicksRequest and returns the request for chaining.
func (r ApiGetSearchesNoClicksRequest) WithLimit(limit int32) ApiGetSearchesNoClicksRequest {
	r.limit = limit
	return r
}

// WithOffset adds the offset to the ApiGetSearchesNoClicksRequest and returns the request for chaining.
func (r ApiGetSearchesNoClicksRequest) WithOffset(offset int32) ApiGetSearchesNoClicksRequest {
	r.offset = offset
	return r
}

// WithTags adds the tags to the ApiGetSearchesNoClicksRequest and returns the request for chaining.
func (r ApiGetSearchesNoClicksRequest) WithTags(tags string) ApiGetSearchesNoClicksRequest {
	r.tags = tags
	return r
}

/*
GetSearchesNoClicks Wraps GetSearchesNoClicksWithContext using context.Background.

Return the most popular of the last 1,000 searches that didn't lead to any clicks.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetSearchesNoClicksRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetSearchesNoClicksResponse
*/
func (c *APIClient) GetSearchesNoClicks(r ApiGetSearchesNoClicksRequest, opts ...Option) (*GetSearchesNoClicksResponse, error) {
	return c.GetSearchesNoClicksWithContext(context.Background(), r, opts...)
}

/*
GetSearchesNoClicks

Return the most popular of the last 1,000 searches that didn't lead to any clicks.

Request can be constructed by NewApiGetSearchesNoClicksRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetSearchesNoClicksResponse
*/
func (c *APIClient) GetSearchesNoClicksWithContext(ctx context.Context, r ApiGetSearchesNoClicksRequest, opts ...Option) (*GetSearchesNoClicksResponse, error) {
	var (
		postBody    any
		returnValue *GetSearchesNoClicksResponse
	)

	requestPath := "/2/searches/noClicks"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetSearchesNoClicks`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSearchesNoResultsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSearchesNoResultsRequest represents the request with all the parameters for the API call.
type ApiGetSearchesNoResultsRequest struct {
	index     string
	startDate string
	endDate   string
	limit     int32
	offset    int32
	tags      string
}

// NewApiGetSearchesNoResultsRequest creates an instance of the ApiGetSearchesNoResultsRequest to be used for the API call.
func (c *APIClient) NewApiGetSearchesNoResultsRequest(index string) ApiGetSearchesNoResultsRequest {
	return ApiGetSearchesNoResultsRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetSearchesNoResultsRequest and returns the request for chaining.
func (r ApiGetSearchesNoResultsRequest) WithStartDate(startDate string) ApiGetSearchesNoResultsRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetSearchesNoResultsRequest and returns the request for chaining.
func (r ApiGetSearchesNoResultsRequest) WithEndDate(endDate string) ApiGetSearchesNoResultsRequest {
	r.endDate = endDate
	return r
}

// WithLimit adds the limit to the ApiGetSearchesNoResultsRequest and returns the request for chaining.
func (r ApiGetSearchesNoResultsRequest) WithLimit(limit int32) ApiGetSearchesNoResultsRequest {
	r.limit = limit
	return r
}

// WithOffset adds the offset to the ApiGetSearchesNoResultsRequest and returns the request for chaining.
func (r ApiGetSearchesNoResultsRequest) WithOffset(offset int32) ApiGetSearchesNoResultsRequest {
	r.offset = offset
	return r
}

// WithTags adds the tags to the ApiGetSearchesNoResultsRequest and returns the request for chaining.
func (r ApiGetSearchesNoResultsRequest) WithTags(tags string) ApiGetSearchesNoResultsRequest {
	r.tags = tags
	return r
}

/*
GetSearchesNoResults Wraps GetSearchesNoResultsWithContext using context.Background.

Returns the most popular of the latest 1,000 searches that didn't return any results.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetSearchesNoResultsRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetSearchesNoResultsResponse
*/
func (c *APIClient) GetSearchesNoResults(r ApiGetSearchesNoResultsRequest, opts ...Option) (*GetSearchesNoResultsResponse, error) {
	return c.GetSearchesNoResultsWithContext(context.Background(), r, opts...)
}

/*
GetSearchesNoResults

Returns the most popular of the latest 1,000 searches that didn't return any results.

Request can be constructed by NewApiGetSearchesNoResultsRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetSearchesNoResultsResponse
*/
func (c *APIClient) GetSearchesNoResultsWithContext(ctx context.Context, r ApiGetSearchesNoResultsRequest, opts ...Option) (*GetSearchesNoResultsResponse, error) {
	var (
		postBody    any
		returnValue *GetSearchesNoResultsResponse
	)

	requestPath := "/2/searches/noResults"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetSearchesNoResults`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetStatusRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}

	return nil
}

// ApiGetStatusRequest represents the request with all the parameters for the API call.
type ApiGetStatusRequest struct {
	index string
}

// NewApiGetStatusRequest creates an instance of the ApiGetStatusRequest to be used for the API call.
func (c *APIClient) NewApiGetStatusRequest(index string) ApiGetStatusRequest {
	return ApiGetStatusRequest{
		index: index,
	}
}

/*
GetStatus Wraps GetStatusWithContext using context.Background.

Return the latest update time of the Analytics API for an index. If the index has been recently created or no search has been performed yet, `updatedAt` will be `null`.
> **Note**: The Analytics API is updated every 5&nbsp;minutes.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetStatusRequest with parameters below.

	@param index string - Index name to target.
	@return GetStatusResponse
*/
func (c *APIClient) GetStatus(r ApiGetStatusRequest, opts ...Option) (*GetStatusResponse, error) {
	return c.GetStatusWithContext(context.Background(), r, opts...)
}

/*
GetStatus

Return the latest update time of the Analytics API for an index. If the index has been recently created or no search has been performed yet, `updatedAt` will be `null`.
> **Note**: The Analytics API is updated every 5&nbsp;minutes.

Request can be constructed by NewApiGetStatusRequest with parameters below.

	@param index string - Index name to target.
	@return GetStatusResponse
*/
func (c *APIClient) GetStatusWithContext(ctx context.Context, r ApiGetStatusRequest, opts ...Option) (*GetStatusResponse, error) {
	var (
		postBody    any
		returnValue *GetStatusResponse
	)

	requestPath := "/2/status"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetStatus`.")
	}

	queryParams.Set("index", parameterToString(r.index))

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTopCountriesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTopCountriesRequest represents the request with all the parameters for the API call.
type ApiGetTopCountriesRequest struct {
	index     string
	startDate string
	endDate   string
	limit     int32
	offset    int32
	tags      string
}

// NewApiGetTopCountriesRequest creates an instance of the ApiGetTopCountriesRequest to be used for the API call.
func (c *APIClient) NewApiGetTopCountriesRequest(index string) ApiGetTopCountriesRequest {
	return ApiGetTopCountriesRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetTopCountriesRequest and returns the request for chaining.
func (r ApiGetTopCountriesRequest) WithStartDate(startDate string) ApiGetTopCountriesRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetTopCountriesRequest and returns the request for chaining.
func (r ApiGetTopCountriesRequest) WithEndDate(endDate string) ApiGetTopCountriesRequest {
	r.endDate = endDate
	return r
}

// WithLimit adds the limit to the ApiGetTopCountriesRequest and returns the request for chaining.
func (r ApiGetTopCountriesRequest) WithLimit(limit int32) ApiGetTopCountriesRequest {
	r.limit = limit
	return r
}

// WithOffset adds the offset to the ApiGetTopCountriesRequest and returns the request for chaining.
func (r ApiGetTopCountriesRequest) WithOffset(offset int32) ApiGetTopCountriesRequest {
	r.offset = offset
	return r
}

// WithTags adds the tags to the ApiGetTopCountriesRequest and returns the request for chaining.
func (r ApiGetTopCountriesRequest) WithTags(tags string) ApiGetTopCountriesRequest {
	r.tags = tags
	return r
}

/*
GetTopCountries Wraps GetTopCountriesWithContext using context.Background.

Returns top countries. Limited to the 1,000 most frequent ones.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetTopCountriesRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetTopCountriesResponse
*/
func (c *APIClient) GetTopCountries(r ApiGetTopCountriesRequest, opts ...Option) (*GetTopCountriesResponse, error) {
	return c.GetTopCountriesWithContext(context.Background(), r, opts...)
}

/*
GetTopCountries

Returns top countries. Limited to the 1,000 most frequent ones.

Request can be constructed by NewApiGetTopCountriesRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetTopCountriesResponse
*/
func (c *APIClient) GetTopCountriesWithContext(ctx context.Context, r ApiGetTopCountriesRequest, opts ...Option) (*GetTopCountriesResponse, error) {
	var (
		postBody    any
		returnValue *GetTopCountriesResponse
	)

	requestPath := "/2/countries"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetTopCountries`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTopFilterAttributesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["search"]; ok {
		err = json.Unmarshal(v, &r.search)
		if err != nil {
			err = json.Unmarshal(b, &r.search)
			if err != nil {
				return fmt.Errorf("cannot unmarshal search: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTopFilterAttributesRequest represents the request with all the parameters for the API call.
type ApiGetTopFilterAttributesRequest struct {
	index     string
	search    string
	startDate string
	endDate   string
	limit     int32
	offset    int32
	tags      string
}

// NewApiGetTopFilterAttributesRequest creates an instance of the ApiGetTopFilterAttributesRequest to be used for the API call.
func (c *APIClient) NewApiGetTopFilterAttributesRequest(index string) ApiGetTopFilterAttributesRequest {
	return ApiGetTopFilterAttributesRequest{
		index: index,
	}
}

// WithSearch adds the search to the ApiGetTopFilterAttributesRequest and returns the request for chaining.
func (r ApiGetTopFilterAttributesRequest) WithSearch(search string) ApiGetTopFilterAttributesRequest {
	r.search = search
	return r
}

// WithStartDate adds the startDate to the ApiGetTopFilterAttributesRequest and returns the request for chaining.
func (r ApiGetTopFilterAttributesRequest) WithStartDate(startDate string) ApiGetTopFilterAttributesRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetTopFilterAttributesRequest and returns the request for chaining.
func (r ApiGetTopFilterAttributesRequest) WithEndDate(endDate string) ApiGetTopFilterAttributesRequest {
	r.endDate = endDate
	return r
}

// WithLimit adds the limit to the ApiGetTopFilterAttributesRequest and returns the request for chaining.
func (r ApiGetTopFilterAttributesRequest) WithLimit(limit int32) ApiGetTopFilterAttributesRequest {
	r.limit = limit
	return r
}

// WithOffset adds the offset to the ApiGetTopFilterAttributesRequest and returns the request for chaining.
func (r ApiGetTopFilterAttributesRequest) WithOffset(offset int32) ApiGetTopFilterAttributesRequest {
	r.offset = offset
	return r
}

// WithTags adds the tags to the ApiGetTopFilterAttributesRequest and returns the request for chaining.
func (r ApiGetTopFilterAttributesRequest) WithTags(tags string) ApiGetTopFilterAttributesRequest {
	r.tags = tags
	return r
}

/*
GetTopFilterAttributes Wraps GetTopFilterAttributesWithContext using context.Background.

Return the most popular [filterable attributes](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering/) in the 1,000 most recently used filters.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetTopFilterAttributesRequest with parameters below.

	@param index string - Index name to target.
	@param search string - User query.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetTopFilterAttributesResponse
*/
func (c *APIClient) GetTopFilterAttributes(r ApiGetTopFilterAttributesRequest, opts ...Option) (*GetTopFilterAttributesResponse, error) {
	return c.GetTopFilterAttributesWithContext(context.Background(), r, opts...)
}

/*
GetTopFilterAttributes

Return the most popular [filterable attributes](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering/) in the 1,000 most recently used filters.

Request can be constructed by NewApiGetTopFilterAttributesRequest with parameters below.

	@param index string - Index name to target.
	@param search string - User query.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetTopFilterAttributesResponse
*/
func (c *APIClient) GetTopFilterAttributesWithContext(ctx context.Context, r ApiGetTopFilterAttributesRequest, opts ...Option) (*GetTopFilterAttributesResponse, error) {
	var (
		postBody    any
		returnValue *GetTopFilterAttributesResponse
	)

	requestPath := "/2/filters"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetTopFilterAttributes`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.search) {
		queryParams.Set("search", parameterToString(r.search))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTopFilterForAttributeRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["attribute"]; ok {
		err = json.Unmarshal(v, &r.attribute)
		if err != nil {
			err = json.Unmarshal(b, &r.attribute)
			if err != nil {
				return fmt.Errorf("cannot unmarshal attribute: %w", err)
			}
		}
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["search"]; ok {
		err = json.Unmarshal(v, &r.search)
		if err != nil {
			err = json.Unmarshal(b, &r.search)
			if err != nil {
				return fmt.Errorf("cannot unmarshal search: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTopFilterForAttributeRequest represents the request with all the parameters for the API call.
type ApiGetTopFilterForAttributeRequest struct {
	attribute string
	index     string
	search    string
	startDate string
	endDate   string
	limit     int32
	offset    int32
	tags      string
}

// NewApiGetTopFilterForAttributeRequest creates an instance of the ApiGetTopFilterForAttributeRequest to be used for the API call.
func (c *APIClient) NewApiGetTopFilterForAttributeRequest(attribute string, index string) ApiGetTopFilterForAttributeRequest {
	return ApiGetTopFilterForAttributeRequest{
		attribute: attribute,
		index:     index,
	}
}

// WithSearch adds the search to the ApiGetTopFilterForAttributeRequest and returns the request for chaining.
func (r ApiGetTopFilterForAttributeRequest) WithSearch(search string) ApiGetTopFilterForAttributeRequest {
	r.search = search
	return r
}

// WithStartDate adds the startDate to the ApiGetTopFilterForAttributeRequest and returns the request for chaining.
func (r ApiGetTopFilterForAttributeRequest) WithStartDate(startDate string) ApiGetTopFilterForAttributeRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetTopFilterForAttributeRequest and returns the request for chaining.
func (r ApiGetTopFilterForAttributeRequest) WithEndDate(endDate string) ApiGetTopFilterForAttributeRequest {
	r.endDate = endDate
	return r
}

// WithLimit adds the limit to the ApiGetTopFilterForAttributeRequest and returns the request for chaining.
func (r ApiGetTopFilterForAttributeRequest) WithLimit(limit int32) ApiGetTopFilterForAttributeRequest {
	r.limit = limit
	return r
}

// WithOffset adds the offset to the ApiGetTopFilterForAttributeRequest and returns the request for chaining.
func (r ApiGetTopFilterForAttributeRequest) WithOffset(offset int32) ApiGetTopFilterForAttributeRequest {
	r.offset = offset
	return r
}

// WithTags adds the tags to the ApiGetTopFilterForAttributeRequest and returns the request for chaining.
func (r ApiGetTopFilterForAttributeRequest) WithTags(tags string) ApiGetTopFilterForAttributeRequest {
	r.tags = tags
	return r
}

/*
GetTopFilterForAttribute Wraps GetTopFilterForAttributeWithContext using context.Background.

Returns the most popular filter values for an attribute in the 1,000 most recently used filters.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetTopFilterForAttributeRequest with parameters below.

	@param attribute string - Attribute name.
	@param index string - Index name to target.
	@param search string - User query.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetTopFilterForAttributeResponse
*/
func (c *APIClient) GetTopFilterForAttribute(r ApiGetTopFilterForAttributeRequest, opts ...Option) (*GetTopFilterForAttributeResponse, error) {
	return c.GetTopFilterForAttributeWithContext(context.Background(), r, opts...)
}

/*
GetTopFilterForAttribute

Returns the most popular filter values for an attribute in the 1,000 most recently used filters.

Request can be constructed by NewApiGetTopFilterForAttributeRequest with parameters below.

	@param attribute string - Attribute name.
	@param index string - Index name to target.
	@param search string - User query.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetTopFilterForAttributeResponse
*/
func (c *APIClient) GetTopFilterForAttributeWithContext(ctx context.Context, r ApiGetTopFilterForAttributeRequest, opts ...Option) (*GetTopFilterForAttributeResponse, error) {
	var (
		postBody    any
		returnValue *GetTopFilterForAttributeResponse
	)

	requestPath := "/2/filters/{attribute}"
	requestPath = strings.ReplaceAll(requestPath, "{attribute}", url.PathEscape(parameterToString(r.attribute)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.attribute == "" {
		return returnValue, reportError("Parameter `attribute` is required when calling `GetTopFilterForAttribute`.")
	}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetTopFilterForAttribute`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.search) {
		queryParams.Set("search", parameterToString(r.search))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTopFiltersNoResultsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["search"]; ok {
		err = json.Unmarshal(v, &r.search)
		if err != nil {
			err = json.Unmarshal(b, &r.search)
			if err != nil {
				return fmt.Errorf("cannot unmarshal search: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTopFiltersNoResultsRequest represents the request with all the parameters for the API call.
type ApiGetTopFiltersNoResultsRequest struct {
	index     string
	search    string
	startDate string
	endDate   string
	limit     int32
	offset    int32
	tags      string
}

// NewApiGetTopFiltersNoResultsRequest creates an instance of the ApiGetTopFiltersNoResultsRequest to be used for the API call.
func (c *APIClient) NewApiGetTopFiltersNoResultsRequest(index string) ApiGetTopFiltersNoResultsRequest {
	return ApiGetTopFiltersNoResultsRequest{
		index: index,
	}
}

// WithSearch adds the search to the ApiGetTopFiltersNoResultsRequest and returns the request for chaining.
func (r ApiGetTopFiltersNoResultsRequest) WithSearch(search string) ApiGetTopFiltersNoResultsRequest {
	r.search = search
	return r
}

// WithStartDate adds the startDate to the ApiGetTopFiltersNoResultsRequest and returns the request for chaining.
func (r ApiGetTopFiltersNoResultsRequest) WithStartDate(startDate string) ApiGetTopFiltersNoResultsRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetTopFiltersNoResultsRequest and returns the request for chaining.
func (r ApiGetTopFiltersNoResultsRequest) WithEndDate(endDate string) ApiGetTopFiltersNoResultsRequest {
	r.endDate = endDate
	return r
}

// WithLimit adds the limit to the ApiGetTopFiltersNoResultsRequest and returns the request for chaining.
func (r ApiGetTopFiltersNoResultsRequest) WithLimit(limit int32) ApiGetTopFiltersNoResultsRequest {
	r.limit = limit
	return r
}

// WithOffset adds the offset to the ApiGetTopFiltersNoResultsRequest and returns the request for chaining.
func (r ApiGetTopFiltersNoResultsRequest) WithOffset(offset int32) ApiGetTopFiltersNoResultsRequest {
	r.offset = offset
	return r
}

// WithTags adds the tags to the ApiGetTopFiltersNoResultsRequest and returns the request for chaining.
func (r ApiGetTopFiltersNoResultsRequest) WithTags(tags string) ApiGetTopFiltersNoResultsRequest {
	r.tags = tags
	return r
}

/*
GetTopFiltersNoResults Wraps GetTopFiltersNoResultsWithContext using context.Background.

Returns top filters for filter-enabled searches that don't return results. Limited to the 1,000 most recently used filters.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetTopFiltersNoResultsRequest with parameters below.

	@param index string - Index name to target.
	@param search string - User query.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetTopFiltersNoResultsResponse
*/
func (c *APIClient) GetTopFiltersNoResults(r ApiGetTopFiltersNoResultsRequest, opts ...Option) (*GetTopFiltersNoResultsResponse, error) {
	return c.GetTopFiltersNoResultsWithContext(context.Background(), r, opts...)
}

/*
GetTopFiltersNoResults

Returns top filters for filter-enabled searches that don't return results. Limited to the 1,000 most recently used filters.

Request can be constructed by NewApiGetTopFiltersNoResultsRequest with parameters below.

	@param index string - Index name to target.
	@param search string - User query.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetTopFiltersNoResultsResponse
*/
func (c *APIClient) GetTopFiltersNoResultsWithContext(ctx context.Context, r ApiGetTopFiltersNoResultsRequest, opts ...Option) (*GetTopFiltersNoResultsResponse, error) {
	var (
		postBody    any
		returnValue *GetTopFiltersNoResultsResponse
	)

	requestPath := "/2/filters/noResults"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetTopFiltersNoResults`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.search) {
		queryParams.Set("search", parameterToString(r.search))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTopHitsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["search"]; ok {
		err = json.Unmarshal(v, &r.search)
		if err != nil {
			err = json.Unmarshal(b, &r.search)
			if err != nil {
				return fmt.Errorf("cannot unmarshal search: %w", err)
			}
		}
	}
	if v, ok := req["clickAnalytics"]; ok {
		err = json.Unmarshal(v, &r.clickAnalytics)
		if err != nil {
			err = json.Unmarshal(b, &r.clickAnalytics)
			if err != nil {
				return fmt.Errorf("cannot unmarshal clickAnalytics: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTopHitsRequest represents the request with all the parameters for the API call.
type ApiGetTopHitsRequest struct {
	index          string
	search         string
	clickAnalytics bool
	startDate      string
	endDate        string
	limit          int32
	offset         int32
	tags           string
}

// NewApiGetTopHitsRequest creates an instance of the ApiGetTopHitsRequest to be used for the API call.
func (c *APIClient) NewApiGetTopHitsRequest(index string) ApiGetTopHitsRequest {
	return ApiGetTopHitsRequest{
		index: index,
	}
}

// WithSearch adds the search to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithSearch(search string) ApiGetTopHitsRequest {
	r.search = search
	return r
}

// WithClickAnalytics adds the clickAnalytics to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithClickAnalytics(clickAnalytics bool) ApiGetTopHitsRequest {
	r.clickAnalytics = clickAnalytics
	return r
}

// WithStartDate adds the startDate to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithStartDate(startDate string) ApiGetTopHitsRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithEndDate(endDate string) ApiGetTopHitsRequest {
	r.endDate = endDate
	return r
}

// WithLimit adds the limit to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithLimit(limit int32) ApiGetTopHitsRequest {
	r.limit = limit
	return r
}

// WithOffset adds the offset to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithOffset(offset int32) ApiGetTopHitsRequest {
	r.offset = offset
	return r
}

// WithTags adds the tags to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithTags(tags string) ApiGetTopHitsRequest {
	r.tags = tags
	return r
}

/*
GetTopHits Wraps GetTopHitsWithContext using context.Background.

Return the most popular clicked results in the last 1,000 searches.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetTopHitsRequest with parameters below.

	@param index string - Index name to target.
	@param search string - User query.
	@param clickAnalytics bool - Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetTopHitsResponse
*/
func (c *APIClient) GetTopHits(r ApiGetTopHitsRequest, opts ...Option) (*GetTopHitsResponse, error) {
	return c.GetTopHitsWithContext(context.Background(), r, opts...)
}

/*
GetTopHits

Return the most popular clicked results in the last 1,000 searches.

Request can be constructed by NewApiGetTopHitsRequest with parameters below.

	@param index string - Index name to target.
	@param search string - User query.
	@param clickAnalytics bool - Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetTopHitsResponse
*/
func (c *APIClient) GetTopHitsWithContext(ctx context.Context, r ApiGetTopHitsRequest, opts ...Option) (*GetTopHitsResponse, error) {
	var (
		postBody    any
		returnValue *GetTopHitsResponse
	)

	requestPath := "/2/hits"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetTopHits`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.search) {
		queryParams.Set("search", parameterToString(r.search))
	}
	if !utils.IsNilOrEmpty(r.clickAnalytics) {
		queryParams.Set("clickAnalytics", parameterToString(r.clickAnalytics))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTopSearchesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["clickAnalytics"]; ok {
		err = json.Unmarshal(v, &r.clickAnalytics)
		if err != nil {
			err = json.Unmarshal(b, &r.clickAnalytics)
			if err != nil {
				return fmt.Errorf("cannot unmarshal clickAnalytics: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["orderBy"]; ok {
		err = json.Unmarshal(v, &r.orderBy)
		if err != nil {
			err = json.Unmarshal(b, &r.orderBy)
			if err != nil {
				return fmt.Errorf("cannot unmarshal orderBy: %w", err)
			}
		}
	}
	if v, ok := req["direction"]; ok {
		err = json.Unmarshal(v, &r.direction)
		if err != nil {
			err = json.Unmarshal(b, &r.direction)
			if err != nil {
				return fmt.Errorf("cannot unmarshal direction: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTopSearchesRequest represents the request with all the parameters for the API call.
type ApiGetTopSearchesRequest struct {
	index          string
	clickAnalytics bool
	startDate      string
	endDate        string
	orderBy        OrderBy
	direction      Direction
	limit          int32
	offset         int32
	tags           string
}

// NewApiGetTopSearchesRequest creates an instance of the ApiGetTopSearchesRequest to be used for the API call.
func (c *APIClient) NewApiGetTopSearchesRequest(index string) ApiGetTopSearchesRequest {
	return ApiGetTopSearchesRequest{
		index: index,
	}
}

// WithClickAnalytics adds the clickAnalytics to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithClickAnalytics(clickAnalytics bool) ApiGetTopSearchesRequest {
	r.clickAnalytics = clickAnalytics
	return r
}

// WithStartDate adds the startDate to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithStartDate(startDate string) ApiGetTopSearchesRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithEndDate(endDate string) ApiGetTopSearchesRequest {
	r.endDate = endDate
	return r
}

// WithOrderBy adds the orderBy to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithOrderBy(orderBy OrderBy) ApiGetTopSearchesRequest {
	r.orderBy = orderBy
	return r
}

// WithDirection adds the direction to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithDirection(direction Direction) ApiGetTopSearchesRequest {
	r.direction = direction
	return r
}

// WithLimit adds the limit to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithLimit(limit int32) ApiGetTopSearchesRequest {
	r.limit = limit
	return r
}

// WithOffset adds the offset to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithOffset(offset int32) ApiGetTopSearchesRequest {
	r.offset = offset
	return r
}

// WithTags adds the tags to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithTags(tags string) ApiGetTopSearchesRequest {
	r.tags = tags
	return r
}

/*
GetTopSearches Wraps GetTopSearchesWithContext using context.Background.

Returns the most popular of the latest 1,000 searches. For each search, also returns the number of hits.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetTopSearchesRequest with parameters below.

	@param index string - Index name to target.
	@param clickAnalytics bool - Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param orderBy OrderBy - Reorder the results.
	@param direction Direction - Sorting direction of the results: ascending or descending.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetTopSearchesResponse
*/
func (c *APIClient) GetTopSearches(r ApiGetTopSearchesRequest, opts ...Option) (*GetTopSearchesResponse, error) {
	return c.GetTopSearchesWithContext(context.Background(), r, opts...)
}

/*
GetTopSearches

Returns the most popular of the latest 1,000 searches. For each search, also returns the number of hits.

Request can be constructed by NewApiGetTopSearchesRequest with parameters below.

	@param index string - Index name to target.
	@param clickAnalytics bool - Whether to include [click and conversion](https://www.algolia.com/doc/guides/sending-events/getting-started/) rates for a search.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param orderBy OrderBy - Reorder the results.
	@param direction Direction - Sorting direction of the results: ascending or descending.
	@param limit int32 - Number of records to return (page size).
	@param offset int32 - Position of the starting record. Used for paging. 0 is the first record.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetTopSearchesResponse
*/
func (c *APIClient) GetTopSearchesWithContext(ctx context.Context, r ApiGetTopSearchesRequest, opts ...Option) (*GetTopSearchesResponse, error) {
	var (
		postBody    any
		returnValue *GetTopSearchesResponse
	)

	requestPath := "/2/searches"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetTopSearches`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.clickAnalytics) {
		queryParams.Set("clickAnalytics", parameterToString(r.clickAnalytics))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.orderBy) {
		queryParams.Set("orderBy", parameterToString(r.orderBy))
	}
	if !utils.IsNilOrEmpty(r.direction) {
		queryParams.Set("direction", parameterToString(r.direction))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		queryParams.Set("limit", parameterToString(r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetUsersCountRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetUsersCountRequest represents the request with all the parameters for the API call.
type ApiGetUsersCountRequest struct {
	index     string
	startDate string
	endDate   string
	tags      string
}

// NewApiGetUsersCountRequest creates an instance of the ApiGetUsersCountRequest to be used for the API call.
func (c *APIClient) NewApiGetUsersCountRequest(index string) ApiGetUsersCountRequest {
	return ApiGetUsersCountRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetUsersCountRequest and returns the request for chaining.
func (r ApiGetUsersCountRequest) WithStartDate(startDate string) ApiGetUsersCountRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetUsersCountRequest and returns the request for chaining.
func (r ApiGetUsersCountRequest) WithEndDate(endDate string) ApiGetUsersCountRequest {
	r.endDate = endDate
	return r
}

// WithTags adds the tags to the ApiGetUsersCountRequest and returns the request for chaining.
func (r ApiGetUsersCountRequest) WithTags(tags string) ApiGetUsersCountRequest {
	r.tags = tags
	return r
}

/*
GetUsersCount Wraps GetUsersCountWithContext using context.Background.

Return the count of unique users.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetUsersCountRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetUsersCountResponse
*/
func (c *APIClient) GetUsersCount(r ApiGetUsersCountRequest, opts ...Option) (*GetUsersCountResponse, error) {
	return c.GetUsersCountWithContext(context.Background(), r, opts...)
}

/*
GetUsersCount

Return the count of unique users.

Request can be constructed by NewApiGetUsersCountRequest with parameters below.

	@param index string - Index name to target.
	@param startDate string - Start date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param endDate string - End date (a string in the format `YYYY-MM-DD`) of the period to analyze.
	@param tags string - Filter analytics on the [`analyticsTags`](https://www.algolia.com/doc/api-reference/api-parameters/analyticsTags/) set at search time. Multiple tags can be combined with the operators OR and AND. If a tag contains characters like spaces or parentheses, it must be URL-encoded.
	@return GetUsersCountResponse
*/
func (c *APIClient) GetUsersCountWithContext(ctx context.Context, r ApiGetUsersCountRequest, opts ...Option) (*GetUsersCountResponse, error) {
	var (
		postBody    any
		returnValue *GetUsersCountResponse
	)

	requestPath := "/2/users/count"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.index == "" {
		return returnValue, reportError("Parameter `index` is required when calling `GetUsersCount`.")
	}

	queryParams.Set("index", parameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		queryParams.Set("tags", parameterToString(r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
