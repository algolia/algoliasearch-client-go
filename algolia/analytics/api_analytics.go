// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package analytics

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/transport"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type config struct {
	// -- Request options for API calls
	context      context.Context
	queryParams  url.Values
	headerParams map[string]string
	timeouts     transport.RequestConfiguration
}

type RequestOption interface {
	apply(*config)
}

type requestOption func(*config)

func (r requestOption) apply(c *config) {
	r(c)
}

func WithContext(ctx context.Context) requestOption {
	return requestOption(func(c *config) {
		c.context = ctx
	})
}

func WithHeaderParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.headerParams[key] = utils.ParameterToString(value)
	})
}

func WithQueryParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.queryParams.Set(utils.QueryParameterToString(key), utils.QueryParameterToString(value))
	})
}

func WithReadTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ReadTimeout = &timeout
	})
}

func WithWriteTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.WriteTimeout = &timeout
	})
}

func WithConnectTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ConnectTimeout = &timeout
	})
}

func (r *ApiCustomDeleteRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomDeleteRequest represents the request with all the parameters for the API call.
type ApiCustomDeleteRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomDeleteRequest creates an instance of the ApiCustomDeleteRequest to be used for the API call.
func (c *APIClient) NewApiCustomDeleteRequest(path string) ApiCustomDeleteRequest {
	return ApiCustomDeleteRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomDeleteRequest and returns the request for chaining.
func (r ApiCustomDeleteRequest) WithParameters(parameters map[string]any) ApiCustomDeleteRequest {
	r.parameters = parameters
	return r
}

/*
CustomDelete calls the API and returns the raw response from it.

	  This method lets you send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomDeleteRequest with parameters below.
	  @param path string - Path of the endpoint, for example `1/newFeature`.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomDeleteWithHTTPInfo(r ApiCustomDeleteRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CustomDelete casts the HTTP response body to a defined struct.

This method lets you send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, for example `1/newFeature`.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomDelete(r ApiCustomDeleteRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomGetRequest represents the request with all the parameters for the API call.
type ApiCustomGetRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomGetRequest creates an instance of the ApiCustomGetRequest to be used for the API call.
func (c *APIClient) NewApiCustomGetRequest(path string) ApiCustomGetRequest {
	return ApiCustomGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomGetRequest and returns the request for chaining.
func (r ApiCustomGetRequest) WithParameters(parameters map[string]any) ApiCustomGetRequest {
	r.parameters = parameters
	return r
}

/*
CustomGet calls the API and returns the raw response from it.

	  This method lets you send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomGetRequest with parameters below.
	  @param path string - Path of the endpoint, for example `1/newFeature`.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomGetWithHTTPInfo(r ApiCustomGetRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CustomGet casts the HTTP response body to a defined struct.

This method lets you send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, for example `1/newFeature`.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomGet(r ApiCustomGetRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPostRequest represents the request with all the parameters for the API call.
type ApiCustomPostRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPostRequest creates an instance of the ApiCustomPostRequest to be used for the API call.
func (c *APIClient) NewApiCustomPostRequest(path string) ApiCustomPostRequest {
	return ApiCustomPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithParameters(parameters map[string]any) ApiCustomPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithBody(body map[string]any) ApiCustomPostRequest {
	r.body = body
	return r
}

/*
CustomPost calls the API and returns the raw response from it.

	  This method lets you send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomPostRequest with parameters below.
	  @param path string - Path of the endpoint, for example `1/newFeature`.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	  @param body map[string]any - Parameters to send with the custom request.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomPostWithHTTPInfo(r ApiCustomPostRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CustomPost casts the HTTP response body to a defined struct.

This method lets you send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, for example `1/newFeature`.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPost(r ApiCustomPostRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPutRequest represents the request with all the parameters for the API call.
type ApiCustomPutRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPutRequest creates an instance of the ApiCustomPutRequest to be used for the API call.
func (c *APIClient) NewApiCustomPutRequest(path string) ApiCustomPutRequest {
	return ApiCustomPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithParameters(parameters map[string]any) ApiCustomPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithBody(body map[string]any) ApiCustomPutRequest {
	r.body = body
	return r
}

/*
CustomPut calls the API and returns the raw response from it.

	  This method lets you send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomPutRequest with parameters below.
	  @param path string - Path of the endpoint, for example `1/newFeature`.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	  @param body map[string]any - Parameters to send with the custom request.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomPutWithHTTPInfo(r ApiCustomPutRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CustomPut casts the HTTP response body to a defined struct.

This method lets you send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, for example `1/newFeature`.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPut(r ApiCustomPutRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetAddToCartRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetAddToCartRateRequest represents the request with all the parameters for the API call.
type ApiGetAddToCartRateRequest struct {
	index     string
	startDate *string
	endDate   *string
	tags      *string
}

// NewApiGetAddToCartRateRequest creates an instance of the ApiGetAddToCartRateRequest to be used for the API call.
func (c *APIClient) NewApiGetAddToCartRateRequest(index string) ApiGetAddToCartRateRequest {
	return ApiGetAddToCartRateRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetAddToCartRateRequest and returns the request for chaining.
func (r ApiGetAddToCartRateRequest) WithStartDate(startDate string) ApiGetAddToCartRateRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetAddToCartRateRequest and returns the request for chaining.
func (r ApiGetAddToCartRateRequest) WithEndDate(endDate string) ApiGetAddToCartRateRequest {
	r.endDate = &endDate
	return r
}

// WithTags adds the tags to the ApiGetAddToCartRateRequest and returns the request for chaining.
func (r ApiGetAddToCartRateRequest) WithTags(tags string) ApiGetAddToCartRateRequest {
	r.tags = &tags
	return r
}

/*
GetAddToCartRate calls the API and returns the raw response from it.

	Retrieves the add-to-cart rate for all your searches with at least one add-to-cart event, including a daily breakdown.

By default, the analyzed period includes the last eight days including the current day.

The rate is the number of add-to-cart conversion events divided by the number of tracked searches.
A search is tracked if it returns a queryID (`clickAnalytics` is `true`).
This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.

**There's a difference between a 0 and null add-to-cart rate when `clickAnalytics` is enabled:**

- **Null** means there were no queries: since Algolia didn't receive any events, the add-to-cart rate is null.
- **0** mean there _were_ queries but no [add-to-cart events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetAddToCartRateRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetAddToCartRateWithHTTPInfo(r ApiGetAddToCartRateRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/conversions/addToCartRate"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetAddToCartRate`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetAddToCartRate casts the HTTP response body to a defined struct.

Retrieves the add-to-cart rate for all your searches with at least one add-to-cart event, including a daily breakdown.

By default, the analyzed period includes the last eight days including the current day.

The rate is the number of add-to-cart conversion events divided by the number of tracked searches.
A search is tracked if it returns a queryID (`clickAnalytics` is `true`).
This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.

**There's a difference between a 0 and null add-to-cart rate when `clickAnalytics` is enabled:**

- **Null** means there were no queries: since Algolia didn't receive any events, the add-to-cart rate is null.
- **0** mean there _were_ queries but no [add-to-cart events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetAddToCartRateRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetAddToCartRateResponse
*/
func (c *APIClient) GetAddToCartRate(r ApiGetAddToCartRateRequest, opts ...RequestOption) (*GetAddToCartRateResponse, error) {
	var returnValue *GetAddToCartRateResponse

	res, resBody, err := c.GetAddToCartRateWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetAverageClickPositionRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetAverageClickPositionRequest represents the request with all the parameters for the API call.
type ApiGetAverageClickPositionRequest struct {
	index     string
	startDate *string
	endDate   *string
	tags      *string
}

// NewApiGetAverageClickPositionRequest creates an instance of the ApiGetAverageClickPositionRequest to be used for the API call.
func (c *APIClient) NewApiGetAverageClickPositionRequest(index string) ApiGetAverageClickPositionRequest {
	return ApiGetAverageClickPositionRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetAverageClickPositionRequest and returns the request for chaining.
func (r ApiGetAverageClickPositionRequest) WithStartDate(startDate string) ApiGetAverageClickPositionRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetAverageClickPositionRequest and returns the request for chaining.
func (r ApiGetAverageClickPositionRequest) WithEndDate(endDate string) ApiGetAverageClickPositionRequest {
	r.endDate = &endDate
	return r
}

// WithTags adds the tags to the ApiGetAverageClickPositionRequest and returns the request for chaining.
func (r ApiGetAverageClickPositionRequest) WithTags(tags string) ApiGetAverageClickPositionRequest {
	r.tags = &tags
	return r
}

/*
GetAverageClickPosition calls the API and returns the raw response from it.

	Retrieves the average click position of your search results, including a daily breakdown.

The average click position is the average of all clicked search result positions.
For example, if users only ever click on the first result for any search, the average click position is 1.
By default, the analyzed period includes the last eight days including the current day.

An average of `null` when `clickAnalytics` is enabled means Algolia didn't receive any [click events](https://www.algolia.com/doc/guides/sending-events/getting-started) for the queries.
The average is `null` until Algolia receives at least one click event.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetAverageClickPositionRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetAverageClickPositionWithHTTPInfo(r ApiGetAverageClickPositionRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/clicks/averageClickPosition"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetAverageClickPosition`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetAverageClickPosition casts the HTTP response body to a defined struct.

Retrieves the average click position of your search results, including a daily breakdown.

The average click position is the average of all clicked search result positions.
For example, if users only ever click on the first result for any search, the average click position is 1.
By default, the analyzed period includes the last eight days including the current day.

An average of `null` when `clickAnalytics` is enabled means Algolia didn't receive any [click events](https://www.algolia.com/doc/guides/sending-events/getting-started) for the queries.
The average is `null` until Algolia receives at least one click event.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetAverageClickPositionRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetAverageClickPositionResponse
*/
func (c *APIClient) GetAverageClickPosition(r ApiGetAverageClickPositionRequest, opts ...RequestOption) (*GetAverageClickPositionResponse, error) {
	var returnValue *GetAverageClickPositionResponse

	res, resBody, err := c.GetAverageClickPositionWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetClickPositionsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetClickPositionsRequest represents the request with all the parameters for the API call.
type ApiGetClickPositionsRequest struct {
	index     string
	startDate *string
	endDate   *string
	tags      *string
}

// NewApiGetClickPositionsRequest creates an instance of the ApiGetClickPositionsRequest to be used for the API call.
func (c *APIClient) NewApiGetClickPositionsRequest(index string) ApiGetClickPositionsRequest {
	return ApiGetClickPositionsRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetClickPositionsRequest and returns the request for chaining.
func (r ApiGetClickPositionsRequest) WithStartDate(startDate string) ApiGetClickPositionsRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetClickPositionsRequest and returns the request for chaining.
func (r ApiGetClickPositionsRequest) WithEndDate(endDate string) ApiGetClickPositionsRequest {
	r.endDate = &endDate
	return r
}

// WithTags adds the tags to the ApiGetClickPositionsRequest and returns the request for chaining.
func (r ApiGetClickPositionsRequest) WithTags(tags string) ApiGetClickPositionsRequest {
	r.tags = &tags
	return r
}

/*
GetClickPositions calls the API and returns the raw response from it.

	Retrieves the positions in the search results and their associated number of clicks.

This lets you check how many clicks the first, second, or tenth search results receive.

An average of `0` when `clickAnalytics` is enabled means Algolia didn't receive any [click events](https://www.algolia.com/doc/guides/sending-events/getting-started) for the queries.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetClickPositionsRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetClickPositionsWithHTTPInfo(r ApiGetClickPositionsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/clicks/positions"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetClickPositions`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetClickPositions casts the HTTP response body to a defined struct.

Retrieves the positions in the search results and their associated number of clicks.

This lets you check how many clicks the first, second, or tenth search results receive.

An average of `0` when `clickAnalytics` is enabled means Algolia didn't receive any [click events](https://www.algolia.com/doc/guides/sending-events/getting-started) for the queries.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetClickPositionsRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetClickPositionsResponse
*/
func (c *APIClient) GetClickPositions(r ApiGetClickPositionsRequest, opts ...RequestOption) (*GetClickPositionsResponse, error) {
	var returnValue *GetClickPositionsResponse

	res, resBody, err := c.GetClickPositionsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetClickThroughRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetClickThroughRateRequest represents the request with all the parameters for the API call.
type ApiGetClickThroughRateRequest struct {
	index     string
	startDate *string
	endDate   *string
	tags      *string
}

// NewApiGetClickThroughRateRequest creates an instance of the ApiGetClickThroughRateRequest to be used for the API call.
func (c *APIClient) NewApiGetClickThroughRateRequest(index string) ApiGetClickThroughRateRequest {
	return ApiGetClickThroughRateRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetClickThroughRateRequest and returns the request for chaining.
func (r ApiGetClickThroughRateRequest) WithStartDate(startDate string) ApiGetClickThroughRateRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetClickThroughRateRequest and returns the request for chaining.
func (r ApiGetClickThroughRateRequest) WithEndDate(endDate string) ApiGetClickThroughRateRequest {
	r.endDate = &endDate
	return r
}

// WithTags adds the tags to the ApiGetClickThroughRateRequest and returns the request for chaining.
func (r ApiGetClickThroughRateRequest) WithTags(tags string) ApiGetClickThroughRateRequest {
	r.tags = &tags
	return r
}

/*
GetClickThroughRate calls the API and returns the raw response from it.

	Retrieves the click-through rate (CTR) for all your searches with at least one click event, including a daily breakdown.

By default, the analyzed period includes the last eight days including the current day.

**There's a difference between a 0 and null CTR when `clickAnalytics` is enabled:**

- **Null** means there were no queries: since Algolia didn't receive any events, CTR is null.
- **0** mean there _were_ queries but no [click events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetClickThroughRateRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetClickThroughRateWithHTTPInfo(r ApiGetClickThroughRateRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/clicks/clickThroughRate"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetClickThroughRate`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetClickThroughRate casts the HTTP response body to a defined struct.

Retrieves the click-through rate (CTR) for all your searches with at least one click event, including a daily breakdown.

By default, the analyzed period includes the last eight days including the current day.

**There's a difference between a 0 and null CTR when `clickAnalytics` is enabled:**

- **Null** means there were no queries: since Algolia didn't receive any events, CTR is null.
- **0** mean there _were_ queries but no [click events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetClickThroughRateRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetClickThroughRateResponse
*/
func (c *APIClient) GetClickThroughRate(r ApiGetClickThroughRateRequest, opts ...RequestOption) (*GetClickThroughRateResponse, error) {
	var returnValue *GetClickThroughRateResponse

	res, resBody, err := c.GetClickThroughRateWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetConversionRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetConversionRateRequest represents the request with all the parameters for the API call.
type ApiGetConversionRateRequest struct {
	index     string
	startDate *string
	endDate   *string
	tags      *string
}

// NewApiGetConversionRateRequest creates an instance of the ApiGetConversionRateRequest to be used for the API call.
func (c *APIClient) NewApiGetConversionRateRequest(index string) ApiGetConversionRateRequest {
	return ApiGetConversionRateRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetConversionRateRequest and returns the request for chaining.
func (r ApiGetConversionRateRequest) WithStartDate(startDate string) ApiGetConversionRateRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetConversionRateRequest and returns the request for chaining.
func (r ApiGetConversionRateRequest) WithEndDate(endDate string) ApiGetConversionRateRequest {
	r.endDate = &endDate
	return r
}

// WithTags adds the tags to the ApiGetConversionRateRequest and returns the request for chaining.
func (r ApiGetConversionRateRequest) WithTags(tags string) ApiGetConversionRateRequest {
	r.tags = &tags
	return r
}

/*
GetConversionRate calls the API and returns the raw response from it.

	Retrieves the conversion rate (CR) for all your searches with at least one conversion event, including a daily breakdown.

By default, the analyzed period includes the last eight days including the current day.

**There's a difference between a 0 and null CR when `clickAnalytics` is enabled:**

- **Null** means there were no queries: since Algolia didn't receive any events, CR is null.
- **0** mean there _were_ queries but no [conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetConversionRateRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetConversionRateWithHTTPInfo(r ApiGetConversionRateRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/conversions/conversionRate"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetConversionRate`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetConversionRate casts the HTTP response body to a defined struct.

Retrieves the conversion rate (CR) for all your searches with at least one conversion event, including a daily breakdown.

By default, the analyzed period includes the last eight days including the current day.

**There's a difference between a 0 and null CR when `clickAnalytics` is enabled:**

- **Null** means there were no queries: since Algolia didn't receive any events, CR is null.
- **0** mean there _were_ queries but no [conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetConversionRateRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetConversionRateResponse
*/
func (c *APIClient) GetConversionRate(r ApiGetConversionRateRequest, opts ...RequestOption) (*GetConversionRateResponse, error) {
	var returnValue *GetConversionRateResponse

	res, resBody, err := c.GetConversionRateWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetNoClickRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetNoClickRateRequest represents the request with all the parameters for the API call.
type ApiGetNoClickRateRequest struct {
	index     string
	startDate *string
	endDate   *string
	tags      *string
}

// NewApiGetNoClickRateRequest creates an instance of the ApiGetNoClickRateRequest to be used for the API call.
func (c *APIClient) NewApiGetNoClickRateRequest(index string) ApiGetNoClickRateRequest {
	return ApiGetNoClickRateRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetNoClickRateRequest and returns the request for chaining.
func (r ApiGetNoClickRateRequest) WithStartDate(startDate string) ApiGetNoClickRateRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetNoClickRateRequest and returns the request for chaining.
func (r ApiGetNoClickRateRequest) WithEndDate(endDate string) ApiGetNoClickRateRequest {
	r.endDate = &endDate
	return r
}

// WithTags adds the tags to the ApiGetNoClickRateRequest and returns the request for chaining.
func (r ApiGetNoClickRateRequest) WithTags(tags string) ApiGetNoClickRateRequest {
	r.tags = &tags
	return r
}

/*
GetNoClickRate calls the API and returns the raw response from it.

	Retrieves the fraction of searches that didn't lead to any click within a time range, including a daily breakdown.

It also returns the number of tracked searches and tracked searches without clicks.

By default, the analyzed period includes the last eight days including the current day.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetNoClickRateRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetNoClickRateWithHTTPInfo(r ApiGetNoClickRateRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/searches/noClickRate"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetNoClickRate`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetNoClickRate casts the HTTP response body to a defined struct.

Retrieves the fraction of searches that didn't lead to any click within a time range, including a daily breakdown.
It also returns the number of tracked searches and tracked searches without clicks.

By default, the analyzed period includes the last eight days including the current day.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetNoClickRateRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetNoClickRateResponse
*/
func (c *APIClient) GetNoClickRate(r ApiGetNoClickRateRequest, opts ...RequestOption) (*GetNoClickRateResponse, error) {
	var returnValue *GetNoClickRateResponse

	res, resBody, err := c.GetNoClickRateWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetNoResultsRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetNoResultsRateRequest represents the request with all the parameters for the API call.
type ApiGetNoResultsRateRequest struct {
	index     string
	startDate *string
	endDate   *string
	tags      *string
}

// NewApiGetNoResultsRateRequest creates an instance of the ApiGetNoResultsRateRequest to be used for the API call.
func (c *APIClient) NewApiGetNoResultsRateRequest(index string) ApiGetNoResultsRateRequest {
	return ApiGetNoResultsRateRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetNoResultsRateRequest and returns the request for chaining.
func (r ApiGetNoResultsRateRequest) WithStartDate(startDate string) ApiGetNoResultsRateRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetNoResultsRateRequest and returns the request for chaining.
func (r ApiGetNoResultsRateRequest) WithEndDate(endDate string) ApiGetNoResultsRateRequest {
	r.endDate = &endDate
	return r
}

// WithTags adds the tags to the ApiGetNoResultsRateRequest and returns the request for chaining.
func (r ApiGetNoResultsRateRequest) WithTags(tags string) ApiGetNoResultsRateRequest {
	r.tags = &tags
	return r
}

/*
GetNoResultsRate calls the API and returns the raw response from it.

	Retrieves the fraction of searches that didn't return any results within a time range, including a daily breakdown.

It also returns the count of searches and searches without results used to compute the rates.

By default, the analyzed period includes the last eight days including the current day.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetNoResultsRateRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetNoResultsRateWithHTTPInfo(r ApiGetNoResultsRateRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/searches/noResultRate"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetNoResultsRate`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetNoResultsRate casts the HTTP response body to a defined struct.

Retrieves the fraction of searches that didn't return any results within a time range, including a daily breakdown.
It also returns the count of searches and searches without results used to compute the rates.

By default, the analyzed period includes the last eight days including the current day.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetNoResultsRateRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetNoResultsRateResponse
*/
func (c *APIClient) GetNoResultsRate(r ApiGetNoResultsRateRequest, opts ...RequestOption) (*GetNoResultsRateResponse, error) {
	var returnValue *GetNoResultsRateResponse

	res, resBody, err := c.GetNoResultsRateWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetPurchaseRateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetPurchaseRateRequest represents the request with all the parameters for the API call.
type ApiGetPurchaseRateRequest struct {
	index     string
	startDate *string
	endDate   *string
	tags      *string
}

// NewApiGetPurchaseRateRequest creates an instance of the ApiGetPurchaseRateRequest to be used for the API call.
func (c *APIClient) NewApiGetPurchaseRateRequest(index string) ApiGetPurchaseRateRequest {
	return ApiGetPurchaseRateRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetPurchaseRateRequest and returns the request for chaining.
func (r ApiGetPurchaseRateRequest) WithStartDate(startDate string) ApiGetPurchaseRateRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetPurchaseRateRequest and returns the request for chaining.
func (r ApiGetPurchaseRateRequest) WithEndDate(endDate string) ApiGetPurchaseRateRequest {
	r.endDate = &endDate
	return r
}

// WithTags adds the tags to the ApiGetPurchaseRateRequest and returns the request for chaining.
func (r ApiGetPurchaseRateRequest) WithTags(tags string) ApiGetPurchaseRateRequest {
	r.tags = &tags
	return r
}

/*
GetPurchaseRate calls the API and returns the raw response from it.

	Retrieves the purchase rate for all your searches with at least one purchase event, including a daily breakdown.

By default, the analyzed period includes the last eight days including the current day.

The rate is the number of purchase conversion events divided by the number of tracked searches.
A search is tracked if it returns a query ID (`clickAnalytics` is `true`).
This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.

**There's a difference between a 0 and null purchase rate when `clickAnalytics` is enabled:**

- **Null** means there were no queries: since Algolia didn't receive any events, the purchase rate is null.
- **0** mean there _were_ queries but no [purchase conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetPurchaseRateRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetPurchaseRateWithHTTPInfo(r ApiGetPurchaseRateRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/conversions/purchaseRate"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetPurchaseRate`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetPurchaseRate casts the HTTP response body to a defined struct.

Retrieves the purchase rate for all your searches with at least one purchase event, including a daily breakdown.

By default, the analyzed period includes the last eight days including the current day.

The rate is the number of purchase conversion events divided by the number of tracked searches.
A search is tracked if it returns a query ID (`clickAnalytics` is `true`).
This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.

**There's a difference between a 0 and null purchase rate when `clickAnalytics` is enabled:**

- **Null** means there were no queries: since Algolia didn't receive any events, the purchase rate is null.
- **0** mean there _were_ queries but no [purchase conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetPurchaseRateRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetPurchaseRateResponse
*/
func (c *APIClient) GetPurchaseRate(r ApiGetPurchaseRateRequest, opts ...RequestOption) (*GetPurchaseRateResponse, error) {
	var returnValue *GetPurchaseRateResponse

	res, resBody, err := c.GetPurchaseRateWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRevenueRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetRevenueRequest represents the request with all the parameters for the API call.
type ApiGetRevenueRequest struct {
	index     string
	startDate *string
	endDate   *string
	tags      *string
}

// NewApiGetRevenueRequest creates an instance of the ApiGetRevenueRequest to be used for the API call.
func (c *APIClient) NewApiGetRevenueRequest(index string) ApiGetRevenueRequest {
	return ApiGetRevenueRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetRevenueRequest and returns the request for chaining.
func (r ApiGetRevenueRequest) WithStartDate(startDate string) ApiGetRevenueRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetRevenueRequest and returns the request for chaining.
func (r ApiGetRevenueRequest) WithEndDate(endDate string) ApiGetRevenueRequest {
	r.endDate = &endDate
	return r
}

// WithTags adds the tags to the ApiGetRevenueRequest and returns the request for chaining.
func (r ApiGetRevenueRequest) WithTags(tags string) ApiGetRevenueRequest {
	r.tags = &tags
	return r
}

/*
GetRevenue calls the API and returns the raw response from it.

	Retrieves revenue-related metrics, such as the total revenue or the average order value.

To retrieve revenue-related metrics, send purchase events.
By default, the analyzed period includes the last eight days including the current day.

Revenue is based on purchase conversion events (a conversion event with an `eventSubtype` attribute of `purchase`).
The revenue is the `price` attribute multiplied by the `quantity` attribute for each object in the event's `objectData` array.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetRevenueRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetRevenueWithHTTPInfo(r ApiGetRevenueRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/conversions/revenue"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetRevenue`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetRevenue casts the HTTP response body to a defined struct.

Retrieves revenue-related metrics, such as the total revenue or the average order value.

To retrieve revenue-related metrics, send purchase events.
By default, the analyzed period includes the last eight days including the current day.

Revenue is based on purchase conversion events (a conversion event with an `eventSubtype` attribute of `purchase`).
The revenue is the `price` attribute multiplied by the `quantity` attribute for each object in the event's `objectData` array.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetRevenueRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetRevenue
*/
func (c *APIClient) GetRevenue(r ApiGetRevenueRequest, opts ...RequestOption) (*GetRevenue, error) {
	var returnValue *GetRevenue

	res, resBody, err := c.GetRevenueWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSearchesCountRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSearchesCountRequest represents the request with all the parameters for the API call.
type ApiGetSearchesCountRequest struct {
	index     string
	startDate *string
	endDate   *string
	tags      *string
}

// NewApiGetSearchesCountRequest creates an instance of the ApiGetSearchesCountRequest to be used for the API call.
func (c *APIClient) NewApiGetSearchesCountRequest(index string) ApiGetSearchesCountRequest {
	return ApiGetSearchesCountRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetSearchesCountRequest and returns the request for chaining.
func (r ApiGetSearchesCountRequest) WithStartDate(startDate string) ApiGetSearchesCountRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetSearchesCountRequest and returns the request for chaining.
func (r ApiGetSearchesCountRequest) WithEndDate(endDate string) ApiGetSearchesCountRequest {
	r.endDate = &endDate
	return r
}

// WithTags adds the tags to the ApiGetSearchesCountRequest and returns the request for chaining.
func (r ApiGetSearchesCountRequest) WithTags(tags string) ApiGetSearchesCountRequest {
	r.tags = &tags
	return r
}

/*
GetSearchesCount calls the API and returns the raw response from it.

	Retrieves the number of searches within a time range, including a daily breakdown.

By default, the analyzed period includes the last eight days including the current day.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetSearchesCountRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetSearchesCountWithHTTPInfo(r ApiGetSearchesCountRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/searches/count"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetSearchesCount`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetSearchesCount casts the HTTP response body to a defined struct.

Retrieves the number of searches within a time range, including a daily breakdown.

By default, the analyzed period includes the last eight days including the current day.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetSearchesCountRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetSearchesCountResponse
*/
func (c *APIClient) GetSearchesCount(r ApiGetSearchesCountRequest, opts ...RequestOption) (*GetSearchesCountResponse, error) {
	var returnValue *GetSearchesCountResponse

	res, resBody, err := c.GetSearchesCountWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSearchesNoClicksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSearchesNoClicksRequest represents the request with all the parameters for the API call.
type ApiGetSearchesNoClicksRequest struct {
	index     string
	startDate *string
	endDate   *string
	limit     *int32
	offset    *int32
	tags      *string
}

// NewApiGetSearchesNoClicksRequest creates an instance of the ApiGetSearchesNoClicksRequest to be used for the API call.
func (c *APIClient) NewApiGetSearchesNoClicksRequest(index string) ApiGetSearchesNoClicksRequest {
	return ApiGetSearchesNoClicksRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetSearchesNoClicksRequest and returns the request for chaining.
func (r ApiGetSearchesNoClicksRequest) WithStartDate(startDate string) ApiGetSearchesNoClicksRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetSearchesNoClicksRequest and returns the request for chaining.
func (r ApiGetSearchesNoClicksRequest) WithEndDate(endDate string) ApiGetSearchesNoClicksRequest {
	r.endDate = &endDate
	return r
}

// WithLimit adds the limit to the ApiGetSearchesNoClicksRequest and returns the request for chaining.
func (r ApiGetSearchesNoClicksRequest) WithLimit(limit int32) ApiGetSearchesNoClicksRequest {
	r.limit = &limit
	return r
}

// WithOffset adds the offset to the ApiGetSearchesNoClicksRequest and returns the request for chaining.
func (r ApiGetSearchesNoClicksRequest) WithOffset(offset int32) ApiGetSearchesNoClicksRequest {
	r.offset = &offset
	return r
}

// WithTags adds the tags to the ApiGetSearchesNoClicksRequest and returns the request for chaining.
func (r ApiGetSearchesNoClicksRequest) WithTags(tags string) ApiGetSearchesNoClicksRequest {
	r.tags = &tags
	return r
}

/*
GetSearchesNoClicks calls the API and returns the raw response from it.

	Retrieves the most popular searches that didn't lead to any clicks, from the 1,000 most frequent searches.

For each search, it also returns the number of displayed search results that remained unclicked.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetSearchesNoClicksRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param limit int32 - Number of items to return.
	  @param offset int32 - Position of the first item to return.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetSearchesNoClicksWithHTTPInfo(r ApiGetSearchesNoClicksRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/searches/noClicks"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetSearchesNoClicks`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetSearchesNoClicks casts the HTTP response body to a defined struct.

Retrieves the most popular searches that didn't lead to any clicks, from the 1,000 most frequent searches.

For each search, it also returns the number of displayed search results that remained unclicked.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetSearchesNoClicksRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param limit int32 - Number of items to return.
	@param offset int32 - Position of the first item to return.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetSearchesNoClicksResponse
*/
func (c *APIClient) GetSearchesNoClicks(r ApiGetSearchesNoClicksRequest, opts ...RequestOption) (*GetSearchesNoClicksResponse, error) {
	var returnValue *GetSearchesNoClicksResponse

	res, resBody, err := c.GetSearchesNoClicksWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSearchesNoResultsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSearchesNoResultsRequest represents the request with all the parameters for the API call.
type ApiGetSearchesNoResultsRequest struct {
	index     string
	startDate *string
	endDate   *string
	limit     *int32
	offset    *int32
	tags      *string
}

// NewApiGetSearchesNoResultsRequest creates an instance of the ApiGetSearchesNoResultsRequest to be used for the API call.
func (c *APIClient) NewApiGetSearchesNoResultsRequest(index string) ApiGetSearchesNoResultsRequest {
	return ApiGetSearchesNoResultsRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetSearchesNoResultsRequest and returns the request for chaining.
func (r ApiGetSearchesNoResultsRequest) WithStartDate(startDate string) ApiGetSearchesNoResultsRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetSearchesNoResultsRequest and returns the request for chaining.
func (r ApiGetSearchesNoResultsRequest) WithEndDate(endDate string) ApiGetSearchesNoResultsRequest {
	r.endDate = &endDate
	return r
}

// WithLimit adds the limit to the ApiGetSearchesNoResultsRequest and returns the request for chaining.
func (r ApiGetSearchesNoResultsRequest) WithLimit(limit int32) ApiGetSearchesNoResultsRequest {
	r.limit = &limit
	return r
}

// WithOffset adds the offset to the ApiGetSearchesNoResultsRequest and returns the request for chaining.
func (r ApiGetSearchesNoResultsRequest) WithOffset(offset int32) ApiGetSearchesNoResultsRequest {
	r.offset = &offset
	return r
}

// WithTags adds the tags to the ApiGetSearchesNoResultsRequest and returns the request for chaining.
func (r ApiGetSearchesNoResultsRequest) WithTags(tags string) ApiGetSearchesNoResultsRequest {
	r.tags = &tags
	return r
}

/*
GetSearchesNoResults calls the API and returns the raw response from it.

	  Retrieves the 1,000 most frequent searches that produced zero results.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetSearchesNoResultsRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param limit int32 - Number of items to return.
	  @param offset int32 - Position of the first item to return.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetSearchesNoResultsWithHTTPInfo(r ApiGetSearchesNoResultsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/searches/noResults"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetSearchesNoResults`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetSearchesNoResults casts the HTTP response body to a defined struct.

Retrieves the 1,000 most frequent searches that produced zero results.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetSearchesNoResultsRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param limit int32 - Number of items to return.
	@param offset int32 - Position of the first item to return.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetSearchesNoResultsResponse
*/
func (c *APIClient) GetSearchesNoResults(r ApiGetSearchesNoResultsRequest, opts ...RequestOption) (*GetSearchesNoResultsResponse, error) {
	var returnValue *GetSearchesNoResultsResponse

	res, resBody, err := c.GetSearchesNoResultsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetStatusRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}

	return nil
}

// ApiGetStatusRequest represents the request with all the parameters for the API call.
type ApiGetStatusRequest struct {
	index string
}

// NewApiGetStatusRequest creates an instance of the ApiGetStatusRequest to be used for the API call.
func (c *APIClient) NewApiGetStatusRequest(index string) ApiGetStatusRequest {
	return ApiGetStatusRequest{
		index: index,
	}
}

/*
GetStatus calls the API and returns the raw response from it.

	Retrieves the time when the Analytics data for the specified index was last updated.

If the index has been recently created or no search has been performed yet the updated time is `null`.

The Analytics data is updated every 5&nbsp;minutes.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetStatusRequest with parameters below.
	  @param index string - Index name.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetStatusWithHTTPInfo(r ApiGetStatusRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/status"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetStatus`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetStatus casts the HTTP response body to a defined struct.

Retrieves the time when the Analytics data for the specified index was last updated.

If the index has been recently created or no search has been performed yet the updated time is `null`.

The Analytics data is updated every 5&nbsp;minutes.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetStatusRequest with parameters below.

	@param index string - Index name.
	@return GetStatusResponse
*/
func (c *APIClient) GetStatus(r ApiGetStatusRequest, opts ...RequestOption) (*GetStatusResponse, error) {
	var returnValue *GetStatusResponse

	res, resBody, err := c.GetStatusWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTopCountriesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTopCountriesRequest represents the request with all the parameters for the API call.
type ApiGetTopCountriesRequest struct {
	index     string
	startDate *string
	endDate   *string
	limit     *int32
	offset    *int32
	tags      *string
}

// NewApiGetTopCountriesRequest creates an instance of the ApiGetTopCountriesRequest to be used for the API call.
func (c *APIClient) NewApiGetTopCountriesRequest(index string) ApiGetTopCountriesRequest {
	return ApiGetTopCountriesRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetTopCountriesRequest and returns the request for chaining.
func (r ApiGetTopCountriesRequest) WithStartDate(startDate string) ApiGetTopCountriesRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetTopCountriesRequest and returns the request for chaining.
func (r ApiGetTopCountriesRequest) WithEndDate(endDate string) ApiGetTopCountriesRequest {
	r.endDate = &endDate
	return r
}

// WithLimit adds the limit to the ApiGetTopCountriesRequest and returns the request for chaining.
func (r ApiGetTopCountriesRequest) WithLimit(limit int32) ApiGetTopCountriesRequest {
	r.limit = &limit
	return r
}

// WithOffset adds the offset to the ApiGetTopCountriesRequest and returns the request for chaining.
func (r ApiGetTopCountriesRequest) WithOffset(offset int32) ApiGetTopCountriesRequest {
	r.offset = &offset
	return r
}

// WithTags adds the tags to the ApiGetTopCountriesRequest and returns the request for chaining.
func (r ApiGetTopCountriesRequest) WithTags(tags string) ApiGetTopCountriesRequest {
	r.tags = &tags
	return r
}

/*
GetTopCountries calls the API and returns the raw response from it.

	  Retrieves the countries with the most searches in your index.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetTopCountriesRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param limit int32 - Number of items to return.
	  @param offset int32 - Position of the first item to return.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTopCountriesWithHTTPInfo(r ApiGetTopCountriesRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/countries"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetTopCountries`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetTopCountries casts the HTTP response body to a defined struct.

Retrieves the countries with the most searches in your index.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetTopCountriesRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param limit int32 - Number of items to return.
	@param offset int32 - Position of the first item to return.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetTopCountriesResponse
*/
func (c *APIClient) GetTopCountries(r ApiGetTopCountriesRequest, opts ...RequestOption) (*GetTopCountriesResponse, error) {
	var returnValue *GetTopCountriesResponse

	res, resBody, err := c.GetTopCountriesWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTopFilterAttributesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["search"]; ok {
		err = json.Unmarshal(v, &r.search)
		if err != nil {
			err = json.Unmarshal(b, &r.search)
			if err != nil {
				return fmt.Errorf("cannot unmarshal search: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTopFilterAttributesRequest represents the request with all the parameters for the API call.
type ApiGetTopFilterAttributesRequest struct {
	index     string
	search    *string
	startDate *string
	endDate   *string
	limit     *int32
	offset    *int32
	tags      *string
}

// NewApiGetTopFilterAttributesRequest creates an instance of the ApiGetTopFilterAttributesRequest to be used for the API call.
func (c *APIClient) NewApiGetTopFilterAttributesRequest(index string) ApiGetTopFilterAttributesRequest {
	return ApiGetTopFilterAttributesRequest{
		index: index,
	}
}

// WithSearch adds the search to the ApiGetTopFilterAttributesRequest and returns the request for chaining.
func (r ApiGetTopFilterAttributesRequest) WithSearch(search string) ApiGetTopFilterAttributesRequest {
	r.search = &search
	return r
}

// WithStartDate adds the startDate to the ApiGetTopFilterAttributesRequest and returns the request for chaining.
func (r ApiGetTopFilterAttributesRequest) WithStartDate(startDate string) ApiGetTopFilterAttributesRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetTopFilterAttributesRequest and returns the request for chaining.
func (r ApiGetTopFilterAttributesRequest) WithEndDate(endDate string) ApiGetTopFilterAttributesRequest {
	r.endDate = &endDate
	return r
}

// WithLimit adds the limit to the ApiGetTopFilterAttributesRequest and returns the request for chaining.
func (r ApiGetTopFilterAttributesRequest) WithLimit(limit int32) ApiGetTopFilterAttributesRequest {
	r.limit = &limit
	return r
}

// WithOffset adds the offset to the ApiGetTopFilterAttributesRequest and returns the request for chaining.
func (r ApiGetTopFilterAttributesRequest) WithOffset(offset int32) ApiGetTopFilterAttributesRequest {
	r.offset = &offset
	return r
}

// WithTags adds the tags to the ApiGetTopFilterAttributesRequest and returns the request for chaining.
func (r ApiGetTopFilterAttributesRequest) WithTags(tags string) ApiGetTopFilterAttributesRequest {
	r.tags = &tags
	return r
}

/*
GetTopFilterAttributes calls the API and returns the raw response from it.

	Retrieves the 1,000 most frequently used filter attributes.

These are attributes of your records that you included in the `attributesForFaceting` setting.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetTopFilterAttributesRequest with parameters below.
	  @param index string - Index name.
	  @param search string - Search query.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param limit int32 - Number of items to return.
	  @param offset int32 - Position of the first item to return.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTopFilterAttributesWithHTTPInfo(r ApiGetTopFilterAttributesRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/filters"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetTopFilterAttributes`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.search) {
		conf.queryParams.Set("search", utils.QueryParameterToString(*r.search))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetTopFilterAttributes casts the HTTP response body to a defined struct.

Retrieves the 1,000 most frequently used filter attributes.

These are attributes of your records that you included in the `attributesForFaceting` setting.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetTopFilterAttributesRequest with parameters below.

	@param index string - Index name.
	@param search string - Search query.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param limit int32 - Number of items to return.
	@param offset int32 - Position of the first item to return.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetTopFilterAttributesResponse
*/
func (c *APIClient) GetTopFilterAttributes(r ApiGetTopFilterAttributesRequest, opts ...RequestOption) (*GetTopFilterAttributesResponse, error) {
	var returnValue *GetTopFilterAttributesResponse

	res, resBody, err := c.GetTopFilterAttributesWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTopFilterForAttributeRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["attribute"]; ok {
		err = json.Unmarshal(v, &r.attribute)
		if err != nil {
			err = json.Unmarshal(b, &r.attribute)
			if err != nil {
				return fmt.Errorf("cannot unmarshal attribute: %w", err)
			}
		}
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["search"]; ok {
		err = json.Unmarshal(v, &r.search)
		if err != nil {
			err = json.Unmarshal(b, &r.search)
			if err != nil {
				return fmt.Errorf("cannot unmarshal search: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTopFilterForAttributeRequest represents the request with all the parameters for the API call.
type ApiGetTopFilterForAttributeRequest struct {
	attribute string
	index     string
	search    *string
	startDate *string
	endDate   *string
	limit     *int32
	offset    *int32
	tags      *string
}

// NewApiGetTopFilterForAttributeRequest creates an instance of the ApiGetTopFilterForAttributeRequest to be used for the API call.
func (c *APIClient) NewApiGetTopFilterForAttributeRequest(attribute string, index string) ApiGetTopFilterForAttributeRequest {
	return ApiGetTopFilterForAttributeRequest{
		attribute: attribute,
		index:     index,
	}
}

// WithSearch adds the search to the ApiGetTopFilterForAttributeRequest and returns the request for chaining.
func (r ApiGetTopFilterForAttributeRequest) WithSearch(search string) ApiGetTopFilterForAttributeRequest {
	r.search = &search
	return r
}

// WithStartDate adds the startDate to the ApiGetTopFilterForAttributeRequest and returns the request for chaining.
func (r ApiGetTopFilterForAttributeRequest) WithStartDate(startDate string) ApiGetTopFilterForAttributeRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetTopFilterForAttributeRequest and returns the request for chaining.
func (r ApiGetTopFilterForAttributeRequest) WithEndDate(endDate string) ApiGetTopFilterForAttributeRequest {
	r.endDate = &endDate
	return r
}

// WithLimit adds the limit to the ApiGetTopFilterForAttributeRequest and returns the request for chaining.
func (r ApiGetTopFilterForAttributeRequest) WithLimit(limit int32) ApiGetTopFilterForAttributeRequest {
	r.limit = &limit
	return r
}

// WithOffset adds the offset to the ApiGetTopFilterForAttributeRequest and returns the request for chaining.
func (r ApiGetTopFilterForAttributeRequest) WithOffset(offset int32) ApiGetTopFilterForAttributeRequest {
	r.offset = &offset
	return r
}

// WithTags adds the tags to the ApiGetTopFilterForAttributeRequest and returns the request for chaining.
func (r ApiGetTopFilterForAttributeRequest) WithTags(tags string) ApiGetTopFilterForAttributeRequest {
	r.tags = &tags
	return r
}

/*
GetTopFilterForAttribute calls the API and returns the raw response from it.

	Retrieves the 1,000 most frequent filter (facet) values for a filter attribute.

These are attributes of your records that you included in the `attributesForFaceting` setting.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetTopFilterForAttributeRequest with parameters below.
	  @param attribute string - Attribute name.
	  @param index string - Index name.
	  @param search string - Search query.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param limit int32 - Number of items to return.
	  @param offset int32 - Position of the first item to return.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTopFilterForAttributeWithHTTPInfo(r ApiGetTopFilterForAttributeRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/filters/{attribute}"
	requestPath = strings.ReplaceAll(requestPath, "{attribute}", url.PathEscape(utils.ParameterToString(r.attribute)))

	if r.attribute == "" {
		return nil, nil, reportError("Parameter `attribute` is required when calling `GetTopFilterForAttribute`.")
	}
	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetTopFilterForAttribute`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.search) {
		conf.queryParams.Set("search", utils.QueryParameterToString(*r.search))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetTopFilterForAttribute casts the HTTP response body to a defined struct.

Retrieves the 1,000 most frequent filter (facet) values for a filter attribute.

These are attributes of your records that you included in the `attributesForFaceting` setting.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetTopFilterForAttributeRequest with parameters below.

	@param attribute string - Attribute name.
	@param index string - Index name.
	@param search string - Search query.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param limit int32 - Number of items to return.
	@param offset int32 - Position of the first item to return.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetTopFilterForAttributeResponse
*/
func (c *APIClient) GetTopFilterForAttribute(r ApiGetTopFilterForAttributeRequest, opts ...RequestOption) (*GetTopFilterForAttributeResponse, error) {
	var returnValue *GetTopFilterForAttributeResponse

	res, resBody, err := c.GetTopFilterForAttributeWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTopFiltersNoResultsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["search"]; ok {
		err = json.Unmarshal(v, &r.search)
		if err != nil {
			err = json.Unmarshal(b, &r.search)
			if err != nil {
				return fmt.Errorf("cannot unmarshal search: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTopFiltersNoResultsRequest represents the request with all the parameters for the API call.
type ApiGetTopFiltersNoResultsRequest struct {
	index     string
	search    *string
	startDate *string
	endDate   *string
	limit     *int32
	offset    *int32
	tags      *string
}

// NewApiGetTopFiltersNoResultsRequest creates an instance of the ApiGetTopFiltersNoResultsRequest to be used for the API call.
func (c *APIClient) NewApiGetTopFiltersNoResultsRequest(index string) ApiGetTopFiltersNoResultsRequest {
	return ApiGetTopFiltersNoResultsRequest{
		index: index,
	}
}

// WithSearch adds the search to the ApiGetTopFiltersNoResultsRequest and returns the request for chaining.
func (r ApiGetTopFiltersNoResultsRequest) WithSearch(search string) ApiGetTopFiltersNoResultsRequest {
	r.search = &search
	return r
}

// WithStartDate adds the startDate to the ApiGetTopFiltersNoResultsRequest and returns the request for chaining.
func (r ApiGetTopFiltersNoResultsRequest) WithStartDate(startDate string) ApiGetTopFiltersNoResultsRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetTopFiltersNoResultsRequest and returns the request for chaining.
func (r ApiGetTopFiltersNoResultsRequest) WithEndDate(endDate string) ApiGetTopFiltersNoResultsRequest {
	r.endDate = &endDate
	return r
}

// WithLimit adds the limit to the ApiGetTopFiltersNoResultsRequest and returns the request for chaining.
func (r ApiGetTopFiltersNoResultsRequest) WithLimit(limit int32) ApiGetTopFiltersNoResultsRequest {
	r.limit = &limit
	return r
}

// WithOffset adds the offset to the ApiGetTopFiltersNoResultsRequest and returns the request for chaining.
func (r ApiGetTopFiltersNoResultsRequest) WithOffset(offset int32) ApiGetTopFiltersNoResultsRequest {
	r.offset = &offset
	return r
}

// WithTags adds the tags to the ApiGetTopFiltersNoResultsRequest and returns the request for chaining.
func (r ApiGetTopFiltersNoResultsRequest) WithTags(tags string) ApiGetTopFiltersNoResultsRequest {
	r.tags = &tags
	return r
}

/*
GetTopFiltersNoResults calls the API and returns the raw response from it.

	Retrieves the 1,000 most frequently used filters for a search that didn't return any results.

To get the most frequent searches without results, use the [Retrieve searches without results](https://www.algolia.com/doc/rest-api/analytics/get-searches-no-results) operation.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetTopFiltersNoResultsRequest with parameters below.
	  @param index string - Index name.
	  @param search string - Search query.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param limit int32 - Number of items to return.
	  @param offset int32 - Position of the first item to return.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTopFiltersNoResultsWithHTTPInfo(r ApiGetTopFiltersNoResultsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/filters/noResults"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetTopFiltersNoResults`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.search) {
		conf.queryParams.Set("search", utils.QueryParameterToString(*r.search))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetTopFiltersNoResults casts the HTTP response body to a defined struct.

Retrieves the 1,000 most frequently used filters for a search that didn't return any results.

To get the most frequent searches without results, use the [Retrieve searches without results](https://www.algolia.com/doc/rest-api/analytics/get-searches-no-results) operation.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetTopFiltersNoResultsRequest with parameters below.

	@param index string - Index name.
	@param search string - Search query.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param limit int32 - Number of items to return.
	@param offset int32 - Position of the first item to return.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetTopFiltersNoResultsResponse
*/
func (c *APIClient) GetTopFiltersNoResults(r ApiGetTopFiltersNoResultsRequest, opts ...RequestOption) (*GetTopFiltersNoResultsResponse, error) {
	var returnValue *GetTopFiltersNoResultsResponse

	res, resBody, err := c.GetTopFiltersNoResultsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTopHitsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["search"]; ok {
		err = json.Unmarshal(v, &r.search)
		if err != nil {
			err = json.Unmarshal(b, &r.search)
			if err != nil {
				return fmt.Errorf("cannot unmarshal search: %w", err)
			}
		}
	}
	if v, ok := req["clickAnalytics"]; ok {
		err = json.Unmarshal(v, &r.clickAnalytics)
		if err != nil {
			err = json.Unmarshal(b, &r.clickAnalytics)
			if err != nil {
				return fmt.Errorf("cannot unmarshal clickAnalytics: %w", err)
			}
		}
	}
	if v, ok := req["revenueAnalytics"]; ok {
		err = json.Unmarshal(v, &r.revenueAnalytics)
		if err != nil {
			err = json.Unmarshal(b, &r.revenueAnalytics)
			if err != nil {
				return fmt.Errorf("cannot unmarshal revenueAnalytics: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTopHitsRequest represents the request with all the parameters for the API call.
type ApiGetTopHitsRequest struct {
	index            string
	search           *string
	clickAnalytics   *bool
	revenueAnalytics *bool
	startDate        *string
	endDate          *string
	limit            *int32
	offset           *int32
	tags             *string
}

// NewApiGetTopHitsRequest creates an instance of the ApiGetTopHitsRequest to be used for the API call.
func (c *APIClient) NewApiGetTopHitsRequest(index string) ApiGetTopHitsRequest {
	return ApiGetTopHitsRequest{
		index: index,
	}
}

// WithSearch adds the search to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithSearch(search string) ApiGetTopHitsRequest {
	r.search = &search
	return r
}

// WithClickAnalytics adds the clickAnalytics to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithClickAnalytics(clickAnalytics bool) ApiGetTopHitsRequest {
	r.clickAnalytics = &clickAnalytics
	return r
}

// WithRevenueAnalytics adds the revenueAnalytics to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithRevenueAnalytics(revenueAnalytics bool) ApiGetTopHitsRequest {
	r.revenueAnalytics = &revenueAnalytics
	return r
}

// WithStartDate adds the startDate to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithStartDate(startDate string) ApiGetTopHitsRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithEndDate(endDate string) ApiGetTopHitsRequest {
	r.endDate = &endDate
	return r
}

// WithLimit adds the limit to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithLimit(limit int32) ApiGetTopHitsRequest {
	r.limit = &limit
	return r
}

// WithOffset adds the offset to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithOffset(offset int32) ApiGetTopHitsRequest {
	r.offset = &offset
	return r
}

// WithTags adds the tags to the ApiGetTopHitsRequest and returns the request for chaining.
func (r ApiGetTopHitsRequest) WithTags(tags string) ApiGetTopHitsRequest {
	r.tags = &tags
	return r
}

/*
GetTopHits calls the API and returns the raw response from it.

	Retrieves the object IDs of the 1,000 most frequent search results.

If you set the `clickAnalytics` query parameter to true, the response also includes:

- Tracked searches count. Tracked searches are Search API requests with the `clickAnalytics` parameter set to `true`. This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.
- Click count
- Click-through rate (CTR)
- Conversion count
- Conversion rate (CR)
- Average click position

If you set the `revenueAnalytics` parameter to `true`, the response also includes:

- Add-to-cart count
- Add-to-cart rate (ATCR)
- Purchase count
- Purchase rate
- Revenue details for each currency

**There's a difference between 0% rates and null rates:**

- **Null** means there were no queries: since Algolia didn't receive any events, the rates (CTR, CR, ATCR, purchase rate) are null.
- **0% rates** mean there _were_ queries but no [click or conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetTopHitsRequest with parameters below.
	  @param index string - Index name.
	  @param search string - Search query.
	  @param clickAnalytics bool - Whether to include metrics related to click and conversion events in the response.
	  @param revenueAnalytics bool - Whether to include metrics related to revenue events in the response.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param limit int32 - Number of items to return.
	  @param offset int32 - Position of the first item to return.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTopHitsWithHTTPInfo(r ApiGetTopHitsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/hits"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetTopHits`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.search) {
		conf.queryParams.Set("search", utils.QueryParameterToString(*r.search))
	}
	if !utils.IsNilOrEmpty(r.clickAnalytics) {
		conf.queryParams.Set("clickAnalytics", utils.QueryParameterToString(*r.clickAnalytics))
	}
	if !utils.IsNilOrEmpty(r.revenueAnalytics) {
		conf.queryParams.Set("revenueAnalytics", utils.QueryParameterToString(*r.revenueAnalytics))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetTopHits casts the HTTP response body to a defined struct.

Retrieves the object IDs of the 1,000 most frequent search results.

If you set the `clickAnalytics` query parameter to true, the response also includes:

- Tracked searches count. Tracked searches are Search API requests with the `clickAnalytics` parameter set to `true`. This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.
- Click count
- Click-through rate (CTR)
- Conversion count
- Conversion rate (CR)
- Average click position

If you set the `revenueAnalytics` parameter to `true`, the response also includes:

- Add-to-cart count
- Add-to-cart rate (ATCR)
- Purchase count
- Purchase rate
- Revenue details for each currency

**There's a difference between 0% rates and null rates:**

- **Null** means there were no queries: since Algolia didn't receive any events, the rates (CTR, CR, ATCR, purchase rate) are null.
- **0% rates** mean there _were_ queries but no [click or conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetTopHitsRequest with parameters below.

	@param index string - Index name.
	@param search string - Search query.
	@param clickAnalytics bool - Whether to include metrics related to click and conversion events in the response.
	@param revenueAnalytics bool - Whether to include metrics related to revenue events in the response.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param limit int32 - Number of items to return.
	@param offset int32 - Position of the first item to return.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetTopHitsResponse
*/
func (c *APIClient) GetTopHits(r ApiGetTopHitsRequest, opts ...RequestOption) (*GetTopHitsResponse, error) {
	var returnValue *GetTopHitsResponse

	res, resBody, err := c.GetTopHitsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTopSearchesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["clickAnalytics"]; ok {
		err = json.Unmarshal(v, &r.clickAnalytics)
		if err != nil {
			err = json.Unmarshal(b, &r.clickAnalytics)
			if err != nil {
				return fmt.Errorf("cannot unmarshal clickAnalytics: %w", err)
			}
		}
	}
	if v, ok := req["revenueAnalytics"]; ok {
		err = json.Unmarshal(v, &r.revenueAnalytics)
		if err != nil {
			err = json.Unmarshal(b, &r.revenueAnalytics)
			if err != nil {
				return fmt.Errorf("cannot unmarshal revenueAnalytics: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["orderBy"]; ok {
		err = json.Unmarshal(v, &r.orderBy)
		if err != nil {
			err = json.Unmarshal(b, &r.orderBy)
			if err != nil {
				return fmt.Errorf("cannot unmarshal orderBy: %w", err)
			}
		}
	}
	if v, ok := req["direction"]; ok {
		err = json.Unmarshal(v, &r.direction)
		if err != nil {
			err = json.Unmarshal(b, &r.direction)
			if err != nil {
				return fmt.Errorf("cannot unmarshal direction: %w", err)
			}
		}
	}
	if v, ok := req["limit"]; ok {
		err = json.Unmarshal(v, &r.limit)
		if err != nil {
			err = json.Unmarshal(b, &r.limit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal limit: %w", err)
			}
		}
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTopSearchesRequest represents the request with all the parameters for the API call.
type ApiGetTopSearchesRequest struct {
	index            string
	clickAnalytics   *bool
	revenueAnalytics *bool
	startDate        *string
	endDate          *string
	orderBy          OrderBy
	direction        Direction
	limit            *int32
	offset           *int32
	tags             *string
}

// NewApiGetTopSearchesRequest creates an instance of the ApiGetTopSearchesRequest to be used for the API call.
func (c *APIClient) NewApiGetTopSearchesRequest(index string) ApiGetTopSearchesRequest {
	return ApiGetTopSearchesRequest{
		index: index,
	}
}

// WithClickAnalytics adds the clickAnalytics to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithClickAnalytics(clickAnalytics bool) ApiGetTopSearchesRequest {
	r.clickAnalytics = &clickAnalytics
	return r
}

// WithRevenueAnalytics adds the revenueAnalytics to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithRevenueAnalytics(revenueAnalytics bool) ApiGetTopSearchesRequest {
	r.revenueAnalytics = &revenueAnalytics
	return r
}

// WithStartDate adds the startDate to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithStartDate(startDate string) ApiGetTopSearchesRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithEndDate(endDate string) ApiGetTopSearchesRequest {
	r.endDate = &endDate
	return r
}

// WithOrderBy adds the orderBy to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithOrderBy(orderBy OrderBy) ApiGetTopSearchesRequest {
	r.orderBy = orderBy
	return r
}

// WithDirection adds the direction to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithDirection(direction Direction) ApiGetTopSearchesRequest {
	r.direction = direction
	return r
}

// WithLimit adds the limit to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithLimit(limit int32) ApiGetTopSearchesRequest {
	r.limit = &limit
	return r
}

// WithOffset adds the offset to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithOffset(offset int32) ApiGetTopSearchesRequest {
	r.offset = &offset
	return r
}

// WithTags adds the tags to the ApiGetTopSearchesRequest and returns the request for chaining.
func (r ApiGetTopSearchesRequest) WithTags(tags string) ApiGetTopSearchesRequest {
	r.tags = &tags
	return r
}

/*
GetTopSearches calls the API and returns the raw response from it.

	Returns the most popular searches. For each search, it also includes the average number of hits.

# If you set the `clickAnalytics` query parameter to `true`, the response also includes

- Tracked searches count. Tracked searches are Search API requests with the `clickAnalytics` parameter set to `true`. This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.
- Click count
- Click-through rate (CTR)
- Conversion count
- Conversion rate (CR)
- Average click position

If you set the `revenueAnalytics` query parameter to `true`, the response also includes:

- Add-to-cart count
- Add-to-cart rate (ATCR)
- Purchase count
- Purchase rate
- Revenue details for each currency

**There's a difference between 0% rates and null rates:**

- **Null** means there were no queries: since Algolia didn't receive any events, the rates (CTR, CR, ATCR, purchase rate) are null.
- **0% rates** mean there _were_ queries but no [click or conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetTopSearchesRequest with parameters below.
	  @param index string - Index name.
	  @param clickAnalytics bool - Whether to include metrics related to click and conversion events in the response.
	  @param revenueAnalytics bool - Whether to include metrics related to revenue events in the response.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param orderBy OrderBy - Attribute by which to order the response items.  If the `clickAnalytics` parameter is false, only `searchCount` is available.
	  @param direction Direction - Sorting direction of the results: ascending or descending.
	  @param limit int32 - Number of items to return.
	  @param offset int32 - Position of the first item to return.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTopSearchesWithHTTPInfo(r ApiGetTopSearchesRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/searches"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetTopSearches`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.clickAnalytics) {
		conf.queryParams.Set("clickAnalytics", utils.QueryParameterToString(*r.clickAnalytics))
	}
	if !utils.IsNilOrEmpty(r.revenueAnalytics) {
		conf.queryParams.Set("revenueAnalytics", utils.QueryParameterToString(*r.revenueAnalytics))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.orderBy) {
		conf.queryParams.Set("orderBy", utils.QueryParameterToString(r.orderBy))
	}
	if !utils.IsNilOrEmpty(r.direction) {
		conf.queryParams.Set("direction", utils.QueryParameterToString(r.direction))
	}
	if !utils.IsNilOrEmpty(r.limit) {
		conf.queryParams.Set("limit", utils.QueryParameterToString(*r.limit))
	}
	if !utils.IsNilOrEmpty(r.offset) {
		conf.queryParams.Set("offset", utils.QueryParameterToString(*r.offset))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetTopSearches casts the HTTP response body to a defined struct.

Returns the most popular searches. For each search, it also includes the average number of hits.

# If you set the `clickAnalytics` query parameter to `true`, the response also includes

- Tracked searches count. Tracked searches are Search API requests with the `clickAnalytics` parameter set to `true`. This differs from the response's `count`, which shows the overall number of searches, including those where `clickAnalytics` is `false`.
- Click count
- Click-through rate (CTR)
- Conversion count
- Conversion rate (CR)
- Average click position

If you set the `revenueAnalytics` query parameter to `true`, the response also includes:

- Add-to-cart count
- Add-to-cart rate (ATCR)
- Purchase count
- Purchase rate
- Revenue details for each currency

**There's a difference between 0% rates and null rates:**

- **Null** means there were no queries: since Algolia didn't receive any events, the rates (CTR, CR, ATCR, purchase rate) are null.
- **0% rates** mean there _were_ queries but no [click or conversion events](https://www.algolia.com/doc/guides/sending-events/getting-started) were received.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetTopSearchesRequest with parameters below.

	@param index string - Index name.
	@param clickAnalytics bool - Whether to include metrics related to click and conversion events in the response.
	@param revenueAnalytics bool - Whether to include metrics related to revenue events in the response.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param orderBy OrderBy - Attribute by which to order the response items.  If the `clickAnalytics` parameter is false, only `searchCount` is available.
	@param direction Direction - Sorting direction of the results: ascending or descending.
	@param limit int32 - Number of items to return.
	@param offset int32 - Position of the first item to return.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetTopSearchesResponse
*/
func (c *APIClient) GetTopSearches(r ApiGetTopSearchesRequest, opts ...RequestOption) (*GetTopSearchesResponse, error) {
	var returnValue *GetTopSearchesResponse

	res, resBody, err := c.GetTopSearchesWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetUsersCountRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["index"]; ok {
		err = json.Unmarshal(v, &r.index)
		if err != nil {
			err = json.Unmarshal(b, &r.index)
			if err != nil {
				return fmt.Errorf("cannot unmarshal index: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}
	if v, ok := req["tags"]; ok {
		err = json.Unmarshal(v, &r.tags)
		if err != nil {
			err = json.Unmarshal(b, &r.tags)
			if err != nil {
				return fmt.Errorf("cannot unmarshal tags: %w", err)
			}
		}
	}

	return nil
}

// ApiGetUsersCountRequest represents the request with all the parameters for the API call.
type ApiGetUsersCountRequest struct {
	index     string
	startDate *string
	endDate   *string
	tags      *string
}

// NewApiGetUsersCountRequest creates an instance of the ApiGetUsersCountRequest to be used for the API call.
func (c *APIClient) NewApiGetUsersCountRequest(index string) ApiGetUsersCountRequest {
	return ApiGetUsersCountRequest{
		index: index,
	}
}

// WithStartDate adds the startDate to the ApiGetUsersCountRequest and returns the request for chaining.
func (r ApiGetUsersCountRequest) WithStartDate(startDate string) ApiGetUsersCountRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetUsersCountRequest and returns the request for chaining.
func (r ApiGetUsersCountRequest) WithEndDate(endDate string) ApiGetUsersCountRequest {
	r.endDate = &endDate
	return r
}

// WithTags adds the tags to the ApiGetUsersCountRequest and returns the request for chaining.
func (r ApiGetUsersCountRequest) WithTags(tags string) ApiGetUsersCountRequest {
	r.tags = &tags
	return r
}

/*
GetUsersCount calls the API and returns the raw response from it.

	Retrieves the number of unique users within a time range, including a daily breakdown.

Since it returns the number of unique users, the sum of the daily values might be different from the total number.

By default:

- Algolia distinguishes search users by their IP address, _unless_ you include a pseudonymous user identifier in your search requests with the `userToken` API parameter or `x-algolia-usertoken` request header.
- The analyzed period includes the last eight days including the current day.

	    Required API Key ACLs:
	    - analytics

	Request can be constructed by NewApiGetUsersCountRequest with parameters below.
	  @param index string - Index name.
	  @param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	  @param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	  @param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetUsersCountWithHTTPInfo(r ApiGetUsersCountRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/users/count"

	if r.index == "" {
		return nil, nil, reportError("Parameter `index` is required when calling `GetUsersCount`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	conf.queryParams.Set("index", utils.QueryParameterToString(r.index))
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}
	if !utils.IsNilOrEmpty(r.tags) {
		conf.queryParams.Set("tags", utils.QueryParameterToString(*r.tags))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetUsersCount casts the HTTP response body to a defined struct.

Retrieves the number of unique users within a time range, including a daily breakdown.

Since it returns the number of unique users, the sum of the daily values might be different from the total number.

By default:

- Algolia distinguishes search users by their IP address, _unless_ you include a pseudonymous user identifier in your search requests with the `userToken` API parameter or `x-algolia-usertoken` request header.
- The analyzed period includes the last eight days including the current day.

Required API Key ACLs:
  - analytics

Request can be constructed by NewApiGetUsersCountRequest with parameters below.

	@param index string - Index name.
	@param startDate string - Start date of the period to analyze, in `YYYY-MM-DD` format.
	@param endDate string - End date of the period to analyze, in `YYYY-MM-DD` format.
	@param tags string - Tags by which to segment the analytics.  You can combine multiple tags with `OR` and `AND`. Tags must be URL-encoded. For more information, see [Segment your analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments).
	@return GetUsersCountResponse
*/
func (c *APIClient) GetUsersCount(r ApiGetUsersCountRequest, opts ...RequestOption) (*GetUsersCountResponse, error) {
	var returnValue *GetUsersCountResponse

	res, resBody, err := c.GetUsersCountWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
