// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package search

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/call"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       name,
		value:      parameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

func (r *ApiAddApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["apiKey"]; ok {
		err = json.Unmarshal(v, &r.apiKey)
		if err != nil {
			err = json.Unmarshal(b, &r.apiKey)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.apiKey)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiAddApiKeyRequest represents the request with all the parameters for the API call.
type ApiAddApiKeyRequest struct {
	apiKey *ApiKey
}

// NewApiAddApiKeyRequest creates an instance of the ApiAddApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiAddApiKeyRequest(apiKey *ApiKey) ApiAddApiKeyRequest {
	return ApiAddApiKeyRequest{
		apiKey: apiKey,
	}
}

/*
AddApiKey Create an API key. Wraps AddApiKeyWithContext using context.Background.

Add a new API Key with specific permissions/restrictions.

Request can be constructed by NewApiAddApiKeyRequest with parameters below.

	@param apiKey ApiKey
	@return AddApiKeyResponse
*/
func (c *APIClient) AddApiKey(r ApiAddApiKeyRequest, opts ...Option) (*AddApiKeyResponse, error) {
	return c.AddApiKeyWithContext(context.Background(), r, opts...)
}

/*
AddApiKey Create an API key.

Add a new API Key with specific permissions/restrictions.

Request can be constructed by NewApiAddApiKeyRequest with parameters below.

	@param apiKey ApiKey
	@return AddApiKeyResponse
*/
func (c *APIClient) AddApiKeyWithContext(ctx context.Context, r ApiAddApiKeyRequest, opts ...Option) (*AddApiKeyResponse, error) {
	var (
		postBody    any
		returnValue *AddApiKeyResponse
	)

	requestPath := "/1/keys"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.apiKey == nil {
		return returnValue, reportError("apiKey is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.apiKey
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiAddOrUpdateObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.body)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiAddOrUpdateObjectRequest represents the request with all the parameters for the API call.
type ApiAddOrUpdateObjectRequest struct {
	indexName string
	objectID  string
	body      map[string]interface{}
}

// NewApiAddOrUpdateObjectRequest creates an instance of the ApiAddOrUpdateObjectRequest to be used for the API call.
func (c *APIClient) NewApiAddOrUpdateObjectRequest(indexName string, objectID string, body map[string]interface{}) ApiAddOrUpdateObjectRequest {
	return ApiAddOrUpdateObjectRequest{
		indexName: indexName,
		objectID:  objectID,
		body:      body,
	}
}

/*
AddOrUpdateObject Add or replace an object. Wraps AddOrUpdateObjectWithContext using context.Background.

Add or replace an object with a given object ID.
If the object does not exist, it will be created.
If it already exists, it will be replaced.

Request can be constructed by NewApiAddOrUpdateObjectRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param body map[string]interface{} - The Algolia object.
	@return UpdatedAtWithObjectIdResponse
*/
func (c *APIClient) AddOrUpdateObject(r ApiAddOrUpdateObjectRequest, opts ...Option) (*UpdatedAtWithObjectIdResponse, error) {
	return c.AddOrUpdateObjectWithContext(context.Background(), r, opts...)
}

/*
AddOrUpdateObject Add or replace an object.

Add or replace an object with a given object ID.
If the object does not exist, it will be created.
If it already exists, it will be replaced.

Request can be constructed by NewApiAddOrUpdateObjectRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param body map[string]interface{} - The Algolia object.
	@return UpdatedAtWithObjectIdResponse
*/
func (c *APIClient) AddOrUpdateObjectWithContext(ctx context.Context, r ApiAddOrUpdateObjectRequest, opts ...Option) (*UpdatedAtWithObjectIdResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtWithObjectIdResponse
	)

	requestPath := "/1/indexes/{indexName}/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.body
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiAppendSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["source"]; ok {
		err = json.Unmarshal(v, &r.source)
		if err != nil {
			err = json.Unmarshal(b, &r.source)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.source)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiAppendSourceRequest represents the request with all the parameters for the API call.
type ApiAppendSourceRequest struct {
	source *Source
}

// NewApiAppendSourceRequest creates an instance of the ApiAppendSourceRequest to be used for the API call.
func (c *APIClient) NewApiAppendSourceRequest(source *Source) ApiAppendSourceRequest {
	return ApiAppendSourceRequest{
		source: source,
	}
}

/*
AppendSource Add a single source. Wraps AppendSourceWithContext using context.Background.

Add a single source to the list of allowed sources.

Request can be constructed by NewApiAppendSourceRequest with parameters below.

	@param source Source - The source to add.
	@return CreatedAtResponse
*/
func (c *APIClient) AppendSource(r ApiAppendSourceRequest, opts ...Option) (*CreatedAtResponse, error) {
	return c.AppendSourceWithContext(context.Background(), r, opts...)
}

/*
AppendSource Add a single source.

Add a single source to the list of allowed sources.

Request can be constructed by NewApiAppendSourceRequest with parameters below.

	@param source Source - The source to add.
	@return CreatedAtResponse
*/
func (c *APIClient) AppendSourceWithContext(ctx context.Context, r ApiAppendSourceRequest, opts ...Option) (*CreatedAtResponse, error) {
	var (
		postBody    any
		returnValue *CreatedAtResponse
	)

	requestPath := "/1/security/sources/append"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.source == nil {
		return returnValue, reportError("source is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.source
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiAssignUserIdRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["xAlgoliaUserID"]; ok {
		err = json.Unmarshal(v, &r.xAlgoliaUserID)
		if err != nil {
			err = json.Unmarshal(b, &r.xAlgoliaUserID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["assignUserIdParams"]; ok {
		err = json.Unmarshal(v, &r.assignUserIdParams)
		if err != nil {
			err = json.Unmarshal(b, &r.assignUserIdParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.assignUserIdParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiAssignUserIdRequest represents the request with all the parameters for the API call.
type ApiAssignUserIdRequest struct {
	xAlgoliaUserID     string
	assignUserIdParams *AssignUserIdParams
}

// NewApiAssignUserIdRequest creates an instance of the ApiAssignUserIdRequest to be used for the API call.
func (c *APIClient) NewApiAssignUserIdRequest(xAlgoliaUserID string, assignUserIdParams *AssignUserIdParams) ApiAssignUserIdRequest {
	return ApiAssignUserIdRequest{
		xAlgoliaUserID:     xAlgoliaUserID,
		assignUserIdParams: assignUserIdParams,
	}
}

/*
AssignUserId Assign or Move userID. Wraps AssignUserIdWithContext using context.Background.

Assign or Move a userID to a cluster.
The time it takes to migrate (move) a user is proportional to the amount of data linked to the userID.
Upon success, the response is 200 OK.
A successful response indicates that the operation has been taken into account, and the userID is directly usable.

Request can be constructed by NewApiAssignUserIdRequest with parameters below.

	@param xAlgoliaUserID string - userID to assign.
	@param assignUserIdParams AssignUserIdParams
	@return CreatedAtResponse
*/
func (c *APIClient) AssignUserId(r ApiAssignUserIdRequest, opts ...Option) (*CreatedAtResponse, error) {
	return c.AssignUserIdWithContext(context.Background(), r, opts...)
}

/*
AssignUserId Assign or Move userID.

Assign or Move a userID to a cluster.
The time it takes to migrate (move) a user is proportional to the amount of data linked to the userID.
Upon success, the response is 200 OK.
A successful response indicates that the operation has been taken into account, and the userID is directly usable.

Request can be constructed by NewApiAssignUserIdRequest with parameters below.

	@param xAlgoliaUserID string - userID to assign.
	@param assignUserIdParams AssignUserIdParams
	@return CreatedAtResponse
*/
func (c *APIClient) AssignUserIdWithContext(ctx context.Context, r ApiAssignUserIdRequest, opts ...Option) (*CreatedAtResponse, error) {
	var (
		postBody    any
		returnValue *CreatedAtResponse
	)

	requestPath := "/1/clusters/mapping"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.xAlgoliaUserID == "" {
		return returnValue, reportError("xAlgoliaUserID is required and must be specified")
	}
	if r.assignUserIdParams == nil {
		return returnValue, reportError("assignUserIdParams is required and must be specified")
	}

	headers["X-Algolia-User-ID"] = parameterToString(r.xAlgoliaUserID)

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.assignUserIdParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiBatchRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["batchWriteParams"]; ok {
		err = json.Unmarshal(v, &r.batchWriteParams)
		if err != nil {
			err = json.Unmarshal(b, &r.batchWriteParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.batchWriteParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiBatchRequest represents the request with all the parameters for the API call.
type ApiBatchRequest struct {
	indexName        string
	batchWriteParams *BatchWriteParams
}

// NewApiBatchRequest creates an instance of the ApiBatchRequest to be used for the API call.
func (c *APIClient) NewApiBatchRequest(indexName string, batchWriteParams *BatchWriteParams) ApiBatchRequest {
	return ApiBatchRequest{
		indexName:        indexName,
		batchWriteParams: batchWriteParams,
	}
}

/*
Batch Batch operations to one index. Wraps BatchWithContext using context.Background.

Perform multiple write operations targeting one index, in a single API call.

Request can be constructed by NewApiBatchRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param batchWriteParams BatchWriteParams
	@return BatchResponse
*/
func (c *APIClient) Batch(r ApiBatchRequest, opts ...Option) (*BatchResponse, error) {
	return c.BatchWithContext(context.Background(), r, opts...)
}

/*
Batch Batch operations to one index.

Perform multiple write operations targeting one index, in a single API call.

Request can be constructed by NewApiBatchRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param batchWriteParams BatchWriteParams
	@return BatchResponse
*/
func (c *APIClient) BatchWithContext(ctx context.Context, r ApiBatchRequest, opts ...Option) (*BatchResponse, error) {
	var (
		postBody    any
		returnValue *BatchResponse
	)

	requestPath := "/1/indexes/{indexName}/batch"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.batchWriteParams == nil {
		return returnValue, reportError("batchWriteParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.batchWriteParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiBatchAssignUserIdsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["xAlgoliaUserID"]; ok {
		err = json.Unmarshal(v, &r.xAlgoliaUserID)
		if err != nil {
			err = json.Unmarshal(b, &r.xAlgoliaUserID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["batchAssignUserIdsParams"]; ok {
		err = json.Unmarshal(v, &r.batchAssignUserIdsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.batchAssignUserIdsParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.batchAssignUserIdsParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiBatchAssignUserIdsRequest represents the request with all the parameters for the API call.
type ApiBatchAssignUserIdsRequest struct {
	xAlgoliaUserID           string
	batchAssignUserIdsParams *BatchAssignUserIdsParams
}

// NewApiBatchAssignUserIdsRequest creates an instance of the ApiBatchAssignUserIdsRequest to be used for the API call.
func (c *APIClient) NewApiBatchAssignUserIdsRequest(xAlgoliaUserID string, batchAssignUserIdsParams *BatchAssignUserIdsParams) ApiBatchAssignUserIdsRequest {
	return ApiBatchAssignUserIdsRequest{
		xAlgoliaUserID:           xAlgoliaUserID,
		batchAssignUserIdsParams: batchAssignUserIdsParams,
	}
}

/*
BatchAssignUserIds Batch assign userIDs. Wraps BatchAssignUserIdsWithContext using context.Background.

Assign multiple userIDs to a cluster.
Upon success, the response is 200 OK.
A successful response indicates that the operation has been taken into account, and the userIDs are directly usable.

Request can be constructed by NewApiBatchAssignUserIdsRequest with parameters below.

	@param xAlgoliaUserID string - userID to assign.
	@param batchAssignUserIdsParams BatchAssignUserIdsParams
	@return CreatedAtResponse
*/
func (c *APIClient) BatchAssignUserIds(r ApiBatchAssignUserIdsRequest, opts ...Option) (*CreatedAtResponse, error) {
	return c.BatchAssignUserIdsWithContext(context.Background(), r, opts...)
}

/*
BatchAssignUserIds Batch assign userIDs.

Assign multiple userIDs to a cluster.
Upon success, the response is 200 OK.
A successful response indicates that the operation has been taken into account, and the userIDs are directly usable.

Request can be constructed by NewApiBatchAssignUserIdsRequest with parameters below.

	@param xAlgoliaUserID string - userID to assign.
	@param batchAssignUserIdsParams BatchAssignUserIdsParams
	@return CreatedAtResponse
*/
func (c *APIClient) BatchAssignUserIdsWithContext(ctx context.Context, r ApiBatchAssignUserIdsRequest, opts ...Option) (*CreatedAtResponse, error) {
	var (
		postBody    any
		returnValue *CreatedAtResponse
	)

	requestPath := "/1/clusters/mapping/batch"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.xAlgoliaUserID == "" {
		return returnValue, reportError("xAlgoliaUserID is required and must be specified")
	}
	if r.batchAssignUserIdsParams == nil {
		return returnValue, reportError("batchAssignUserIdsParams is required and must be specified")
	}

	headers["X-Algolia-User-ID"] = parameterToString(r.xAlgoliaUserID)

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.batchAssignUserIdsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiBatchDictionaryEntriesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["dictionaryName"]; ok {
		err = json.Unmarshal(v, &r.dictionaryName)
		if err != nil {
			err = json.Unmarshal(b, &r.dictionaryName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["batchDictionaryEntriesParams"]; ok {
		err = json.Unmarshal(v, &r.batchDictionaryEntriesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.batchDictionaryEntriesParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.batchDictionaryEntriesParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiBatchDictionaryEntriesRequest represents the request with all the parameters for the API call.
type ApiBatchDictionaryEntriesRequest struct {
	dictionaryName               DictionaryType
	batchDictionaryEntriesParams *BatchDictionaryEntriesParams
}

// NewApiBatchDictionaryEntriesRequest creates an instance of the ApiBatchDictionaryEntriesRequest to be used for the API call.
func (c *APIClient) NewApiBatchDictionaryEntriesRequest(dictionaryName DictionaryType, batchDictionaryEntriesParams *BatchDictionaryEntriesParams) ApiBatchDictionaryEntriesRequest {
	return ApiBatchDictionaryEntriesRequest{
		dictionaryName:               dictionaryName,
		batchDictionaryEntriesParams: batchDictionaryEntriesParams,
	}
}

/*
BatchDictionaryEntries Batch dictionary entries. Wraps BatchDictionaryEntriesWithContext using context.Background.

Send a batch of dictionary entries.

Request can be constructed by NewApiBatchDictionaryEntriesRequest with parameters below.

	@param dictionaryName DictionaryType - The dictionary to search in.
	@param batchDictionaryEntriesParams BatchDictionaryEntriesParams
	@return UpdatedAtResponse
*/
func (c *APIClient) BatchDictionaryEntries(r ApiBatchDictionaryEntriesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.BatchDictionaryEntriesWithContext(context.Background(), r, opts...)
}

/*
BatchDictionaryEntries Batch dictionary entries.

Send a batch of dictionary entries.

Request can be constructed by NewApiBatchDictionaryEntriesRequest with parameters below.

	@param dictionaryName DictionaryType - The dictionary to search in.
	@param batchDictionaryEntriesParams BatchDictionaryEntriesParams
	@return UpdatedAtResponse
*/
func (c *APIClient) BatchDictionaryEntriesWithContext(ctx context.Context, r ApiBatchDictionaryEntriesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/dictionaries/{dictionaryName}/batch"
	requestPath = strings.Replace(requestPath, "{"+"dictionaryName"+"}", url.PathEscape(parameterToString(r.dictionaryName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.batchDictionaryEntriesParams == nil {
		return returnValue, reportError("batchDictionaryEntriesParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.batchDictionaryEntriesParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiBrowseRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["browseParams"]; ok {
		err = json.Unmarshal(v, &r.browseParams)
		if err != nil {
			err = json.Unmarshal(b, &r.browseParams)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiBrowseRequest represents the request with all the parameters for the API call.
type ApiBrowseRequest struct {
	indexName    string
	browseParams *BrowseParams
}

// NewApiBrowseRequest creates an instance of the ApiBrowseRequest to be used for the API call.
func (c *APIClient) NewApiBrowseRequest(indexName string) ApiBrowseRequest {
	return ApiBrowseRequest{
		indexName: indexName,
	}
}

// WithBrowseParams adds the browseParams to the ApiBrowseRequest and returns the request for chaining.
func (r ApiBrowseRequest) WithBrowseParams(browseParams *BrowseParams) ApiBrowseRequest {
	r.browseParams = browseParams
	return r
}

/*
Browse Retrieve all index content. Wraps BrowseWithContext using context.Background.

This method allows you to retrieve all index content. It can retrieve up to 1,000 records per call and supports full text search and filters.
For performance reasons, some features are not supported, including `distinct`, sorting by `typos`, `words` or `geo distance`.
When there is more content to be browsed, the response contains a cursor field. This cursor has to be passed to the subsequent call to browse in order to get the next page of results. When the end of the index has been reached, the cursor field is absent from the response.

Request can be constructed by NewApiBrowseRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param browseParams BrowseParams
	@return BrowseResponse
*/
func (c *APIClient) Browse(r ApiBrowseRequest, opts ...Option) (*BrowseResponse, error) {
	return c.BrowseWithContext(context.Background(), r, opts...)
}

/*
Browse Retrieve all index content.

This method allows you to retrieve all index content. It can retrieve up to 1,000 records per call and supports full text search and filters.
For performance reasons, some features are not supported, including `distinct`, sorting by `typos`, `words` or `geo distance`.
When there is more content to be browsed, the response contains a cursor field. This cursor has to be passed to the subsequent call to browse in order to get the next page of results. When the end of the index has been reached, the cursor field is absent from the response.

Request can be constructed by NewApiBrowseRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param browseParams BrowseParams
	@return BrowseResponse
*/
func (c *APIClient) BrowseWithContext(ctx context.Context, r ApiBrowseRequest, opts ...Option) (*BrowseResponse, error) {
	var (
		postBody    any
		returnValue *BrowseResponse
	)

	requestPath := "/1/indexes/{indexName}/browse"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.browseParams) {
		postBody = "{}"
	} else {
		postBody = r.browseParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiClearAllSynonymsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiClearAllSynonymsRequest represents the request with all the parameters for the API call.
type ApiClearAllSynonymsRequest struct {
	indexName         string
	forwardToReplicas bool
}

// NewApiClearAllSynonymsRequest creates an instance of the ApiClearAllSynonymsRequest to be used for the API call.
func (c *APIClient) NewApiClearAllSynonymsRequest(indexName string) ApiClearAllSynonymsRequest {
	return ApiClearAllSynonymsRequest{
		indexName: indexName,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiClearAllSynonymsRequest and returns the request for chaining.
func (r ApiClearAllSynonymsRequest) WithForwardToReplicas(forwardToReplicas bool) ApiClearAllSynonymsRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
ClearAllSynonyms Clear all synonyms. Wraps ClearAllSynonymsWithContext using context.Background.

Remove all synonyms from an index.

Request can be constructed by NewApiClearAllSynonymsRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearAllSynonyms(r ApiClearAllSynonymsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.ClearAllSynonymsWithContext(context.Background(), r, opts...)
}

/*
ClearAllSynonyms Clear all synonyms.

Remove all synonyms from an index.

Request can be constructed by NewApiClearAllSynonymsRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearAllSynonymsWithContext(ctx context.Context, r ApiClearAllSynonymsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/synonyms/clear"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiClearObjectsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiClearObjectsRequest represents the request with all the parameters for the API call.
type ApiClearObjectsRequest struct {
	indexName string
}

// NewApiClearObjectsRequest creates an instance of the ApiClearObjectsRequest to be used for the API call.
func (c *APIClient) NewApiClearObjectsRequest(indexName string) ApiClearObjectsRequest {
	return ApiClearObjectsRequest{
		indexName: indexName,
	}
}

/*
ClearObjects Clear all objects from an index. Wraps ClearObjectsWithContext using context.Background.

Delete an index's content, but leave settings and index-specific API keys untouched.

Request can be constructed by NewApiClearObjectsRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearObjects(r ApiClearObjectsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.ClearObjectsWithContext(context.Background(), r, opts...)
}

/*
ClearObjects Clear all objects from an index.

Delete an index's content, but leave settings and index-specific API keys untouched.

Request can be constructed by NewApiClearObjectsRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearObjectsWithContext(ctx context.Context, r ApiClearObjectsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/clear"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiClearRulesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiClearRulesRequest represents the request with all the parameters for the API call.
type ApiClearRulesRequest struct {
	indexName         string
	forwardToReplicas bool
}

// NewApiClearRulesRequest creates an instance of the ApiClearRulesRequest to be used for the API call.
func (c *APIClient) NewApiClearRulesRequest(indexName string) ApiClearRulesRequest {
	return ApiClearRulesRequest{
		indexName: indexName,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiClearRulesRequest and returns the request for chaining.
func (r ApiClearRulesRequest) WithForwardToReplicas(forwardToReplicas bool) ApiClearRulesRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
ClearRules Clear Rules. Wraps ClearRulesWithContext using context.Background.

Delete all Rules in the index.

Request can be constructed by NewApiClearRulesRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearRules(r ApiClearRulesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.ClearRulesWithContext(context.Background(), r, opts...)
}

/*
ClearRules Clear Rules.

Delete all Rules in the index.

Request can be constructed by NewApiClearRulesRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearRulesWithContext(ctx context.Context, r ApiClearRulesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/rules/clear"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDelRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDelRequest represents the request with all the parameters for the API call.
type ApiDelRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiDelRequest creates an instance of the ApiDelRequest to be used for the API call.
func (c *APIClient) NewApiDelRequest(path string) ApiDelRequest {
	return ApiDelRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiDelRequest and returns the request for chaining.
func (r ApiDelRequest) WithParameters(parameters map[string]interface{}) ApiDelRequest {
	r.parameters = parameters
	return r
}

/*
Del Send requests to the Algolia REST API. Wraps DelWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiDelRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) Del(r ApiDelRequest, opts ...Option) (map[string]interface{}, error) {
	return c.DelWithContext(context.Background(), r, opts...)
}

/*
Del Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiDelRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) DelWithContext(ctx context.Context, r ApiDelRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["key"]; ok {
		err = json.Unmarshal(v, &r.key)
		if err != nil {
			err = json.Unmarshal(b, &r.key)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteApiKeyRequest represents the request with all the parameters for the API call.
type ApiDeleteApiKeyRequest struct {
	key string
}

// NewApiDeleteApiKeyRequest creates an instance of the ApiDeleteApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiDeleteApiKeyRequest(key string) ApiDeleteApiKeyRequest {
	return ApiDeleteApiKeyRequest{
		key: key,
	}
}

/*
DeleteApiKey Delete an API key. Wraps DeleteApiKeyWithContext using context.Background.

Delete an existing API Key.

Request can be constructed by NewApiDeleteApiKeyRequest with parameters below.

	@param key string - API Key string.
	@return DeleteApiKeyResponse
*/
func (c *APIClient) DeleteApiKey(r ApiDeleteApiKeyRequest, opts ...Option) (*DeleteApiKeyResponse, error) {
	return c.DeleteApiKeyWithContext(context.Background(), r, opts...)
}

/*
DeleteApiKey Delete an API key.

Delete an existing API Key.

Request can be constructed by NewApiDeleteApiKeyRequest with parameters below.

	@param key string - API Key string.
	@return DeleteApiKeyResponse
*/
func (c *APIClient) DeleteApiKeyWithContext(ctx context.Context, r ApiDeleteApiKeyRequest, opts ...Option) (*DeleteApiKeyResponse, error) {
	var (
		postBody    any
		returnValue *DeleteApiKeyResponse
	)

	requestPath := "/1/keys/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(parameterToString(r.key)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteByRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["deleteByParams"]; ok {
		err = json.Unmarshal(v, &r.deleteByParams)
		if err != nil {
			err = json.Unmarshal(b, &r.deleteByParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.deleteByParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiDeleteByRequest represents the request with all the parameters for the API call.
type ApiDeleteByRequest struct {
	indexName      string
	deleteByParams *DeleteByParams
}

// NewApiDeleteByRequest creates an instance of the ApiDeleteByRequest to be used for the API call.
func (c *APIClient) NewApiDeleteByRequest(indexName string, deleteByParams *DeleteByParams) ApiDeleteByRequest {
	return ApiDeleteByRequest{
		indexName:      indexName,
		deleteByParams: deleteByParams,
	}
}

/*
DeleteBy Delete all records matching the query. Wraps DeleteByWithContext using context.Background.

Remove all objects matching a filter (including geo filters).
This method enables you to delete one or more objects based on filters (numeric, facet, tag or geo queries).
It doesn't accept empty filters or a query.

Request can be constructed by NewApiDeleteByRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param deleteByParams DeleteByParams
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteBy(r ApiDeleteByRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteByWithContext(context.Background(), r, opts...)
}

/*
DeleteBy Delete all records matching the query.

Remove all objects matching a filter (including geo filters).
This method enables you to delete one or more objects based on filters (numeric, facet, tag or geo queries).
It doesn't accept empty filters or a query.

Request can be constructed by NewApiDeleteByRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param deleteByParams DeleteByParams
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteByWithContext(ctx context.Context, r ApiDeleteByRequest, opts ...Option) (*DeletedAtResponse, error) {
	var (
		postBody    any
		returnValue *DeletedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/deleteByQuery"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.deleteByParams == nil {
		return returnValue, reportError("deleteByParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.deleteByParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteIndexRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteIndexRequest represents the request with all the parameters for the API call.
type ApiDeleteIndexRequest struct {
	indexName string
}

// NewApiDeleteIndexRequest creates an instance of the ApiDeleteIndexRequest to be used for the API call.
func (c *APIClient) NewApiDeleteIndexRequest(indexName string) ApiDeleteIndexRequest {
	return ApiDeleteIndexRequest{
		indexName: indexName,
	}
}

/*
DeleteIndex Delete index. Wraps DeleteIndexWithContext using context.Background.

Delete an existing index.

Request can be constructed by NewApiDeleteIndexRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteIndex(r ApiDeleteIndexRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteIndexWithContext(context.Background(), r, opts...)
}

/*
DeleteIndex Delete index.

Delete an existing index.

Request can be constructed by NewApiDeleteIndexRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteIndexWithContext(ctx context.Context, r ApiDeleteIndexRequest, opts ...Option) (*DeletedAtResponse, error) {
	var (
		postBody    any
		returnValue *DeletedAtResponse
	)

	requestPath := "/1/indexes/{indexName}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteObjectRequest represents the request with all the parameters for the API call.
type ApiDeleteObjectRequest struct {
	indexName string
	objectID  string
}

// NewApiDeleteObjectRequest creates an instance of the ApiDeleteObjectRequest to be used for the API call.
func (c *APIClient) NewApiDeleteObjectRequest(indexName string, objectID string) ApiDeleteObjectRequest {
	return ApiDeleteObjectRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

/*
DeleteObject Delete an object. Wraps DeleteObjectWithContext using context.Background.

Delete an existing object.

Request can be constructed by NewApiDeleteObjectRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteObject(r ApiDeleteObjectRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteObjectWithContext(context.Background(), r, opts...)
}

/*
DeleteObject Delete an object.

Delete an existing object.

Request can be constructed by NewApiDeleteObjectRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteObjectWithContext(ctx context.Context, r ApiDeleteObjectRequest, opts ...Option) (*DeletedAtResponse, error) {
	var (
		postBody    any
		returnValue *DeletedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteRuleRequest represents the request with all the parameters for the API call.
type ApiDeleteRuleRequest struct {
	indexName         string
	objectID          string
	forwardToReplicas bool
}

// NewApiDeleteRuleRequest creates an instance of the ApiDeleteRuleRequest to be used for the API call.
func (c *APIClient) NewApiDeleteRuleRequest(indexName string, objectID string) ApiDeleteRuleRequest {
	return ApiDeleteRuleRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiDeleteRuleRequest and returns the request for chaining.
func (r ApiDeleteRuleRequest) WithForwardToReplicas(forwardToReplicas bool) ApiDeleteRuleRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
DeleteRule Delete a rule. Wraps DeleteRuleWithContext using context.Background.

Delete the Rule with the specified objectID.

Request can be constructed by NewApiDeleteRuleRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return UpdatedAtResponse
*/
func (c *APIClient) DeleteRule(r ApiDeleteRuleRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.DeleteRuleWithContext(context.Background(), r, opts...)
}

/*
DeleteRule Delete a rule.

Delete the Rule with the specified objectID.

Request can be constructed by NewApiDeleteRuleRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return UpdatedAtResponse
*/
func (c *APIClient) DeleteRuleWithContext(ctx context.Context, r ApiDeleteRuleRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/rules/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["source"]; ok {
		err = json.Unmarshal(v, &r.source)
		if err != nil {
			err = json.Unmarshal(b, &r.source)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteSourceRequest represents the request with all the parameters for the API call.
type ApiDeleteSourceRequest struct {
	source string
}

// NewApiDeleteSourceRequest creates an instance of the ApiDeleteSourceRequest to be used for the API call.
func (c *APIClient) NewApiDeleteSourceRequest(source string) ApiDeleteSourceRequest {
	return ApiDeleteSourceRequest{
		source: source,
	}
}

/*
DeleteSource Remove a single source. Wraps DeleteSourceWithContext using context.Background.

Remove a single source from the list of allowed sources.

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param source string - The IP range of the source.
	@return DeleteSourceResponse
*/
func (c *APIClient) DeleteSource(r ApiDeleteSourceRequest, opts ...Option) (*DeleteSourceResponse, error) {
	return c.DeleteSourceWithContext(context.Background(), r, opts...)
}

/*
DeleteSource Remove a single source.

Remove a single source from the list of allowed sources.

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param source string - The IP range of the source.
	@return DeleteSourceResponse
*/
func (c *APIClient) DeleteSourceWithContext(ctx context.Context, r ApiDeleteSourceRequest, opts ...Option) (*DeleteSourceResponse, error) {
	var (
		postBody    any
		returnValue *DeleteSourceResponse
	)

	requestPath := "/1/security/sources/{source}"
	requestPath = strings.Replace(requestPath, "{"+"source"+"}", url.PathEscape(parameterToString(r.source)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteSynonymRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteSynonymRequest represents the request with all the parameters for the API call.
type ApiDeleteSynonymRequest struct {
	indexName         string
	objectID          string
	forwardToReplicas bool
}

// NewApiDeleteSynonymRequest creates an instance of the ApiDeleteSynonymRequest to be used for the API call.
func (c *APIClient) NewApiDeleteSynonymRequest(indexName string, objectID string) ApiDeleteSynonymRequest {
	return ApiDeleteSynonymRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiDeleteSynonymRequest and returns the request for chaining.
func (r ApiDeleteSynonymRequest) WithForwardToReplicas(forwardToReplicas bool) ApiDeleteSynonymRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
DeleteSynonym Delete synonym. Wraps DeleteSynonymWithContext using context.Background.

Delete a single synonyms set, identified by the given objectID.

Request can be constructed by NewApiDeleteSynonymRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteSynonym(r ApiDeleteSynonymRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteSynonymWithContext(context.Background(), r, opts...)
}

/*
DeleteSynonym Delete synonym.

Delete a single synonyms set, identified by the given objectID.

Request can be constructed by NewApiDeleteSynonymRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteSynonymWithContext(ctx context.Context, r ApiDeleteSynonymRequest, opts ...Option) (*DeletedAtResponse, error) {
	var (
		postBody    any
		returnValue *DeletedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/synonyms/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetRequest represents the request with all the parameters for the API call.
type ApiGetRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiGetRequest creates an instance of the ApiGetRequest to be used for the API call.
func (c *APIClient) NewApiGetRequest(path string) ApiGetRequest {
	return ApiGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiGetRequest and returns the request for chaining.
func (r ApiGetRequest) WithParameters(parameters map[string]interface{}) ApiGetRequest {
	r.parameters = parameters
	return r
}

/*
Get Send requests to the Algolia REST API. Wraps GetWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiGetRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) Get(r ApiGetRequest, opts ...Option) (map[string]interface{}, error) {
	return c.GetWithContext(context.Background(), r, opts...)
}

/*
Get Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiGetRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) GetWithContext(ctx context.Context, r ApiGetRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["key"]; ok {
		err = json.Unmarshal(v, &r.key)
		if err != nil {
			err = json.Unmarshal(b, &r.key)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetApiKeyRequest represents the request with all the parameters for the API call.
type ApiGetApiKeyRequest struct {
	key string
}

// NewApiGetApiKeyRequest creates an instance of the ApiGetApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiGetApiKeyRequest(key string) ApiGetApiKeyRequest {
	return ApiGetApiKeyRequest{
		key: key,
	}
}

/*
GetApiKey Get an API key. Wraps GetApiKeyWithContext using context.Background.

Get the permissions of an API key.

Request can be constructed by NewApiGetApiKeyRequest with parameters below.

	@param key string - API Key string.
	@return GetApiKeyResponse
*/
func (c *APIClient) GetApiKey(r ApiGetApiKeyRequest, opts ...Option) (*GetApiKeyResponse, error) {
	return c.GetApiKeyWithContext(context.Background(), r, opts...)
}

/*
GetApiKey Get an API key.

Get the permissions of an API key.

Request can be constructed by NewApiGetApiKeyRequest with parameters below.

	@param key string - API Key string.
	@return GetApiKeyResponse
*/
func (c *APIClient) GetApiKeyWithContext(ctx context.Context, r ApiGetApiKeyRequest, opts ...Option) (*GetApiKeyResponse, error) {
	var (
		postBody    any
		returnValue *GetApiKeyResponse
	)

	requestPath := "/1/keys/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(parameterToString(r.key)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetDictionaryLanguages List available languages. Wraps GetDictionaryLanguagesWithContext using context.Background.

List dictionaries supported per language.

Request can be constructed by NewApiGetDictionaryLanguagesRequest with parameters below.

	@return map[string]Languages
*/
func (c *APIClient) GetDictionaryLanguages(opts ...Option) (*map[string]Languages, error) {
	return c.GetDictionaryLanguagesWithContext(context.Background(), opts...)
}

/*
GetDictionaryLanguages List available languages.

List dictionaries supported per language.

Request can be constructed by NewApiGetDictionaryLanguagesRequest with parameters below.

	@return map[string]Languages
*/
func (c *APIClient) GetDictionaryLanguagesWithContext(ctx context.Context, opts ...Option) (*map[string]Languages, error) {
	var (
		postBody    any
		returnValue *map[string]Languages
	)

	requestPath := "/1/dictionaries/*/languages"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetDictionarySettings Retrieve dictionaries settings. Wraps GetDictionarySettingsWithContext using context.Background.

Retrieve dictionaries settings. The API stores languages whose standard entries are disabled. Fetch settings does not return false values.

Request can be constructed by NewApiGetDictionarySettingsRequest with parameters below.

	@return GetDictionarySettingsResponse
*/
func (c *APIClient) GetDictionarySettings(opts ...Option) (*GetDictionarySettingsResponse, error) {
	return c.GetDictionarySettingsWithContext(context.Background(), opts...)
}

/*
GetDictionarySettings Retrieve dictionaries settings.

Retrieve dictionaries settings. The API stores languages whose standard entries are disabled. Fetch settings does not return false values.

Request can be constructed by NewApiGetDictionarySettingsRequest with parameters below.

	@return GetDictionarySettingsResponse
*/
func (c *APIClient) GetDictionarySettingsWithContext(ctx context.Context, opts ...Option) (*GetDictionarySettingsResponse, error) {
	var (
		postBody    any
		returnValue *GetDictionarySettingsResponse
	)

	requestPath := "/1/dictionaries/*/settings"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetLogsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["length"]; ok {
		err = json.Unmarshal(v, &r.length)
		if err != nil {
			err = json.Unmarshal(b, &r.length)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetLogsRequest represents the request with all the parameters for the API call.
type ApiGetLogsRequest struct {
	offset    int32
	length    int32
	indexName string
	type_     *LogType
}

// NewApiGetLogsRequest creates an instance of the ApiGetLogsRequest to be used for the API call.
func (c *APIClient) NewApiGetLogsRequest() ApiGetLogsRequest {
	return ApiGetLogsRequest{}
}

// WithOffset adds the offset to the ApiGetLogsRequest and returns the request for chaining.
func (r ApiGetLogsRequest) WithOffset(offset int32) ApiGetLogsRequest {
	r.offset = offset
	return r
}

// WithLength adds the length to the ApiGetLogsRequest and returns the request for chaining.
func (r ApiGetLogsRequest) WithLength(length int32) ApiGetLogsRequest {
	r.length = length
	return r
}

// WithIndexName adds the indexName to the ApiGetLogsRequest and returns the request for chaining.
func (r ApiGetLogsRequest) WithIndexName(indexName string) ApiGetLogsRequest {
	r.indexName = indexName
	return r
}

// WithType_ adds the type_ to the ApiGetLogsRequest and returns the request for chaining.
func (r ApiGetLogsRequest) WithType_(type_ *LogType) ApiGetLogsRequest {
	r.type_ = type_
	return r
}

/*
GetLogs Return the latest log entries. Wraps GetLogsWithContext using context.Background.

Return the latest log entries.

Request can be constructed by NewApiGetLogsRequest with parameters below.

	@param offset int32 - First entry to retrieve (zero-based). Log entries are sorted by decreasing date, therefore 0 designates the most recent log entry.
	@param length int32 - Maximum number of entries to retrieve. The maximum allowed value is 1000.
	@param indexName string - Index for which log entries should be retrieved. When omitted, log entries are retrieved across all indices.
	@param type_ LogType - Type of log entries to retrieve. When omitted, all log entries are retrieved.
	@return GetLogsResponse
*/
func (c *APIClient) GetLogs(r ApiGetLogsRequest, opts ...Option) (*GetLogsResponse, error) {
	return c.GetLogsWithContext(context.Background(), r, opts...)
}

/*
GetLogs Return the latest log entries.

Return the latest log entries.

Request can be constructed by NewApiGetLogsRequest with parameters below.

	@param offset int32 - First entry to retrieve (zero-based). Log entries are sorted by decreasing date, therefore 0 designates the most recent log entry.
	@param length int32 - Maximum number of entries to retrieve. The maximum allowed value is 1000.
	@param indexName string - Index for which log entries should be retrieved. When omitted, log entries are retrieved across all indices.
	@param type_ LogType - Type of log entries to retrieve. When omitted, all log entries are retrieved.
	@return GetLogsResponse
*/
func (c *APIClient) GetLogsWithContext(ctx context.Context, r ApiGetLogsRequest, opts ...Option) (*GetLogsResponse, error) {
	var (
		postBody    any
		returnValue *GetLogsResponse
	)

	requestPath := "/1/logs"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !isNilorEmpty(r.length) {
		queryParams.Set("length", parameterToString(r.length))
	}
	if !isNilorEmpty(r.indexName) {
		queryParams.Set("indexName", parameterToString(r.indexName))
	}
	if !isNilorEmpty(r.type_) {
		queryParams.Set("type", parameterToString(*r.type_))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["attributesToRetrieve"]; ok {
		err = json.Unmarshal(v, &r.attributesToRetrieve)
		if err != nil {
			err = json.Unmarshal(b, &r.attributesToRetrieve)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetObjectRequest represents the request with all the parameters for the API call.
type ApiGetObjectRequest struct {
	indexName            string
	objectID             string
	attributesToRetrieve []string
}

// NewApiGetObjectRequest creates an instance of the ApiGetObjectRequest to be used for the API call.
func (c *APIClient) NewApiGetObjectRequest(indexName string, objectID string) ApiGetObjectRequest {
	return ApiGetObjectRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

// WithAttributesToRetrieve adds the attributesToRetrieve to the ApiGetObjectRequest and returns the request for chaining.
func (r ApiGetObjectRequest) WithAttributesToRetrieve(attributesToRetrieve []string) ApiGetObjectRequest {
	r.attributesToRetrieve = attributesToRetrieve
	return r
}

/*
GetObject Retrieve an object. Wraps GetObjectWithContext using context.Background.

Retrieve one object from the index.

Request can be constructed by NewApiGetObjectRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param attributesToRetrieve []string - List of attributes to retrieve. If not specified, all retrievable attributes are returned.
	@return map[string]string
*/
func (c *APIClient) GetObject(r ApiGetObjectRequest, opts ...Option) (map[string]string, error) {
	return c.GetObjectWithContext(context.Background(), r, opts...)
}

/*
GetObject Retrieve an object.

Retrieve one object from the index.

Request can be constructed by NewApiGetObjectRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param attributesToRetrieve []string - List of attributes to retrieve. If not specified, all retrievable attributes are returned.
	@return map[string]string
*/
func (c *APIClient) GetObjectWithContext(ctx context.Context, r ApiGetObjectRequest, opts ...Option) (map[string]string, error) {
	var (
		postBody    any
		returnValue map[string]string
	)

	requestPath := "/1/indexes/{indexName}/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.attributesToRetrieve) {
		queryParams.Set("attributesToRetrieve", parameterToString(r.attributesToRetrieve))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetObjectsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["getObjectsParams"]; ok {
		err = json.Unmarshal(v, &r.getObjectsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.getObjectsParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.getObjectsParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiGetObjectsRequest represents the request with all the parameters for the API call.
type ApiGetObjectsRequest struct {
	getObjectsParams *GetObjectsParams
}

// NewApiGetObjectsRequest creates an instance of the ApiGetObjectsRequest to be used for the API call.
func (c *APIClient) NewApiGetObjectsRequest(getObjectsParams *GetObjectsParams) ApiGetObjectsRequest {
	return ApiGetObjectsRequest{
		getObjectsParams: getObjectsParams,
	}
}

/*
GetObjects Retrieve one or more objects. Wraps GetObjectsWithContext using context.Background.

Retrieve one or more objects, potentially from different indices, in a single API call.

Request can be constructed by NewApiGetObjectsRequest with parameters below.

	@param getObjectsParams GetObjectsParams - The Algolia object.
	@return GetObjectsResponse
*/
func (c *APIClient) GetObjects(r ApiGetObjectsRequest, opts ...Option) (*GetObjectsResponse, error) {
	return c.GetObjectsWithContext(context.Background(), r, opts...)
}

/*
GetObjects Retrieve one or more objects.

Retrieve one or more objects, potentially from different indices, in a single API call.

Request can be constructed by NewApiGetObjectsRequest with parameters below.

	@param getObjectsParams GetObjectsParams - The Algolia object.
	@return GetObjectsResponse
*/
func (c *APIClient) GetObjectsWithContext(ctx context.Context, r ApiGetObjectsRequest, opts ...Option) (*GetObjectsResponse, error) {
	var (
		postBody    any
		returnValue *GetObjectsResponse
	)

	requestPath := "/1/indexes/*/objects"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.getObjectsParams == nil {
		return returnValue, reportError("getObjectsParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.getObjectsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetRuleRequest represents the request with all the parameters for the API call.
type ApiGetRuleRequest struct {
	indexName string
	objectID  string
}

// NewApiGetRuleRequest creates an instance of the ApiGetRuleRequest to be used for the API call.
func (c *APIClient) NewApiGetRuleRequest(indexName string, objectID string) ApiGetRuleRequest {
	return ApiGetRuleRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

/*
GetRule Get a rule. Wraps GetRuleWithContext using context.Background.

Retrieve the Rule with the specified objectID.

Request can be constructed by NewApiGetRuleRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@return Rule
*/
func (c *APIClient) GetRule(r ApiGetRuleRequest, opts ...Option) (*Rule, error) {
	return c.GetRuleWithContext(context.Background(), r, opts...)
}

/*
GetRule Get a rule.

Retrieve the Rule with the specified objectID.

Request can be constructed by NewApiGetRuleRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@return Rule
*/
func (c *APIClient) GetRuleWithContext(ctx context.Context, r ApiGetRuleRequest, opts ...Option) (*Rule, error) {
	var (
		postBody    any
		returnValue *Rule
	)

	requestPath := "/1/indexes/{indexName}/rules/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSettingsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetSettingsRequest represents the request with all the parameters for the API call.
type ApiGetSettingsRequest struct {
	indexName string
}

// NewApiGetSettingsRequest creates an instance of the ApiGetSettingsRequest to be used for the API call.
func (c *APIClient) NewApiGetSettingsRequest(indexName string) ApiGetSettingsRequest {
	return ApiGetSettingsRequest{
		indexName: indexName,
	}
}

/*
GetSettings Retrieve settings of an index. Wraps GetSettingsWithContext using context.Background.

Retrieve settings of an index.

Request can be constructed by NewApiGetSettingsRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@return IndexSettings
*/
func (c *APIClient) GetSettings(r ApiGetSettingsRequest, opts ...Option) (*IndexSettings, error) {
	return c.GetSettingsWithContext(context.Background(), r, opts...)
}

/*
GetSettings Retrieve settings of an index.

Retrieve settings of an index.

Request can be constructed by NewApiGetSettingsRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@return IndexSettings
*/
func (c *APIClient) GetSettingsWithContext(ctx context.Context, r ApiGetSettingsRequest, opts ...Option) (*IndexSettings, error) {
	var (
		postBody    any
		returnValue *IndexSettings
	)

	requestPath := "/1/indexes/{indexName}/settings"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetSources List all allowed sources. Wraps GetSourcesWithContext using context.Background.

List all allowed sources.

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@return []Source
*/
func (c *APIClient) GetSources(opts ...Option) ([]Source, error) {
	return c.GetSourcesWithContext(context.Background(), opts...)
}

/*
GetSources List all allowed sources.

List all allowed sources.

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@return []Source
*/
func (c *APIClient) GetSourcesWithContext(ctx context.Context, opts ...Option) ([]Source, error) {
	var (
		postBody    any
		returnValue []Source
	)

	requestPath := "/1/security/sources"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSynonymRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetSynonymRequest represents the request with all the parameters for the API call.
type ApiGetSynonymRequest struct {
	indexName string
	objectID  string
}

// NewApiGetSynonymRequest creates an instance of the ApiGetSynonymRequest to be used for the API call.
func (c *APIClient) NewApiGetSynonymRequest(indexName string, objectID string) ApiGetSynonymRequest {
	return ApiGetSynonymRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

/*
GetSynonym Get synonym. Wraps GetSynonymWithContext using context.Background.

Fetch a synonym object identified by its objectID.

Request can be constructed by NewApiGetSynonymRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@return SynonymHit
*/
func (c *APIClient) GetSynonym(r ApiGetSynonymRequest, opts ...Option) (*SynonymHit, error) {
	return c.GetSynonymWithContext(context.Background(), r, opts...)
}

/*
GetSynonym Get synonym.

Fetch a synonym object identified by its objectID.

Request can be constructed by NewApiGetSynonymRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@return SynonymHit
*/
func (c *APIClient) GetSynonymWithContext(ctx context.Context, r ApiGetSynonymRequest, opts ...Option) (*SynonymHit, error) {
	var (
		postBody    any
		returnValue *SynonymHit
	)

	requestPath := "/1/indexes/{indexName}/synonyms/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetTaskRequest represents the request with all the parameters for the API call.
type ApiGetTaskRequest struct {
	indexName string
	taskID    int64
}

// NewApiGetTaskRequest creates an instance of the ApiGetTaskRequest to be used for the API call.
func (c *APIClient) NewApiGetTaskRequest(indexName string, taskID int64) ApiGetTaskRequest {
	return ApiGetTaskRequest{
		indexName: indexName,
		taskID:    taskID,
	}
}

/*
GetTask Check the status of a task. Wraps GetTaskWithContext using context.Background.

Check the current status of a given task.

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param taskID int64 - Unique identifier of an task. Numeric value (up to 64bits).
	@return GetTaskResponse
*/
func (c *APIClient) GetTask(r ApiGetTaskRequest, opts ...Option) (*GetTaskResponse, error) {
	return c.GetTaskWithContext(context.Background(), r, opts...)
}

/*
GetTask Check the status of a task.

Check the current status of a given task.

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param taskID int64 - Unique identifier of an task. Numeric value (up to 64bits).
	@return GetTaskResponse
*/
func (c *APIClient) GetTaskWithContext(ctx context.Context, r ApiGetTaskRequest, opts ...Option) (*GetTaskResponse, error) {
	var (
		postBody    any
		returnValue *GetTaskResponse
	)

	requestPath := "/1/indexes/{indexName}/task/{taskID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"taskID"+"}", url.PathEscape(parameterToString(r.taskID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetTopUserIds Get top userID. Wraps GetTopUserIdsWithContext using context.Background.

Get the top 10 userIDs with the highest number of records per cluster.
The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds to propagate to the different clusters.
Upon success, the response is 200 OK and contains the following array of userIDs and clusters.

Request can be constructed by NewApiGetTopUserIdsRequest with parameters below.

	@return GetTopUserIdsResponse
*/
func (c *APIClient) GetTopUserIds(opts ...Option) (*GetTopUserIdsResponse, error) {
	return c.GetTopUserIdsWithContext(context.Background(), opts...)
}

/*
GetTopUserIds Get top userID.

Get the top 10 userIDs with the highest number of records per cluster.
The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds to propagate to the different clusters.
Upon success, the response is 200 OK and contains the following array of userIDs and clusters.

Request can be constructed by NewApiGetTopUserIdsRequest with parameters below.

	@return GetTopUserIdsResponse
*/
func (c *APIClient) GetTopUserIdsWithContext(ctx context.Context, opts ...Option) (*GetTopUserIdsResponse, error) {
	var (
		postBody    any
		returnValue *GetTopUserIdsResponse
	)

	requestPath := "/1/clusters/mapping/top"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetUserIdRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["userID"]; ok {
		err = json.Unmarshal(v, &r.userID)
		if err != nil {
			err = json.Unmarshal(b, &r.userID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetUserIdRequest represents the request with all the parameters for the API call.
type ApiGetUserIdRequest struct {
	userID string
}

// NewApiGetUserIdRequest creates an instance of the ApiGetUserIdRequest to be used for the API call.
func (c *APIClient) NewApiGetUserIdRequest(userID string) ApiGetUserIdRequest {
	return ApiGetUserIdRequest{
		userID: userID,
	}
}

/*
GetUserId Get userID. Wraps GetUserIdWithContext using context.Background.

Returns the userID data stored in the mapping.
The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds to propagate to the different clusters.
Upon success, the response is 200 OK and contains the following userID data.

Request can be constructed by NewApiGetUserIdRequest with parameters below.

	@param userID string - userID to assign.
	@return UserId
*/
func (c *APIClient) GetUserId(r ApiGetUserIdRequest, opts ...Option) (*UserId, error) {
	return c.GetUserIdWithContext(context.Background(), r, opts...)
}

/*
GetUserId Get userID.

Returns the userID data stored in the mapping.
The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds to propagate to the different clusters.
Upon success, the response is 200 OK and contains the following userID data.

Request can be constructed by NewApiGetUserIdRequest with parameters below.

	@param userID string - userID to assign.
	@return UserId
*/
func (c *APIClient) GetUserIdWithContext(ctx context.Context, r ApiGetUserIdRequest, opts ...Option) (*UserId, error) {
	var (
		postBody    any
		returnValue *UserId
	)

	requestPath := "/1/clusters/mapping/{userID}"
	requestPath = strings.Replace(requestPath, "{"+"userID"+"}", url.PathEscape(parameterToString(r.userID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiHasPendingMappingsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["getClusters"]; ok {
		err = json.Unmarshal(v, &r.getClusters)
		if err != nil {
			err = json.Unmarshal(b, &r.getClusters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiHasPendingMappingsRequest represents the request with all the parameters for the API call.
type ApiHasPendingMappingsRequest struct {
	getClusters bool
}

// NewApiHasPendingMappingsRequest creates an instance of the ApiHasPendingMappingsRequest to be used for the API call.
func (c *APIClient) NewApiHasPendingMappingsRequest() ApiHasPendingMappingsRequest {
	return ApiHasPendingMappingsRequest{}
}

// WithGetClusters adds the getClusters to the ApiHasPendingMappingsRequest and returns the request for chaining.
func (r ApiHasPendingMappingsRequest) WithGetClusters(getClusters bool) ApiHasPendingMappingsRequest {
	r.getClusters = getClusters
	return r
}

/*
HasPendingMappings Get migration status. Wraps HasPendingMappingsWithContext using context.Background.

Get the status of your clusters' migrations or user creations.
Creating a large batch of users or migrating your multi-cluster may take quite some time. This method lets you retrieve the status of the migration, so you can know when it's done.
Upon success, the response is 200 OK.
A successful response indicates that the operation has been taken into account, and the userIDs are directly usable.

Request can be constructed by NewApiHasPendingMappingsRequest with parameters below.

	@param getClusters bool - If the clusters pending mapping state should be on the response.
	@return HasPendingMappingsResponse
*/
func (c *APIClient) HasPendingMappings(r ApiHasPendingMappingsRequest, opts ...Option) (*HasPendingMappingsResponse, error) {
	return c.HasPendingMappingsWithContext(context.Background(), r, opts...)
}

/*
HasPendingMappings Get migration status.

Get the status of your clusters' migrations or user creations.
Creating a large batch of users or migrating your multi-cluster may take quite some time. This method lets you retrieve the status of the migration, so you can know when it's done.
Upon success, the response is 200 OK.
A successful response indicates that the operation has been taken into account, and the userIDs are directly usable.

Request can be constructed by NewApiHasPendingMappingsRequest with parameters below.

	@param getClusters bool - If the clusters pending mapping state should be on the response.
	@return HasPendingMappingsResponse
*/
func (c *APIClient) HasPendingMappingsWithContext(ctx context.Context, r ApiHasPendingMappingsRequest, opts ...Option) (*HasPendingMappingsResponse, error) {
	var (
		postBody    any
		returnValue *HasPendingMappingsResponse
	)

	requestPath := "/1/clusters/mapping/pending"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.getClusters) {
		queryParams.Set("getClusters", parameterToString(r.getClusters))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
ListApiKeys List API Keys. Wraps ListApiKeysWithContext using context.Background.

List API keys, along with their associated rights.

Request can be constructed by NewApiListApiKeysRequest with parameters below.

	@return ListApiKeysResponse
*/
func (c *APIClient) ListApiKeys(opts ...Option) (*ListApiKeysResponse, error) {
	return c.ListApiKeysWithContext(context.Background(), opts...)
}

/*
ListApiKeys List API Keys.

List API keys, along with their associated rights.

Request can be constructed by NewApiListApiKeysRequest with parameters below.

	@return ListApiKeysResponse
*/
func (c *APIClient) ListApiKeysWithContext(ctx context.Context, opts ...Option) (*ListApiKeysResponse, error) {
	var (
		postBody    any
		returnValue *ListApiKeysResponse
	)

	requestPath := "/1/keys"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
ListClusters List clusters. Wraps ListClustersWithContext using context.Background.

List the clusters available in a multi-clusters setup for a single appID.
Upon success, the response is 200 OK and contains the following clusters.

Request can be constructed by NewApiListClustersRequest with parameters below.

	@return ListClustersResponse
*/
func (c *APIClient) ListClusters(opts ...Option) (*ListClustersResponse, error) {
	return c.ListClustersWithContext(context.Background(), opts...)
}

/*
ListClusters List clusters.

List the clusters available in a multi-clusters setup for a single appID.
Upon success, the response is 200 OK and contains the following clusters.

Request can be constructed by NewApiListClustersRequest with parameters below.

	@return ListClustersResponse
*/
func (c *APIClient) ListClustersWithContext(ctx context.Context, opts ...Option) (*ListClustersResponse, error) {
	var (
		postBody    any
		returnValue *ListClustersResponse
	)

	requestPath := "/1/clusters"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListIndicesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiListIndicesRequest represents the request with all the parameters for the API call.
type ApiListIndicesRequest struct {
	page int32
}

// NewApiListIndicesRequest creates an instance of the ApiListIndicesRequest to be used for the API call.
func (c *APIClient) NewApiListIndicesRequest() ApiListIndicesRequest {
	return ApiListIndicesRequest{}
}

// WithPage adds the page to the ApiListIndicesRequest and returns the request for chaining.
func (r ApiListIndicesRequest) WithPage(page int32) ApiListIndicesRequest {
	r.page = page
	return r
}

/*
ListIndices List existing indexes. Wraps ListIndicesWithContext using context.Background.

List existing indexes from an application.

Request can be constructed by NewApiListIndicesRequest with parameters below.

	@param page int32 - Requested page (zero-based). When specified, will retrieve a specific page; the page size is implicitly set to 100. When null, will retrieve all indices (no pagination).
	@return ListIndicesResponse
*/
func (c *APIClient) ListIndices(r ApiListIndicesRequest, opts ...Option) (*ListIndicesResponse, error) {
	return c.ListIndicesWithContext(context.Background(), r, opts...)
}

/*
ListIndices List existing indexes.

List existing indexes from an application.

Request can be constructed by NewApiListIndicesRequest with parameters below.

	@param page int32 - Requested page (zero-based). When specified, will retrieve a specific page; the page size is implicitly set to 100. When null, will retrieve all indices (no pagination).
	@return ListIndicesResponse
*/
func (c *APIClient) ListIndicesWithContext(ctx context.Context, r ApiListIndicesRequest, opts ...Option) (*ListIndicesResponse, error) {
	var (
		postBody    any
		returnValue *ListIndicesResponse
	)

	requestPath := "/1/indexes"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.page) {
		queryParams.Set("page", parameterToString(r.page))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListUserIdsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["hitsPerPage"]; ok {
		err = json.Unmarshal(v, &r.hitsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.hitsPerPage)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiListUserIdsRequest represents the request with all the parameters for the API call.
type ApiListUserIdsRequest struct {
	page        int32
	hitsPerPage int32
}

// NewApiListUserIdsRequest creates an instance of the ApiListUserIdsRequest to be used for the API call.
func (c *APIClient) NewApiListUserIdsRequest() ApiListUserIdsRequest {
	return ApiListUserIdsRequest{}
}

// WithPage adds the page to the ApiListUserIdsRequest and returns the request for chaining.
func (r ApiListUserIdsRequest) WithPage(page int32) ApiListUserIdsRequest {
	r.page = page
	return r
}

// WithHitsPerPage adds the hitsPerPage to the ApiListUserIdsRequest and returns the request for chaining.
func (r ApiListUserIdsRequest) WithHitsPerPage(hitsPerPage int32) ApiListUserIdsRequest {
	r.hitsPerPage = hitsPerPage
	return r
}

/*
ListUserIds List userIDs. Wraps ListUserIdsWithContext using context.Background.

List the userIDs assigned to a multi-clusters appID.
The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds to propagate to the different clusters.
Upon success, the response is 200 OK and contains the following userIDs data.

Request can be constructed by NewApiListUserIdsRequest with parameters below.

	@param page int32 - Requested page (zero-based). When specified, will retrieve a specific page; the page size is implicitly set to 100. When null, will retrieve all indices (no pagination).
	@param hitsPerPage int32 - Maximum number of objects to retrieve.
	@return ListUserIdsResponse
*/
func (c *APIClient) ListUserIds(r ApiListUserIdsRequest, opts ...Option) (*ListUserIdsResponse, error) {
	return c.ListUserIdsWithContext(context.Background(), r, opts...)
}

/*
ListUserIds List userIDs.

List the userIDs assigned to a multi-clusters appID.
The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds to propagate to the different clusters.
Upon success, the response is 200 OK and contains the following userIDs data.

Request can be constructed by NewApiListUserIdsRequest with parameters below.

	@param page int32 - Requested page (zero-based). When specified, will retrieve a specific page; the page size is implicitly set to 100. When null, will retrieve all indices (no pagination).
	@param hitsPerPage int32 - Maximum number of objects to retrieve.
	@return ListUserIdsResponse
*/
func (c *APIClient) ListUserIdsWithContext(ctx context.Context, r ApiListUserIdsRequest, opts ...Option) (*ListUserIdsResponse, error) {
	var (
		postBody    any
		returnValue *ListUserIdsResponse
	)

	requestPath := "/1/clusters/mapping"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.page) {
		queryParams.Set("page", parameterToString(r.page))
	}
	if !isNilorEmpty(r.hitsPerPage) {
		queryParams.Set("hitsPerPage", parameterToString(r.hitsPerPage))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiMultipleBatchRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["batchParams"]; ok {
		err = json.Unmarshal(v, &r.batchParams)
		if err != nil {
			err = json.Unmarshal(b, &r.batchParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.batchParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiMultipleBatchRequest represents the request with all the parameters for the API call.
type ApiMultipleBatchRequest struct {
	batchParams *BatchParams
}

// NewApiMultipleBatchRequest creates an instance of the ApiMultipleBatchRequest to be used for the API call.
func (c *APIClient) NewApiMultipleBatchRequest(batchParams *BatchParams) ApiMultipleBatchRequest {
	return ApiMultipleBatchRequest{
		batchParams: batchParams,
	}
}

/*
MultipleBatch Batch operations to many indices. Wraps MultipleBatchWithContext using context.Background.

Perform multiple write operations, potentially targeting multiple indices, in a single API call.

Request can be constructed by NewApiMultipleBatchRequest with parameters below.

	@param batchParams BatchParams
	@return MultipleBatchResponse
*/
func (c *APIClient) MultipleBatch(r ApiMultipleBatchRequest, opts ...Option) (*MultipleBatchResponse, error) {
	return c.MultipleBatchWithContext(context.Background(), r, opts...)
}

/*
MultipleBatch Batch operations to many indices.

Perform multiple write operations, potentially targeting multiple indices, in a single API call.

Request can be constructed by NewApiMultipleBatchRequest with parameters below.

	@param batchParams BatchParams
	@return MultipleBatchResponse
*/
func (c *APIClient) MultipleBatchWithContext(ctx context.Context, r ApiMultipleBatchRequest, opts ...Option) (*MultipleBatchResponse, error) {
	var (
		postBody    any
		returnValue *MultipleBatchResponse
	)

	requestPath := "/1/indexes/*/batch"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.batchParams == nil {
		return returnValue, reportError("batchParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.batchParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiOperationIndexRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["operationIndexParams"]; ok {
		err = json.Unmarshal(v, &r.operationIndexParams)
		if err != nil {
			err = json.Unmarshal(b, &r.operationIndexParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.operationIndexParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiOperationIndexRequest represents the request with all the parameters for the API call.
type ApiOperationIndexRequest struct {
	indexName            string
	operationIndexParams *OperationIndexParams
}

// NewApiOperationIndexRequest creates an instance of the ApiOperationIndexRequest to be used for the API call.
func (c *APIClient) NewApiOperationIndexRequest(indexName string, operationIndexParams *OperationIndexParams) ApiOperationIndexRequest {
	return ApiOperationIndexRequest{
		indexName:            indexName,
		operationIndexParams: operationIndexParams,
	}
}

/*
OperationIndex Copy/move index. Wraps OperationIndexWithContext using context.Background.

Performs a copy or a move operation on a index.

Request can be constructed by NewApiOperationIndexRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param operationIndexParams OperationIndexParams
	@return UpdatedAtResponse
*/
func (c *APIClient) OperationIndex(r ApiOperationIndexRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.OperationIndexWithContext(context.Background(), r, opts...)
}

/*
OperationIndex Copy/move index.

Performs a copy or a move operation on a index.

Request can be constructed by NewApiOperationIndexRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param operationIndexParams OperationIndexParams
	@return UpdatedAtResponse
*/
func (c *APIClient) OperationIndexWithContext(ctx context.Context, r ApiOperationIndexRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/operation"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.operationIndexParams == nil {
		return returnValue, reportError("operationIndexParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.operationIndexParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPartialUpdateObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["attributesToUpdate"]; ok {
		err = json.Unmarshal(v, &r.attributesToUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.attributesToUpdate)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.attributesToUpdate)
		if err != nil {
			return err
		}
	}
	if v, ok := req["createIfNotExists"]; ok {
		err = json.Unmarshal(v, &r.createIfNotExists)
		if err != nil {
			err = json.Unmarshal(b, &r.createIfNotExists)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiPartialUpdateObjectRequest represents the request with all the parameters for the API call.
type ApiPartialUpdateObjectRequest struct {
	indexName          string
	objectID           string
	attributesToUpdate *map[string]AttributeToUpdate
	createIfNotExists  bool
}

// NewApiPartialUpdateObjectRequest creates an instance of the ApiPartialUpdateObjectRequest to be used for the API call.
func (c *APIClient) NewApiPartialUpdateObjectRequest(indexName string, objectID string, attributesToUpdate *map[string]AttributeToUpdate) ApiPartialUpdateObjectRequest {
	return ApiPartialUpdateObjectRequest{
		indexName:          indexName,
		objectID:           objectID,
		attributesToUpdate: attributesToUpdate,
	}
}

// WithCreateIfNotExists adds the createIfNotExists to the ApiPartialUpdateObjectRequest and returns the request for chaining.
func (r ApiPartialUpdateObjectRequest) WithCreateIfNotExists(createIfNotExists bool) ApiPartialUpdateObjectRequest {
	r.createIfNotExists = createIfNotExists
	return r
}

/*
PartialUpdateObject Partially update an object. Wraps PartialUpdateObjectWithContext using context.Background.

Update one or more attributes of an existing object.
This method lets you update only a part of an existing object, either by adding new attributes or updating existing ones.
You can partially update several objects in a single method call.
If the index targeted by this operation doesn't exist yet, it's automatically created.

Request can be constructed by NewApiPartialUpdateObjectRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param attributesToUpdate map[string]AttributeToUpdate - Map of attribute(s) to update.
	@param createIfNotExists bool - Creates the record if it does not exist yet.
	@return UpdatedAtWithObjectIdResponse
*/
func (c *APIClient) PartialUpdateObject(r ApiPartialUpdateObjectRequest, opts ...Option) (*UpdatedAtWithObjectIdResponse, error) {
	return c.PartialUpdateObjectWithContext(context.Background(), r, opts...)
}

/*
PartialUpdateObject Partially update an object.

Update one or more attributes of an existing object.
This method lets you update only a part of an existing object, either by adding new attributes or updating existing ones.
You can partially update several objects in a single method call.
If the index targeted by this operation doesn't exist yet, it's automatically created.

Request can be constructed by NewApiPartialUpdateObjectRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param attributesToUpdate map[string]AttributeToUpdate - Map of attribute(s) to update.
	@param createIfNotExists bool - Creates the record if it does not exist yet.
	@return UpdatedAtWithObjectIdResponse
*/
func (c *APIClient) PartialUpdateObjectWithContext(ctx context.Context, r ApiPartialUpdateObjectRequest, opts ...Option) (*UpdatedAtWithObjectIdResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtWithObjectIdResponse
	)

	requestPath := "/1/indexes/{indexName}/{objectID}/partial"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.attributesToUpdate == nil {
		return returnValue, reportError("attributesToUpdate is required and must be specified")
	}

	if !isNilorEmpty(r.createIfNotExists) {
		queryParams.Set("createIfNotExists", parameterToString(r.createIfNotExists))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.attributesToUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiPostRequest represents the request with all the parameters for the API call.
type ApiPostRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiPostRequest creates an instance of the ApiPostRequest to be used for the API call.
func (c *APIClient) NewApiPostRequest(path string) ApiPostRequest {
	return ApiPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiPostRequest and returns the request for chaining.
func (r ApiPostRequest) WithParameters(parameters map[string]interface{}) ApiPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiPostRequest and returns the request for chaining.
func (r ApiPostRequest) WithBody(body map[string]interface{}) ApiPostRequest {
	r.body = body
	return r
}

/*
Post Send requests to the Algolia REST API. Wraps PostWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPostRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@param body map[string]interface{} - The parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) Post(r ApiPostRequest, opts ...Option) (map[string]interface{}, error) {
	return c.PostWithContext(context.Background(), r, opts...)
}

/*
Post Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPostRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@param body map[string]interface{} - The parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) PostWithContext(ctx context.Context, r ApiPostRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiPutRequest represents the request with all the parameters for the API call.
type ApiPutRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiPutRequest creates an instance of the ApiPutRequest to be used for the API call.
func (c *APIClient) NewApiPutRequest(path string) ApiPutRequest {
	return ApiPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiPutRequest and returns the request for chaining.
func (r ApiPutRequest) WithParameters(parameters map[string]interface{}) ApiPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiPutRequest and returns the request for chaining.
func (r ApiPutRequest) WithBody(body map[string]interface{}) ApiPutRequest {
	r.body = body
	return r
}

/*
Put Send requests to the Algolia REST API. Wraps PutWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPutRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@param body map[string]interface{} - The parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) Put(r ApiPutRequest, opts ...Option) (map[string]interface{}, error) {
	return c.PutWithContext(context.Background(), r, opts...)
}

/*
Put Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPutRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@param body map[string]interface{} - The parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) PutWithContext(ctx context.Context, r ApiPutRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRemoveUserIdRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["userID"]; ok {
		err = json.Unmarshal(v, &r.userID)
		if err != nil {
			err = json.Unmarshal(b, &r.userID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiRemoveUserIdRequest represents the request with all the parameters for the API call.
type ApiRemoveUserIdRequest struct {
	userID string
}

// NewApiRemoveUserIdRequest creates an instance of the ApiRemoveUserIdRequest to be used for the API call.
func (c *APIClient) NewApiRemoveUserIdRequest(userID string) ApiRemoveUserIdRequest {
	return ApiRemoveUserIdRequest{
		userID: userID,
	}
}

/*
RemoveUserId Remove userID. Wraps RemoveUserIdWithContext using context.Background.

Remove a userID and its associated data from the multi-clusters.
Upon success, the response is 200 OK and a task is created to remove the userID data and mapping.

Request can be constructed by NewApiRemoveUserIdRequest with parameters below.

	@param userID string - userID to assign.
	@return RemoveUserIdResponse
*/
func (c *APIClient) RemoveUserId(r ApiRemoveUserIdRequest, opts ...Option) (*RemoveUserIdResponse, error) {
	return c.RemoveUserIdWithContext(context.Background(), r, opts...)
}

/*
RemoveUserId Remove userID.

Remove a userID and its associated data from the multi-clusters.
Upon success, the response is 200 OK and a task is created to remove the userID data and mapping.

Request can be constructed by NewApiRemoveUserIdRequest with parameters below.

	@param userID string - userID to assign.
	@return RemoveUserIdResponse
*/
func (c *APIClient) RemoveUserIdWithContext(ctx context.Context, r ApiRemoveUserIdRequest, opts ...Option) (*RemoveUserIdResponse, error) {
	var (
		postBody    any
		returnValue *RemoveUserIdResponse
	)

	requestPath := "/1/clusters/mapping/{userID}"
	requestPath = strings.Replace(requestPath, "{"+"userID"+"}", url.PathEscape(parameterToString(r.userID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiReplaceSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["source"]; ok {
		err = json.Unmarshal(v, &r.source)
		if err != nil {
			err = json.Unmarshal(b, &r.source)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.source)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiReplaceSourcesRequest represents the request with all the parameters for the API call.
type ApiReplaceSourcesRequest struct {
	source []Source
}

// NewApiReplaceSourcesRequest creates an instance of the ApiReplaceSourcesRequest to be used for the API call.
func (c *APIClient) NewApiReplaceSourcesRequest(source []Source) ApiReplaceSourcesRequest {
	return ApiReplaceSourcesRequest{
		source: source,
	}
}

/*
ReplaceSources Replace all allowed sources. Wraps ReplaceSourcesWithContext using context.Background.

Replace all allowed sources.

Request can be constructed by NewApiReplaceSourcesRequest with parameters below.

	@param source []Source - The sources to allow.
	@return ReplaceSourceResponse
*/
func (c *APIClient) ReplaceSources(r ApiReplaceSourcesRequest, opts ...Option) (*ReplaceSourceResponse, error) {
	return c.ReplaceSourcesWithContext(context.Background(), r, opts...)
}

/*
ReplaceSources Replace all allowed sources.

Replace all allowed sources.

Request can be constructed by NewApiReplaceSourcesRequest with parameters below.

	@param source []Source - The sources to allow.
	@return ReplaceSourceResponse
*/
func (c *APIClient) ReplaceSourcesWithContext(ctx context.Context, r ApiReplaceSourcesRequest, opts ...Option) (*ReplaceSourceResponse, error) {
	var (
		postBody    any
		returnValue *ReplaceSourceResponse
	)

	requestPath := "/1/security/sources"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.source == nil {
		return returnValue, reportError("source is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.source
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRestoreApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["key"]; ok {
		err = json.Unmarshal(v, &r.key)
		if err != nil {
			err = json.Unmarshal(b, &r.key)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiRestoreApiKeyRequest represents the request with all the parameters for the API call.
type ApiRestoreApiKeyRequest struct {
	key string
}

// NewApiRestoreApiKeyRequest creates an instance of the ApiRestoreApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiRestoreApiKeyRequest(key string) ApiRestoreApiKeyRequest {
	return ApiRestoreApiKeyRequest{
		key: key,
	}
}

/*
RestoreApiKey Restore an API key. Wraps RestoreApiKeyWithContext using context.Background.

Restore a deleted API key, along with its associated rights.

Request can be constructed by NewApiRestoreApiKeyRequest with parameters below.

	@param key string - API Key string.
	@return AddApiKeyResponse
*/
func (c *APIClient) RestoreApiKey(r ApiRestoreApiKeyRequest, opts ...Option) (*AddApiKeyResponse, error) {
	return c.RestoreApiKeyWithContext(context.Background(), r, opts...)
}

/*
RestoreApiKey Restore an API key.

Restore a deleted API key, along with its associated rights.

Request can be constructed by NewApiRestoreApiKeyRequest with parameters below.

	@param key string - API Key string.
	@return AddApiKeyResponse
*/
func (c *APIClient) RestoreApiKeyWithContext(ctx context.Context, r ApiRestoreApiKeyRequest, opts ...Option) (*AddApiKeyResponse, error) {
	var (
		postBody    any
		returnValue *AddApiKeyResponse
	)

	requestPath := "/1/keys/{key}/restore"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(parameterToString(r.key)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.body)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSaveObjectRequest represents the request with all the parameters for the API call.
type ApiSaveObjectRequest struct {
	indexName string
	body      map[string]interface{}
}

// NewApiSaveObjectRequest creates an instance of the ApiSaveObjectRequest to be used for the API call.
func (c *APIClient) NewApiSaveObjectRequest(indexName string, body map[string]interface{}) ApiSaveObjectRequest {
	return ApiSaveObjectRequest{
		indexName: indexName,
		body:      body,
	}
}

/*
SaveObject Add an object to the index. Wraps SaveObjectWithContext using context.Background.

Add an object to the index, automatically assigning it an object ID.

Request can be constructed by NewApiSaveObjectRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param body map[string]interface{} - The Algolia record.
	@return SaveObjectResponse
*/
func (c *APIClient) SaveObject(r ApiSaveObjectRequest, opts ...Option) (*SaveObjectResponse, error) {
	return c.SaveObjectWithContext(context.Background(), r, opts...)
}

/*
SaveObject Add an object to the index.

Add an object to the index, automatically assigning it an object ID.

Request can be constructed by NewApiSaveObjectRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param body map[string]interface{} - The Algolia record.
	@return SaveObjectResponse
*/
func (c *APIClient) SaveObjectWithContext(ctx context.Context, r ApiSaveObjectRequest, opts ...Option) (*SaveObjectResponse, error) {
	var (
		postBody    any
		returnValue *SaveObjectResponse
	)

	requestPath := "/1/indexes/{indexName}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.body
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["rule"]; ok {
		err = json.Unmarshal(v, &r.rule)
		if err != nil {
			err = json.Unmarshal(b, &r.rule)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.rule)
		if err != nil {
			return err
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSaveRuleRequest represents the request with all the parameters for the API call.
type ApiSaveRuleRequest struct {
	indexName         string
	objectID          string
	rule              *Rule
	forwardToReplicas bool
}

// NewApiSaveRuleRequest creates an instance of the ApiSaveRuleRequest to be used for the API call.
func (c *APIClient) NewApiSaveRuleRequest(indexName string, objectID string, rule *Rule) ApiSaveRuleRequest {
	return ApiSaveRuleRequest{
		indexName: indexName,
		objectID:  objectID,
		rule:      rule,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSaveRuleRequest and returns the request for chaining.
func (r ApiSaveRuleRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSaveRuleRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
SaveRule Save/Update a rule. Wraps SaveRuleWithContext using context.Background.

Create or update the Rule with the specified objectID.

Request can be constructed by NewApiSaveRuleRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param rule Rule
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return UpdatedRuleResponse
*/
func (c *APIClient) SaveRule(r ApiSaveRuleRequest, opts ...Option) (*UpdatedRuleResponse, error) {
	return c.SaveRuleWithContext(context.Background(), r, opts...)
}

/*
SaveRule Save/Update a rule.

Create or update the Rule with the specified objectID.

Request can be constructed by NewApiSaveRuleRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param rule Rule
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return UpdatedRuleResponse
*/
func (c *APIClient) SaveRuleWithContext(ctx context.Context, r ApiSaveRuleRequest, opts ...Option) (*UpdatedRuleResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedRuleResponse
	)

	requestPath := "/1/indexes/{indexName}/rules/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.rule == nil {
		return returnValue, reportError("rule is required and must be specified")
	}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.rule
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveRulesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["rules"]; ok {
		err = json.Unmarshal(v, &r.rules)
		if err != nil {
			err = json.Unmarshal(b, &r.rules)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.rules)
		if err != nil {
			return err
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["clearExistingRules"]; ok {
		err = json.Unmarshal(v, &r.clearExistingRules)
		if err != nil {
			err = json.Unmarshal(b, &r.clearExistingRules)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSaveRulesRequest represents the request with all the parameters for the API call.
type ApiSaveRulesRequest struct {
	indexName          string
	rules              []Rule
	forwardToReplicas  bool
	clearExistingRules bool
}

// NewApiSaveRulesRequest creates an instance of the ApiSaveRulesRequest to be used for the API call.
func (c *APIClient) NewApiSaveRulesRequest(indexName string, rules []Rule) ApiSaveRulesRequest {
	return ApiSaveRulesRequest{
		indexName: indexName,
		rules:     rules,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSaveRulesRequest and returns the request for chaining.
func (r ApiSaveRulesRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSaveRulesRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

// WithClearExistingRules adds the clearExistingRules to the ApiSaveRulesRequest and returns the request for chaining.
func (r ApiSaveRulesRequest) WithClearExistingRules(clearExistingRules bool) ApiSaveRulesRequest {
	r.clearExistingRules = clearExistingRules
	return r
}

/*
SaveRules Save a batch of rules. Wraps SaveRulesWithContext using context.Background.

Create/update multiple rules objects at once.

Request can be constructed by NewApiSaveRulesRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param rules []Rule
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@param clearExistingRules bool - When true, existing Rules are cleared before adding this batch. When false, existing Rules are kept.
	@return UpdatedAtResponse
*/
func (c *APIClient) SaveRules(r ApiSaveRulesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SaveRulesWithContext(context.Background(), r, opts...)
}

/*
SaveRules Save a batch of rules.

Create/update multiple rules objects at once.

Request can be constructed by NewApiSaveRulesRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param rules []Rule
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@param clearExistingRules bool - When true, existing Rules are cleared before adding this batch. When false, existing Rules are kept.
	@return UpdatedAtResponse
*/
func (c *APIClient) SaveRulesWithContext(ctx context.Context, r ApiSaveRulesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/rules/batch"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.rules == nil {
		return returnValue, reportError("rules is required and must be specified")
	}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}
	if !isNilorEmpty(r.clearExistingRules) {
		queryParams.Set("clearExistingRules", parameterToString(r.clearExistingRules))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.rules
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveSynonymRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["synonymHit"]; ok {
		err = json.Unmarshal(v, &r.synonymHit)
		if err != nil {
			err = json.Unmarshal(b, &r.synonymHit)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.synonymHit)
		if err != nil {
			return err
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSaveSynonymRequest represents the request with all the parameters for the API call.
type ApiSaveSynonymRequest struct {
	indexName         string
	objectID          string
	synonymHit        *SynonymHit
	forwardToReplicas bool
}

// NewApiSaveSynonymRequest creates an instance of the ApiSaveSynonymRequest to be used for the API call.
func (c *APIClient) NewApiSaveSynonymRequest(indexName string, objectID string, synonymHit *SynonymHit) ApiSaveSynonymRequest {
	return ApiSaveSynonymRequest{
		indexName:  indexName,
		objectID:   objectID,
		synonymHit: synonymHit,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSaveSynonymRequest and returns the request for chaining.
func (r ApiSaveSynonymRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSaveSynonymRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
SaveSynonym Save synonym. Wraps SaveSynonymWithContext using context.Background.

Create a new synonym object or update the existing synonym object with the given object ID.

Request can be constructed by NewApiSaveSynonymRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param synonymHit SynonymHit
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return SaveSynonymResponse
*/
func (c *APIClient) SaveSynonym(r ApiSaveSynonymRequest, opts ...Option) (*SaveSynonymResponse, error) {
	return c.SaveSynonymWithContext(context.Background(), r, opts...)
}

/*
SaveSynonym Save synonym.

Create a new synonym object or update the existing synonym object with the given object ID.

Request can be constructed by NewApiSaveSynonymRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param objectID string - Unique identifier of an object.
	@param synonymHit SynonymHit
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return SaveSynonymResponse
*/
func (c *APIClient) SaveSynonymWithContext(ctx context.Context, r ApiSaveSynonymRequest, opts ...Option) (*SaveSynonymResponse, error) {
	var (
		postBody    any
		returnValue *SaveSynonymResponse
	)

	requestPath := "/1/indexes/{indexName}/synonyms/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.synonymHit == nil {
		return returnValue, reportError("synonymHit is required and must be specified")
	}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.synonymHit
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveSynonymsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["synonymHit"]; ok {
		err = json.Unmarshal(v, &r.synonymHit)
		if err != nil {
			err = json.Unmarshal(b, &r.synonymHit)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.synonymHit)
		if err != nil {
			return err
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["replaceExistingSynonyms"]; ok {
		err = json.Unmarshal(v, &r.replaceExistingSynonyms)
		if err != nil {
			err = json.Unmarshal(b, &r.replaceExistingSynonyms)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSaveSynonymsRequest represents the request with all the parameters for the API call.
type ApiSaveSynonymsRequest struct {
	indexName               string
	synonymHit              []SynonymHit
	forwardToReplicas       bool
	replaceExistingSynonyms bool
}

// NewApiSaveSynonymsRequest creates an instance of the ApiSaveSynonymsRequest to be used for the API call.
func (c *APIClient) NewApiSaveSynonymsRequest(indexName string, synonymHit []SynonymHit) ApiSaveSynonymsRequest {
	return ApiSaveSynonymsRequest{
		indexName:  indexName,
		synonymHit: synonymHit,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSaveSynonymsRequest and returns the request for chaining.
func (r ApiSaveSynonymsRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSaveSynonymsRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

// WithReplaceExistingSynonyms adds the replaceExistingSynonyms to the ApiSaveSynonymsRequest and returns the request for chaining.
func (r ApiSaveSynonymsRequest) WithReplaceExistingSynonyms(replaceExistingSynonyms bool) ApiSaveSynonymsRequest {
	r.replaceExistingSynonyms = replaceExistingSynonyms
	return r
}

/*
SaveSynonyms Save a batch of synonyms. Wraps SaveSynonymsWithContext using context.Background.

Create/update multiple synonym objects at once, potentially replacing the entire list of synonyms if replaceExistingSynonyms is true.

Request can be constructed by NewApiSaveSynonymsRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param synonymHit []SynonymHit
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@param replaceExistingSynonyms bool - Replace all synonyms of the index with the ones sent with this request.
	@return UpdatedAtResponse
*/
func (c *APIClient) SaveSynonyms(r ApiSaveSynonymsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SaveSynonymsWithContext(context.Background(), r, opts...)
}

/*
SaveSynonyms Save a batch of synonyms.

Create/update multiple synonym objects at once, potentially replacing the entire list of synonyms if replaceExistingSynonyms is true.

Request can be constructed by NewApiSaveSynonymsRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param synonymHit []SynonymHit
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@param replaceExistingSynonyms bool - Replace all synonyms of the index with the ones sent with this request.
	@return UpdatedAtResponse
*/
func (c *APIClient) SaveSynonymsWithContext(ctx context.Context, r ApiSaveSynonymsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/synonyms/batch"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.synonymHit == nil {
		return returnValue, reportError("synonymHit is required and must be specified")
	}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}
	if !isNilorEmpty(r.replaceExistingSynonyms) {
		queryParams.Set("replaceExistingSynonyms", parameterToString(r.replaceExistingSynonyms))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.synonymHit
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["searchMethodParams"]; ok {
		err = json.Unmarshal(v, &r.searchMethodParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchMethodParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.searchMethodParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSearchRequest represents the request with all the parameters for the API call.
type ApiSearchRequest struct {
	searchMethodParams *SearchMethodParams
}

// NewApiSearchRequest creates an instance of the ApiSearchRequest to be used for the API call.
func (c *APIClient) NewApiSearchRequest(searchMethodParams *SearchMethodParams) ApiSearchRequest {
	return ApiSearchRequest{
		searchMethodParams: searchMethodParams,
	}
}

/*
Search Search multiple indices. Wraps SearchWithContext using context.Background.

Perform a search operation targeting one or many indices.

Request can be constructed by NewApiSearchRequest with parameters below.

	@param searchMethodParams SearchMethodParams - The `search` requests and strategy.
	@return SearchResponses
*/
func (c *APIClient) Search(r ApiSearchRequest, opts ...Option) (*SearchResponses, error) {
	return c.SearchWithContext(context.Background(), r, opts...)
}

/*
Search Search multiple indices.

Perform a search operation targeting one or many indices.

Request can be constructed by NewApiSearchRequest with parameters below.

	@param searchMethodParams SearchMethodParams - The `search` requests and strategy.
	@return SearchResponses
*/
func (c *APIClient) SearchWithContext(ctx context.Context, r ApiSearchRequest, opts ...Option) (*SearchResponses, error) {
	var (
		postBody    any
		returnValue *SearchResponses
	)

	requestPath := "/1/indexes/*/queries"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.searchMethodParams == nil {
		return returnValue, reportError("searchMethodParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.searchMethodParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchDictionaryEntriesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["dictionaryName"]; ok {
		err = json.Unmarshal(v, &r.dictionaryName)
		if err != nil {
			err = json.Unmarshal(b, &r.dictionaryName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["searchDictionaryEntriesParams"]; ok {
		err = json.Unmarshal(v, &r.searchDictionaryEntriesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchDictionaryEntriesParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.searchDictionaryEntriesParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSearchDictionaryEntriesRequest represents the request with all the parameters for the API call.
type ApiSearchDictionaryEntriesRequest struct {
	dictionaryName                DictionaryType
	searchDictionaryEntriesParams *SearchDictionaryEntriesParams
}

// NewApiSearchDictionaryEntriesRequest creates an instance of the ApiSearchDictionaryEntriesRequest to be used for the API call.
func (c *APIClient) NewApiSearchDictionaryEntriesRequest(dictionaryName DictionaryType, searchDictionaryEntriesParams *SearchDictionaryEntriesParams) ApiSearchDictionaryEntriesRequest {
	return ApiSearchDictionaryEntriesRequest{
		dictionaryName:                dictionaryName,
		searchDictionaryEntriesParams: searchDictionaryEntriesParams,
	}
}

/*
SearchDictionaryEntries Search a dictionary entries. Wraps SearchDictionaryEntriesWithContext using context.Background.

Search the dictionary entries.

Request can be constructed by NewApiSearchDictionaryEntriesRequest with parameters below.

	@param dictionaryName DictionaryType - The dictionary to search in.
	@param searchDictionaryEntriesParams SearchDictionaryEntriesParams
	@return UpdatedAtResponse
*/
func (c *APIClient) SearchDictionaryEntries(r ApiSearchDictionaryEntriesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SearchDictionaryEntriesWithContext(context.Background(), r, opts...)
}

/*
SearchDictionaryEntries Search a dictionary entries.

Search the dictionary entries.

Request can be constructed by NewApiSearchDictionaryEntriesRequest with parameters below.

	@param dictionaryName DictionaryType - The dictionary to search in.
	@param searchDictionaryEntriesParams SearchDictionaryEntriesParams
	@return UpdatedAtResponse
*/
func (c *APIClient) SearchDictionaryEntriesWithContext(ctx context.Context, r ApiSearchDictionaryEntriesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/dictionaries/{dictionaryName}/search"
	requestPath = strings.Replace(requestPath, "{"+"dictionaryName"+"}", url.PathEscape(parameterToString(r.dictionaryName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.searchDictionaryEntriesParams == nil {
		return returnValue, reportError("searchDictionaryEntriesParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.searchDictionaryEntriesParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchForFacetValuesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["facetName"]; ok {
		err = json.Unmarshal(v, &r.facetName)
		if err != nil {
			err = json.Unmarshal(b, &r.facetName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["searchForFacetValuesRequest"]; ok {
		err = json.Unmarshal(v, &r.searchForFacetValuesRequest)
		if err != nil {
			err = json.Unmarshal(b, &r.searchForFacetValuesRequest)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSearchForFacetValuesRequest represents the request with all the parameters for the API call.
type ApiSearchForFacetValuesRequest struct {
	indexName                   string
	facetName                   string
	searchForFacetValuesRequest *SearchForFacetValuesRequest
}

// NewApiSearchForFacetValuesRequest creates an instance of the ApiSearchForFacetValuesRequest to be used for the API call.
func (c *APIClient) NewApiSearchForFacetValuesRequest(indexName string, facetName string) ApiSearchForFacetValuesRequest {
	return ApiSearchForFacetValuesRequest{
		indexName: indexName,
		facetName: facetName,
	}
}

// WithSearchForFacetValuesRequest adds the searchForFacetValuesRequest to the ApiSearchForFacetValuesRequest and returns the request for chaining.
func (r ApiSearchForFacetValuesRequest) WithSearchForFacetValuesRequest(searchForFacetValuesRequest *SearchForFacetValuesRequest) ApiSearchForFacetValuesRequest {
	r.searchForFacetValuesRequest = searchForFacetValuesRequest
	return r
}

/*
SearchForFacetValues Search for values of a given facet. Wraps SearchForFacetValuesWithContext using context.Background.

Search for values of a given facet, optionally restricting the returned values to those contained in objects matching other search criteria.

Request can be constructed by NewApiSearchForFacetValuesRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param facetName string - The facet name.
	@param searchForFacetValuesRequest SearchForFacetValuesRequest
	@return SearchForFacetValuesResponse
*/
func (c *APIClient) SearchForFacetValues(r ApiSearchForFacetValuesRequest, opts ...Option) (*SearchForFacetValuesResponse, error) {
	return c.SearchForFacetValuesWithContext(context.Background(), r, opts...)
}

/*
SearchForFacetValues Search for values of a given facet.

Search for values of a given facet, optionally restricting the returned values to those contained in objects matching other search criteria.

Request can be constructed by NewApiSearchForFacetValuesRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param facetName string - The facet name.
	@param searchForFacetValuesRequest SearchForFacetValuesRequest
	@return SearchForFacetValuesResponse
*/
func (c *APIClient) SearchForFacetValuesWithContext(ctx context.Context, r ApiSearchForFacetValuesRequest, opts ...Option) (*SearchForFacetValuesResponse, error) {
	var (
		postBody    any
		returnValue *SearchForFacetValuesResponse
	)

	requestPath := "/1/indexes/{indexName}/facets/{facetName}/query"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"facetName"+"}", url.PathEscape(parameterToString(r.facetName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.searchForFacetValuesRequest) {
		postBody = "{}"
	} else {
		postBody = r.searchForFacetValuesRequest
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchRulesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["searchRulesParams"]; ok {
		err = json.Unmarshal(v, &r.searchRulesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchRulesParams)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSearchRulesRequest represents the request with all the parameters for the API call.
type ApiSearchRulesRequest struct {
	indexName         string
	searchRulesParams *SearchRulesParams
}

// NewApiSearchRulesRequest creates an instance of the ApiSearchRulesRequest to be used for the API call.
func (c *APIClient) NewApiSearchRulesRequest(indexName string) ApiSearchRulesRequest {
	return ApiSearchRulesRequest{
		indexName: indexName,
	}
}

// WithSearchRulesParams adds the searchRulesParams to the ApiSearchRulesRequest and returns the request for chaining.
func (r ApiSearchRulesRequest) WithSearchRulesParams(searchRulesParams *SearchRulesParams) ApiSearchRulesRequest {
	r.searchRulesParams = searchRulesParams
	return r
}

/*
SearchRules Search for rules. Wraps SearchRulesWithContext using context.Background.

Search for rules matching various criteria.

Request can be constructed by NewApiSearchRulesRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param searchRulesParams SearchRulesParams
	@return SearchRulesResponse
*/
func (c *APIClient) SearchRules(r ApiSearchRulesRequest, opts ...Option) (*SearchRulesResponse, error) {
	return c.SearchRulesWithContext(context.Background(), r, opts...)
}

/*
SearchRules Search for rules.

Search for rules matching various criteria.

Request can be constructed by NewApiSearchRulesRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param searchRulesParams SearchRulesParams
	@return SearchRulesResponse
*/
func (c *APIClient) SearchRulesWithContext(ctx context.Context, r ApiSearchRulesRequest, opts ...Option) (*SearchRulesResponse, error) {
	var (
		postBody    any
		returnValue *SearchRulesResponse
	)

	requestPath := "/1/indexes/{indexName}/rules/search"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.searchRulesParams) {
		postBody = "{}"
	} else {
		postBody = r.searchRulesParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchSingleIndexRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["searchParams"]; ok {
		err = json.Unmarshal(v, &r.searchParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchParams)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSearchSingleIndexRequest represents the request with all the parameters for the API call.
type ApiSearchSingleIndexRequest struct {
	indexName    string
	searchParams *SearchParams
}

// NewApiSearchSingleIndexRequest creates an instance of the ApiSearchSingleIndexRequest to be used for the API call.
func (c *APIClient) NewApiSearchSingleIndexRequest(indexName string) ApiSearchSingleIndexRequest {
	return ApiSearchSingleIndexRequest{
		indexName: indexName,
	}
}

// WithSearchParams adds the searchParams to the ApiSearchSingleIndexRequest and returns the request for chaining.
func (r ApiSearchSingleIndexRequest) WithSearchParams(searchParams *SearchParams) ApiSearchSingleIndexRequest {
	r.searchParams = searchParams
	return r
}

/*
SearchSingleIndex Search in a single index. Wraps SearchSingleIndexWithContext using context.Background.

Perform a search operation targeting one specific index.

Request can be constructed by NewApiSearchSingleIndexRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param searchParams SearchParams
	@return SearchResponse
*/
func (c *APIClient) SearchSingleIndex(r ApiSearchSingleIndexRequest, opts ...Option) (*SearchResponse, error) {
	return c.SearchSingleIndexWithContext(context.Background(), r, opts...)
}

/*
SearchSingleIndex Search in a single index.

Perform a search operation targeting one specific index.

Request can be constructed by NewApiSearchSingleIndexRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param searchParams SearchParams
	@return SearchResponse
*/
func (c *APIClient) SearchSingleIndexWithContext(ctx context.Context, r ApiSearchSingleIndexRequest, opts ...Option) (*SearchResponse, error) {
	var (
		postBody    any
		returnValue *SearchResponse
	)

	requestPath := "/1/indexes/{indexName}/query"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.searchParams) {
		postBody = "{}"
	} else {
		postBody = r.searchParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchSynonymsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["hitsPerPage"]; ok {
		err = json.Unmarshal(v, &r.hitsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.hitsPerPage)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["searchSynonymsParams"]; ok {
		err = json.Unmarshal(v, &r.searchSynonymsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchSynonymsParams)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSearchSynonymsRequest represents the request with all the parameters for the API call.
type ApiSearchSynonymsRequest struct {
	indexName            string
	type_                *SynonymType
	page                 int32
	hitsPerPage          int32
	searchSynonymsParams *SearchSynonymsParams
}

// NewApiSearchSynonymsRequest creates an instance of the ApiSearchSynonymsRequest to be used for the API call.
func (c *APIClient) NewApiSearchSynonymsRequest(indexName string) ApiSearchSynonymsRequest {
	return ApiSearchSynonymsRequest{
		indexName: indexName,
	}
}

// WithType_ adds the type_ to the ApiSearchSynonymsRequest and returns the request for chaining.
func (r ApiSearchSynonymsRequest) WithType_(type_ *SynonymType) ApiSearchSynonymsRequest {
	r.type_ = type_
	return r
}

// WithPage adds the page to the ApiSearchSynonymsRequest and returns the request for chaining.
func (r ApiSearchSynonymsRequest) WithPage(page int32) ApiSearchSynonymsRequest {
	r.page = page
	return r
}

// WithHitsPerPage adds the hitsPerPage to the ApiSearchSynonymsRequest and returns the request for chaining.
func (r ApiSearchSynonymsRequest) WithHitsPerPage(hitsPerPage int32) ApiSearchSynonymsRequest {
	r.hitsPerPage = hitsPerPage
	return r
}

// WithSearchSynonymsParams adds the searchSynonymsParams to the ApiSearchSynonymsRequest and returns the request for chaining.
func (r ApiSearchSynonymsRequest) WithSearchSynonymsParams(searchSynonymsParams *SearchSynonymsParams) ApiSearchSynonymsRequest {
	r.searchSynonymsParams = searchSynonymsParams
	return r
}

/*
SearchSynonyms Search synonyms. Wraps SearchSynonymsWithContext using context.Background.

Search or browse all synonyms, optionally filtering them by type.

Request can be constructed by NewApiSearchSynonymsRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param type_ SynonymType - Only search for specific types of synonyms.
	@param page int32 - Requested page (zero-based). When specified, will retrieve a specific page; the page size is implicitly set to 100. When null, will retrieve all indices (no pagination).
	@param hitsPerPage int32 - Maximum number of objects to retrieve.
	@param searchSynonymsParams SearchSynonymsParams - The body of the the `searchSynonyms` method.
	@return SearchSynonymsResponse
*/
func (c *APIClient) SearchSynonyms(r ApiSearchSynonymsRequest, opts ...Option) (*SearchSynonymsResponse, error) {
	return c.SearchSynonymsWithContext(context.Background(), r, opts...)
}

/*
SearchSynonyms Search synonyms.

Search or browse all synonyms, optionally filtering them by type.

Request can be constructed by NewApiSearchSynonymsRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param type_ SynonymType - Only search for specific types of synonyms.
	@param page int32 - Requested page (zero-based). When specified, will retrieve a specific page; the page size is implicitly set to 100. When null, will retrieve all indices (no pagination).
	@param hitsPerPage int32 - Maximum number of objects to retrieve.
	@param searchSynonymsParams SearchSynonymsParams - The body of the the `searchSynonyms` method.
	@return SearchSynonymsResponse
*/
func (c *APIClient) SearchSynonymsWithContext(ctx context.Context, r ApiSearchSynonymsRequest, opts ...Option) (*SearchSynonymsResponse, error) {
	var (
		postBody    any
		returnValue *SearchSynonymsResponse
	)

	requestPath := "/1/indexes/{indexName}/synonyms/search"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.type_) {
		queryParams.Set("type", parameterToString(*r.type_))
	}
	if !isNilorEmpty(r.page) {
		queryParams.Set("page", parameterToString(r.page))
	}
	if !isNilorEmpty(r.hitsPerPage) {
		queryParams.Set("hitsPerPage", parameterToString(r.hitsPerPage))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.searchSynonymsParams) {
		postBody = "{}"
	} else {
		postBody = r.searchSynonymsParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchUserIdsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["searchUserIdsParams"]; ok {
		err = json.Unmarshal(v, &r.searchUserIdsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchUserIdsParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.searchUserIdsParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSearchUserIdsRequest represents the request with all the parameters for the API call.
type ApiSearchUserIdsRequest struct {
	searchUserIdsParams *SearchUserIdsParams
}

// NewApiSearchUserIdsRequest creates an instance of the ApiSearchUserIdsRequest to be used for the API call.
func (c *APIClient) NewApiSearchUserIdsRequest(searchUserIdsParams *SearchUserIdsParams) ApiSearchUserIdsRequest {
	return ApiSearchUserIdsRequest{
		searchUserIdsParams: searchUserIdsParams,
	}
}

/*
SearchUserIds Search userID. Wraps SearchUserIdsWithContext using context.Background.

Search for userIDs.
The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds propagate to the different clusters.
To keep updates moving quickly, the index of userIDs isn't built synchronously with the mapping. Instead, the index is built once every 12h, at the same time as the update of userID usage. For example, when you perform a modification like adding or moving a userID, the search will report an outdated value until the next rebuild of the mapping, which takes place every 12h.
Upon success, the response is 200 OK and contains the following userIDs data.

Request can be constructed by NewApiSearchUserIdsRequest with parameters below.

	@param searchUserIdsParams SearchUserIdsParams
	@return SearchUserIdsResponse
*/
func (c *APIClient) SearchUserIds(r ApiSearchUserIdsRequest, opts ...Option) (*SearchUserIdsResponse, error) {
	return c.SearchUserIdsWithContext(context.Background(), r, opts...)
}

/*
SearchUserIds Search userID.

Search for userIDs.
The data returned will usually be a few seconds behind real time, because userID usage may take up to a few seconds propagate to the different clusters.
To keep updates moving quickly, the index of userIDs isn't built synchronously with the mapping. Instead, the index is built once every 12h, at the same time as the update of userID usage. For example, when you perform a modification like adding or moving a userID, the search will report an outdated value until the next rebuild of the mapping, which takes place every 12h.
Upon success, the response is 200 OK and contains the following userIDs data.

Request can be constructed by NewApiSearchUserIdsRequest with parameters below.

	@param searchUserIdsParams SearchUserIdsParams
	@return SearchUserIdsResponse
*/
func (c *APIClient) SearchUserIdsWithContext(ctx context.Context, r ApiSearchUserIdsRequest, opts ...Option) (*SearchUserIdsResponse, error) {
	var (
		postBody    any
		returnValue *SearchUserIdsResponse
	)

	requestPath := "/1/clusters/mapping/search"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.searchUserIdsParams == nil {
		return returnValue, reportError("searchUserIdsParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.searchUserIdsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSetDictionarySettingsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["dictionarySettingsParams"]; ok {
		err = json.Unmarshal(v, &r.dictionarySettingsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.dictionarySettingsParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.dictionarySettingsParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSetDictionarySettingsRequest represents the request with all the parameters for the API call.
type ApiSetDictionarySettingsRequest struct {
	dictionarySettingsParams *DictionarySettingsParams
}

// NewApiSetDictionarySettingsRequest creates an instance of the ApiSetDictionarySettingsRequest to be used for the API call.
func (c *APIClient) NewApiSetDictionarySettingsRequest(dictionarySettingsParams *DictionarySettingsParams) ApiSetDictionarySettingsRequest {
	return ApiSetDictionarySettingsRequest{
		dictionarySettingsParams: dictionarySettingsParams,
	}
}

/*
SetDictionarySettings Set dictionaries settings. Wraps SetDictionarySettingsWithContext using context.Background.

Set dictionaries settings.

Request can be constructed by NewApiSetDictionarySettingsRequest with parameters below.

	@param dictionarySettingsParams DictionarySettingsParams
	@return UpdatedAtResponse
*/
func (c *APIClient) SetDictionarySettings(r ApiSetDictionarySettingsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SetDictionarySettingsWithContext(context.Background(), r, opts...)
}

/*
SetDictionarySettings Set dictionaries settings.

Set dictionaries settings.

Request can be constructed by NewApiSetDictionarySettingsRequest with parameters below.

	@param dictionarySettingsParams DictionarySettingsParams
	@return UpdatedAtResponse
*/
func (c *APIClient) SetDictionarySettingsWithContext(ctx context.Context, r ApiSetDictionarySettingsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/dictionaries/*/settings"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.dictionarySettingsParams == nil {
		return returnValue, reportError("dictionarySettingsParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.dictionarySettingsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSetSettingsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["indexSettings"]; ok {
		err = json.Unmarshal(v, &r.indexSettings)
		if err != nil {
			err = json.Unmarshal(b, &r.indexSettings)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.indexSettings)
		if err != nil {
			return err
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSetSettingsRequest represents the request with all the parameters for the API call.
type ApiSetSettingsRequest struct {
	indexName         string
	indexSettings     *IndexSettings
	forwardToReplicas bool
}

// NewApiSetSettingsRequest creates an instance of the ApiSetSettingsRequest to be used for the API call.
func (c *APIClient) NewApiSetSettingsRequest(indexName string, indexSettings *IndexSettings) ApiSetSettingsRequest {
	return ApiSetSettingsRequest{
		indexName:     indexName,
		indexSettings: indexSettings,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSetSettingsRequest and returns the request for chaining.
func (r ApiSetSettingsRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSetSettingsRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
SetSettings Update settings of an index. Wraps SetSettingsWithContext using context.Background.

Update settings of an index. Only specified settings are overridden; unspecified settings are left unchanged. Specifying null for a setting resets it to its default value.

Request can be constructed by NewApiSetSettingsRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param indexSettings IndexSettings
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return UpdatedAtResponse
*/
func (c *APIClient) SetSettings(r ApiSetSettingsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SetSettingsWithContext(context.Background(), r, opts...)
}

/*
SetSettings Update settings of an index.

Update settings of an index. Only specified settings are overridden; unspecified settings are left unchanged. Specifying null for a setting resets it to its default value.

Request can be constructed by NewApiSetSettingsRequest with parameters below.

	@param indexName string - The index in which to perform the request.
	@param indexSettings IndexSettings
	@param forwardToReplicas bool - When true, changes are also propagated to replicas of the given indexName.
	@return UpdatedAtResponse
*/
func (c *APIClient) SetSettingsWithContext(ctx context.Context, r ApiSetSettingsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/settings"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexSettings == nil {
		return returnValue, reportError("indexSettings is required and must be specified")
	}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.indexSettings
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["key"]; ok {
		err = json.Unmarshal(v, &r.key)
		if err != nil {
			err = json.Unmarshal(b, &r.key)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["apiKey"]; ok {
		err = json.Unmarshal(v, &r.apiKey)
		if err != nil {
			err = json.Unmarshal(b, &r.apiKey)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.apiKey)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiUpdateApiKeyRequest represents the request with all the parameters for the API call.
type ApiUpdateApiKeyRequest struct {
	key    string
	apiKey *ApiKey
}

// NewApiUpdateApiKeyRequest creates an instance of the ApiUpdateApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiUpdateApiKeyRequest(key string, apiKey *ApiKey) ApiUpdateApiKeyRequest {
	return ApiUpdateApiKeyRequest{
		key:    key,
		apiKey: apiKey,
	}
}

/*
UpdateApiKey Update an API key. Wraps UpdateApiKeyWithContext using context.Background.

Replace every permission of an existing API key.

Request can be constructed by NewApiUpdateApiKeyRequest with parameters below.

	@param key string - API Key string.
	@param apiKey ApiKey
	@return UpdateApiKeyResponse
*/
func (c *APIClient) UpdateApiKey(r ApiUpdateApiKeyRequest, opts ...Option) (*UpdateApiKeyResponse, error) {
	return c.UpdateApiKeyWithContext(context.Background(), r, opts...)
}

/*
UpdateApiKey Update an API key.

Replace every permission of an existing API key.

Request can be constructed by NewApiUpdateApiKeyRequest with parameters below.

	@param key string - API Key string.
	@param apiKey ApiKey
	@return UpdateApiKeyResponse
*/
func (c *APIClient) UpdateApiKeyWithContext(ctx context.Context, r ApiUpdateApiKeyRequest, opts ...Option) (*UpdateApiKeyResponse, error) {
	var (
		postBody    any
		returnValue *UpdateApiKeyResponse
	)

	requestPath := "/1/keys/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(parameterToString(r.key)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.apiKey == nil {
		return returnValue, reportError("apiKey is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.apiKey
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
