// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package search

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"slices"
	"strings"
	"time"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/call"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/internal/errs"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       name,
		value:      parameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

func (r *ApiAddApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["apiKey"]; ok {
		err = json.Unmarshal(v, &r.apiKey)
		if err != nil {
			err = json.Unmarshal(b, &r.apiKey)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.apiKey)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiAddApiKeyRequest represents the request with all the parameters for the API call.
type ApiAddApiKeyRequest struct {
	apiKey *ApiKey
}

// NewApiAddApiKeyRequest creates an instance of the ApiAddApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiAddApiKeyRequest(apiKey *ApiKey) ApiAddApiKeyRequest {
	return ApiAddApiKeyRequest{
		apiKey: apiKey,
	}
}

/*
AddApiKey Add API key. Wraps AddApiKeyWithContext using context.Background.

Add a new API key with specific permissions and restrictions.
The request must be authenticated with the admin API key.
The response returns an API key string.

Request can be constructed by NewApiAddApiKeyRequest with parameters below.

	@param apiKey ApiKey
	@return AddApiKeyResponse
*/
func (c *APIClient) AddApiKey(r ApiAddApiKeyRequest, opts ...Option) (*AddApiKeyResponse, error) {
	return c.AddApiKeyWithContext(context.Background(), r, opts...)
}

/*
AddApiKey Add API key.

Add a new API key with specific permissions and restrictions.
The request must be authenticated with the admin API key.
The response returns an API key string.

Request can be constructed by NewApiAddApiKeyRequest with parameters below.

	@param apiKey ApiKey
	@return AddApiKeyResponse
*/
func (c *APIClient) AddApiKeyWithContext(ctx context.Context, r ApiAddApiKeyRequest, opts ...Option) (*AddApiKeyResponse, error) {
	var (
		postBody    any
		returnValue *AddApiKeyResponse
	)

	requestPath := "/1/keys"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.apiKey == nil {
		return returnValue, reportError("apiKey is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.apiKey
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiAddOrUpdateObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.body)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiAddOrUpdateObjectRequest represents the request with all the parameters for the API call.
type ApiAddOrUpdateObjectRequest struct {
	indexName string
	objectID  string
	body      map[string]interface{}
}

// NewApiAddOrUpdateObjectRequest creates an instance of the ApiAddOrUpdateObjectRequest to be used for the API call.
func (c *APIClient) NewApiAddOrUpdateObjectRequest(indexName string, objectID string, body map[string]interface{}) ApiAddOrUpdateObjectRequest {
	return ApiAddOrUpdateObjectRequest{
		indexName: indexName,
		objectID:  objectID,
		body:      body,
	}
}

/*
AddOrUpdateObject Add or update a record (using objectID). Wraps AddOrUpdateObjectWithContext using context.Background.

If you use an existing `objectID`, the existing record will be replaced with the new one.

To update only some attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead.

To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).

Request can be constructed by NewApiAddOrUpdateObjectRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique record (object) identifier.
	@param body map[string]interface{} - Algolia record.
	@return UpdatedAtWithObjectIdResponse
*/
func (c *APIClient) AddOrUpdateObject(r ApiAddOrUpdateObjectRequest, opts ...Option) (*UpdatedAtWithObjectIdResponse, error) {
	return c.AddOrUpdateObjectWithContext(context.Background(), r, opts...)
}

/*
AddOrUpdateObject Add or update a record (using objectID).

If you use an existing `objectID`, the existing record will be replaced with the new one.

To update only some attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead.

To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).

Request can be constructed by NewApiAddOrUpdateObjectRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique record (object) identifier.
	@param body map[string]interface{} - Algolia record.
	@return UpdatedAtWithObjectIdResponse
*/
func (c *APIClient) AddOrUpdateObjectWithContext(ctx context.Context, r ApiAddOrUpdateObjectRequest, opts ...Option) (*UpdatedAtWithObjectIdResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtWithObjectIdResponse
	)

	requestPath := "/1/indexes/{indexName}/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.body
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiAppendSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["source"]; ok {
		err = json.Unmarshal(v, &r.source)
		if err != nil {
			err = json.Unmarshal(b, &r.source)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.source)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiAppendSourceRequest represents the request with all the parameters for the API call.
type ApiAppendSourceRequest struct {
	source *Source
}

// NewApiAppendSourceRequest creates an instance of the ApiAppendSourceRequest to be used for the API call.
func (c *APIClient) NewApiAppendSourceRequest(source *Source) ApiAppendSourceRequest {
	return ApiAppendSourceRequest{
		source: source,
	}
}

/*
AppendSource Add a source. Wraps AppendSourceWithContext using context.Background.

Add a source to the list of allowed sources.

Request can be constructed by NewApiAppendSourceRequest with parameters below.

	@param source Source - Source to add.
	@return CreatedAtResponse
*/
func (c *APIClient) AppendSource(r ApiAppendSourceRequest, opts ...Option) (*CreatedAtResponse, error) {
	return c.AppendSourceWithContext(context.Background(), r, opts...)
}

/*
AppendSource Add a source.

Add a source to the list of allowed sources.

Request can be constructed by NewApiAppendSourceRequest with parameters below.

	@param source Source - Source to add.
	@return CreatedAtResponse
*/
func (c *APIClient) AppendSourceWithContext(ctx context.Context, r ApiAppendSourceRequest, opts ...Option) (*CreatedAtResponse, error) {
	var (
		postBody    any
		returnValue *CreatedAtResponse
	)

	requestPath := "/1/security/sources/append"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.source == nil {
		return returnValue, reportError("source is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.source
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiAssignUserIdRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["xAlgoliaUserID"]; ok {
		err = json.Unmarshal(v, &r.xAlgoliaUserID)
		if err != nil {
			err = json.Unmarshal(b, &r.xAlgoliaUserID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["assignUserIdParams"]; ok {
		err = json.Unmarshal(v, &r.assignUserIdParams)
		if err != nil {
			err = json.Unmarshal(b, &r.assignUserIdParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.assignUserIdParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiAssignUserIdRequest represents the request with all the parameters for the API call.
type ApiAssignUserIdRequest struct {
	xAlgoliaUserID     string
	assignUserIdParams *AssignUserIdParams
}

// NewApiAssignUserIdRequest creates an instance of the ApiAssignUserIdRequest to be used for the API call.
func (c *APIClient) NewApiAssignUserIdRequest(xAlgoliaUserID string, assignUserIdParams *AssignUserIdParams) ApiAssignUserIdRequest {
	return ApiAssignUserIdRequest{
		xAlgoliaUserID:     xAlgoliaUserID,
		assignUserIdParams: assignUserIdParams,
	}
}

/*
AssignUserId Assign or move a user ID. Wraps AssignUserIdWithContext using context.Background.

Assign or move a user ID to a cluster.
The time it takes to move a user is proportional to the amount of data linked to the user ID.

Request can be constructed by NewApiAssignUserIdRequest with parameters below.

	@param xAlgoliaUserID string - userID to assign.
	@param assignUserIdParams AssignUserIdParams
	@return CreatedAtResponse
*/
func (c *APIClient) AssignUserId(r ApiAssignUserIdRequest, opts ...Option) (*CreatedAtResponse, error) {
	return c.AssignUserIdWithContext(context.Background(), r, opts...)
}

/*
AssignUserId Assign or move a user ID.

Assign or move a user ID to a cluster.
The time it takes to move a user is proportional to the amount of data linked to the user ID.

Request can be constructed by NewApiAssignUserIdRequest with parameters below.

	@param xAlgoliaUserID string - userID to assign.
	@param assignUserIdParams AssignUserIdParams
	@return CreatedAtResponse
*/
func (c *APIClient) AssignUserIdWithContext(ctx context.Context, r ApiAssignUserIdRequest, opts ...Option) (*CreatedAtResponse, error) {
	var (
		postBody    any
		returnValue *CreatedAtResponse
	)

	requestPath := "/1/clusters/mapping"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.xAlgoliaUserID == "" {
		return returnValue, reportError("xAlgoliaUserID is required and must be specified")
	}
	if r.assignUserIdParams == nil {
		return returnValue, reportError("assignUserIdParams is required and must be specified")
	}

	headers["X-Algolia-User-ID"] = parameterToString(r.xAlgoliaUserID)

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.assignUserIdParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiBatchRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["batchWriteParams"]; ok {
		err = json.Unmarshal(v, &r.batchWriteParams)
		if err != nil {
			err = json.Unmarshal(b, &r.batchWriteParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.batchWriteParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiBatchRequest represents the request with all the parameters for the API call.
type ApiBatchRequest struct {
	indexName        string
	batchWriteParams *BatchWriteParams
}

// NewApiBatchRequest creates an instance of the ApiBatchRequest to be used for the API call.
func (c *APIClient) NewApiBatchRequest(indexName string, batchWriteParams *BatchWriteParams) ApiBatchRequest {
	return ApiBatchRequest{
		indexName:        indexName,
		batchWriteParams: batchWriteParams,
	}
}

/*
Batch Batch write operations on one index. Wraps BatchWithContext using context.Background.

To reduce the time spent on network round trips, you can perform several write actions in a single API call. Actions are applied in the order they are specified.
The supported `action`s are equivalent to the individual operations of the same name.

Request can be constructed by NewApiBatchRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param batchWriteParams BatchWriteParams
	@return BatchResponse
*/
func (c *APIClient) Batch(r ApiBatchRequest, opts ...Option) (*BatchResponse, error) {
	return c.BatchWithContext(context.Background(), r, opts...)
}

/*
Batch Batch write operations on one index.

To reduce the time spent on network round trips, you can perform several write actions in a single API call. Actions are applied in the order they are specified.
The supported `action`s are equivalent to the individual operations of the same name.

Request can be constructed by NewApiBatchRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param batchWriteParams BatchWriteParams
	@return BatchResponse
*/
func (c *APIClient) BatchWithContext(ctx context.Context, r ApiBatchRequest, opts ...Option) (*BatchResponse, error) {
	var (
		postBody    any
		returnValue *BatchResponse
	)

	requestPath := "/1/indexes/{indexName}/batch"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.batchWriteParams == nil {
		return returnValue, reportError("batchWriteParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.batchWriteParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiBatchAssignUserIdsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["xAlgoliaUserID"]; ok {
		err = json.Unmarshal(v, &r.xAlgoliaUserID)
		if err != nil {
			err = json.Unmarshal(b, &r.xAlgoliaUserID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["batchAssignUserIdsParams"]; ok {
		err = json.Unmarshal(v, &r.batchAssignUserIdsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.batchAssignUserIdsParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.batchAssignUserIdsParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiBatchAssignUserIdsRequest represents the request with all the parameters for the API call.
type ApiBatchAssignUserIdsRequest struct {
	xAlgoliaUserID           string
	batchAssignUserIdsParams *BatchAssignUserIdsParams
}

// NewApiBatchAssignUserIdsRequest creates an instance of the ApiBatchAssignUserIdsRequest to be used for the API call.
func (c *APIClient) NewApiBatchAssignUserIdsRequest(xAlgoliaUserID string, batchAssignUserIdsParams *BatchAssignUserIdsParams) ApiBatchAssignUserIdsRequest {
	return ApiBatchAssignUserIdsRequest{
		xAlgoliaUserID:           xAlgoliaUserID,
		batchAssignUserIdsParams: batchAssignUserIdsParams,
	}
}

/*
BatchAssignUserIds Batch assign userIDs. Wraps BatchAssignUserIdsWithContext using context.Background.

Assign multiple user IDs to a cluster.
**You can't _move_ users with this operation.**.

Request can be constructed by NewApiBatchAssignUserIdsRequest with parameters below.

	@param xAlgoliaUserID string - userID to assign.
	@param batchAssignUserIdsParams BatchAssignUserIdsParams
	@return CreatedAtResponse
*/
func (c *APIClient) BatchAssignUserIds(r ApiBatchAssignUserIdsRequest, opts ...Option) (*CreatedAtResponse, error) {
	return c.BatchAssignUserIdsWithContext(context.Background(), r, opts...)
}

/*
BatchAssignUserIds Batch assign userIDs.

Assign multiple user IDs to a cluster.
**You can't _move_ users with this operation.**.

Request can be constructed by NewApiBatchAssignUserIdsRequest with parameters below.

	@param xAlgoliaUserID string - userID to assign.
	@param batchAssignUserIdsParams BatchAssignUserIdsParams
	@return CreatedAtResponse
*/
func (c *APIClient) BatchAssignUserIdsWithContext(ctx context.Context, r ApiBatchAssignUserIdsRequest, opts ...Option) (*CreatedAtResponse, error) {
	var (
		postBody    any
		returnValue *CreatedAtResponse
	)

	requestPath := "/1/clusters/mapping/batch"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.xAlgoliaUserID == "" {
		return returnValue, reportError("xAlgoliaUserID is required and must be specified")
	}
	if r.batchAssignUserIdsParams == nil {
		return returnValue, reportError("batchAssignUserIdsParams is required and must be specified")
	}

	headers["X-Algolia-User-ID"] = parameterToString(r.xAlgoliaUserID)

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.batchAssignUserIdsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiBatchDictionaryEntriesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["dictionaryName"]; ok {
		err = json.Unmarshal(v, &r.dictionaryName)
		if err != nil {
			err = json.Unmarshal(b, &r.dictionaryName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["batchDictionaryEntriesParams"]; ok {
		err = json.Unmarshal(v, &r.batchDictionaryEntriesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.batchDictionaryEntriesParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.batchDictionaryEntriesParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiBatchDictionaryEntriesRequest represents the request with all the parameters for the API call.
type ApiBatchDictionaryEntriesRequest struct {
	dictionaryName               DictionaryType
	batchDictionaryEntriesParams *BatchDictionaryEntriesParams
}

// NewApiBatchDictionaryEntriesRequest creates an instance of the ApiBatchDictionaryEntriesRequest to be used for the API call.
func (c *APIClient) NewApiBatchDictionaryEntriesRequest(dictionaryName DictionaryType, batchDictionaryEntriesParams *BatchDictionaryEntriesParams) ApiBatchDictionaryEntriesRequest {
	return ApiBatchDictionaryEntriesRequest{
		dictionaryName:               dictionaryName,
		batchDictionaryEntriesParams: batchDictionaryEntriesParams,
	}
}

/*
BatchDictionaryEntries Batch dictionary entries. Wraps BatchDictionaryEntriesWithContext using context.Background.

Add or remove a batch of dictionary entries.

Request can be constructed by NewApiBatchDictionaryEntriesRequest with parameters below.

	@param dictionaryName DictionaryType - Dictionary to search in.
	@param batchDictionaryEntriesParams BatchDictionaryEntriesParams
	@return UpdatedAtResponse
*/
func (c *APIClient) BatchDictionaryEntries(r ApiBatchDictionaryEntriesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.BatchDictionaryEntriesWithContext(context.Background(), r, opts...)
}

/*
BatchDictionaryEntries Batch dictionary entries.

Add or remove a batch of dictionary entries.

Request can be constructed by NewApiBatchDictionaryEntriesRequest with parameters below.

	@param dictionaryName DictionaryType - Dictionary to search in.
	@param batchDictionaryEntriesParams BatchDictionaryEntriesParams
	@return UpdatedAtResponse
*/
func (c *APIClient) BatchDictionaryEntriesWithContext(ctx context.Context, r ApiBatchDictionaryEntriesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/dictionaries/{dictionaryName}/batch"
	requestPath = strings.Replace(requestPath, "{"+"dictionaryName"+"}", url.PathEscape(parameterToString(r.dictionaryName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.batchDictionaryEntriesParams == nil {
		return returnValue, reportError("batchDictionaryEntriesParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.batchDictionaryEntriesParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiBrowseRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["browseParams"]; ok {
		err = json.Unmarshal(v, &r.browseParams)
		if err != nil {
			err = json.Unmarshal(b, &r.browseParams)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiBrowseRequest represents the request with all the parameters for the API call.
type ApiBrowseRequest struct {
	indexName    string
	browseParams *BrowseParams
}

// NewApiBrowseRequest creates an instance of the ApiBrowseRequest to be used for the API call.
func (c *APIClient) NewApiBrowseRequest(indexName string) ApiBrowseRequest {
	return ApiBrowseRequest{
		indexName: indexName,
	}
}

// WithBrowseParams adds the browseParams to the ApiBrowseRequest and returns the request for chaining.
func (r ApiBrowseRequest) WithBrowseParams(browseParams *BrowseParams) ApiBrowseRequest {
	r.browseParams = browseParams
	return r
}

/*
Browse Get all records from an index. Wraps BrowseWithContext using context.Background.

Retrieve up to 1,000 records per call.
Supports full-text search and filters. For better performance, it doesn't support:
- The `distinct` query parameter - Sorting by typos, proximity, words, or geographical distance.

Request can be constructed by NewApiBrowseRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param browseParams BrowseParams
	@return BrowseResponse
*/
func (c *APIClient) Browse(r ApiBrowseRequest, opts ...Option) (*BrowseResponse, error) {
	return c.BrowseWithContext(context.Background(), r, opts...)
}

/*
Browse Get all records from an index.

Retrieve up to 1,000 records per call.
Supports full-text search and filters. For better performance, it doesn't support:
- The `distinct` query parameter - Sorting by typos, proximity, words, or geographical distance.

Request can be constructed by NewApiBrowseRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param browseParams BrowseParams
	@return BrowseResponse
*/
func (c *APIClient) BrowseWithContext(ctx context.Context, r ApiBrowseRequest, opts ...Option) (*BrowseResponse, error) {
	var (
		postBody    any
		returnValue *BrowseResponse
	)

	requestPath := "/1/indexes/{indexName}/browse"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.browseParams) {
		postBody = "{}"
	} else {
		postBody = r.browseParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiClearAllSynonymsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiClearAllSynonymsRequest represents the request with all the parameters for the API call.
type ApiClearAllSynonymsRequest struct {
	indexName         string
	forwardToReplicas bool
}

// NewApiClearAllSynonymsRequest creates an instance of the ApiClearAllSynonymsRequest to be used for the API call.
func (c *APIClient) NewApiClearAllSynonymsRequest(indexName string) ApiClearAllSynonymsRequest {
	return ApiClearAllSynonymsRequest{
		indexName: indexName,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiClearAllSynonymsRequest and returns the request for chaining.
func (r ApiClearAllSynonymsRequest) WithForwardToReplicas(forwardToReplicas bool) ApiClearAllSynonymsRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
ClearAllSynonyms Delete all synonyms. Wraps ClearAllSynonymsWithContext using context.Background.

Delete all synonyms in the index.

Request can be constructed by NewApiClearAllSynonymsRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearAllSynonyms(r ApiClearAllSynonymsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.ClearAllSynonymsWithContext(context.Background(), r, opts...)
}

/*
ClearAllSynonyms Delete all synonyms.

Delete all synonyms in the index.

Request can be constructed by NewApiClearAllSynonymsRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearAllSynonymsWithContext(ctx context.Context, r ApiClearAllSynonymsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/synonyms/clear"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiClearObjectsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiClearObjectsRequest represents the request with all the parameters for the API call.
type ApiClearObjectsRequest struct {
	indexName string
}

// NewApiClearObjectsRequest creates an instance of the ApiClearObjectsRequest to be used for the API call.
func (c *APIClient) NewApiClearObjectsRequest(indexName string) ApiClearObjectsRequest {
	return ApiClearObjectsRequest{
		indexName: indexName,
	}
}

/*
ClearObjects Delete all records from an index. Wraps ClearObjectsWithContext using context.Background.

Delete the records but leave settings and index-specific API keys untouched.

Request can be constructed by NewApiClearObjectsRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearObjects(r ApiClearObjectsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.ClearObjectsWithContext(context.Background(), r, opts...)
}

/*
ClearObjects Delete all records from an index.

Delete the records but leave settings and index-specific API keys untouched.

Request can be constructed by NewApiClearObjectsRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearObjectsWithContext(ctx context.Context, r ApiClearObjectsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/clear"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiClearRulesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiClearRulesRequest represents the request with all the parameters for the API call.
type ApiClearRulesRequest struct {
	indexName         string
	forwardToReplicas bool
}

// NewApiClearRulesRequest creates an instance of the ApiClearRulesRequest to be used for the API call.
func (c *APIClient) NewApiClearRulesRequest(indexName string) ApiClearRulesRequest {
	return ApiClearRulesRequest{
		indexName: indexName,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiClearRulesRequest and returns the request for chaining.
func (r ApiClearRulesRequest) WithForwardToReplicas(forwardToReplicas bool) ApiClearRulesRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
ClearRules Delete all rules. Wraps ClearRulesWithContext using context.Background.

Delete all rules in the index.

Request can be constructed by NewApiClearRulesRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearRules(r ApiClearRulesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.ClearRulesWithContext(context.Background(), r, opts...)
}

/*
ClearRules Delete all rules.

Delete all rules in the index.

Request can be constructed by NewApiClearRulesRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearRulesWithContext(ctx context.Context, r ApiClearRulesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/rules/clear"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDelRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDelRequest represents the request with all the parameters for the API call.
type ApiDelRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiDelRequest creates an instance of the ApiDelRequest to be used for the API call.
func (c *APIClient) NewApiDelRequest(path string) ApiDelRequest {
	return ApiDelRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiDelRequest and returns the request for chaining.
func (r ApiDelRequest) WithParameters(parameters map[string]interface{}) ApiDelRequest {
	r.parameters = parameters
	return r
}

/*
Del Send requests to the Algolia REST API. Wraps DelWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiDelRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) Del(r ApiDelRequest, opts ...Option) (map[string]interface{}, error) {
	return c.DelWithContext(context.Background(), r, opts...)
}

/*
Del Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiDelRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) DelWithContext(ctx context.Context, r ApiDelRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["key"]; ok {
		err = json.Unmarshal(v, &r.key)
		if err != nil {
			err = json.Unmarshal(b, &r.key)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteApiKeyRequest represents the request with all the parameters for the API call.
type ApiDeleteApiKeyRequest struct {
	key string
}

// NewApiDeleteApiKeyRequest creates an instance of the ApiDeleteApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiDeleteApiKeyRequest(key string) ApiDeleteApiKeyRequest {
	return ApiDeleteApiKeyRequest{
		key: key,
	}
}

/*
DeleteApiKey Delete API key. Wraps DeleteApiKeyWithContext using context.Background.

Delete an existing API key.
The request must be authenticated with the admin API key.

Request can be constructed by NewApiDeleteApiKeyRequest with parameters below.

	@param key string - API key.
	@return DeleteApiKeyResponse
*/
func (c *APIClient) DeleteApiKey(r ApiDeleteApiKeyRequest, opts ...Option) (*DeleteApiKeyResponse, error) {
	return c.DeleteApiKeyWithContext(context.Background(), r, opts...)
}

/*
DeleteApiKey Delete API key.

Delete an existing API key.
The request must be authenticated with the admin API key.

Request can be constructed by NewApiDeleteApiKeyRequest with parameters below.

	@param key string - API key.
	@return DeleteApiKeyResponse
*/
func (c *APIClient) DeleteApiKeyWithContext(ctx context.Context, r ApiDeleteApiKeyRequest, opts ...Option) (*DeleteApiKeyResponse, error) {
	var (
		postBody    any
		returnValue *DeleteApiKeyResponse
	)

	requestPath := "/1/keys/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(parameterToString(r.key)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteByRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["deleteByParams"]; ok {
		err = json.Unmarshal(v, &r.deleteByParams)
		if err != nil {
			err = json.Unmarshal(b, &r.deleteByParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.deleteByParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiDeleteByRequest represents the request with all the parameters for the API call.
type ApiDeleteByRequest struct {
	indexName      string
	deleteByParams *DeleteByParams
}

// NewApiDeleteByRequest creates an instance of the ApiDeleteByRequest to be used for the API call.
func (c *APIClient) NewApiDeleteByRequest(indexName string, deleteByParams *DeleteByParams) ApiDeleteByRequest {
	return ApiDeleteByRequest{
		indexName:      indexName,
		deleteByParams: deleteByParams,
	}
}

/*
DeleteBy Delete all records matching a query. Wraps DeleteByWithContext using context.Background.

This operation doesn't support all the query options, only its filters (numeric, facet, or tag) and geo queries.
It doesn't accept empty filters or queries.

Request can be constructed by NewApiDeleteByRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param deleteByParams DeleteByParams
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteBy(r ApiDeleteByRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteByWithContext(context.Background(), r, opts...)
}

/*
DeleteBy Delete all records matching a query.

This operation doesn't support all the query options, only its filters (numeric, facet, or tag) and geo queries.
It doesn't accept empty filters or queries.

Request can be constructed by NewApiDeleteByRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param deleteByParams DeleteByParams
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteByWithContext(ctx context.Context, r ApiDeleteByRequest, opts ...Option) (*DeletedAtResponse, error) {
	var (
		postBody    any
		returnValue *DeletedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/deleteByQuery"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.deleteByParams == nil {
		return returnValue, reportError("deleteByParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.deleteByParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteIndexRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteIndexRequest represents the request with all the parameters for the API call.
type ApiDeleteIndexRequest struct {
	indexName string
}

// NewApiDeleteIndexRequest creates an instance of the ApiDeleteIndexRequest to be used for the API call.
func (c *APIClient) NewApiDeleteIndexRequest(indexName string) ApiDeleteIndexRequest {
	return ApiDeleteIndexRequest{
		indexName: indexName,
	}
}

/*
DeleteIndex Delete index. Wraps DeleteIndexWithContext using context.Background.

Delete an existing index.

Request can be constructed by NewApiDeleteIndexRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteIndex(r ApiDeleteIndexRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteIndexWithContext(context.Background(), r, opts...)
}

/*
DeleteIndex Delete index.

Delete an existing index.

Request can be constructed by NewApiDeleteIndexRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteIndexWithContext(ctx context.Context, r ApiDeleteIndexRequest, opts ...Option) (*DeletedAtResponse, error) {
	var (
		postBody    any
		returnValue *DeletedAtResponse
	)

	requestPath := "/1/indexes/{indexName}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteObjectRequest represents the request with all the parameters for the API call.
type ApiDeleteObjectRequest struct {
	indexName string
	objectID  string
}

// NewApiDeleteObjectRequest creates an instance of the ApiDeleteObjectRequest to be used for the API call.
func (c *APIClient) NewApiDeleteObjectRequest(indexName string, objectID string) ApiDeleteObjectRequest {
	return ApiDeleteObjectRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

/*
DeleteObject Delete a record. Wraps DeleteObjectWithContext using context.Background.

To delete a set of records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy) instead.

Request can be constructed by NewApiDeleteObjectRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique record (object) identifier.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteObject(r ApiDeleteObjectRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteObjectWithContext(context.Background(), r, opts...)
}

/*
DeleteObject Delete a record.

To delete a set of records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy) instead.

Request can be constructed by NewApiDeleteObjectRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique record (object) identifier.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteObjectWithContext(ctx context.Context, r ApiDeleteObjectRequest, opts ...Option) (*DeletedAtResponse, error) {
	var (
		postBody    any
		returnValue *DeletedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteRuleRequest represents the request with all the parameters for the API call.
type ApiDeleteRuleRequest struct {
	indexName         string
	objectID          string
	forwardToReplicas bool
}

// NewApiDeleteRuleRequest creates an instance of the ApiDeleteRuleRequest to be used for the API call.
func (c *APIClient) NewApiDeleteRuleRequest(indexName string, objectID string) ApiDeleteRuleRequest {
	return ApiDeleteRuleRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiDeleteRuleRequest and returns the request for chaining.
func (r ApiDeleteRuleRequest) WithForwardToReplicas(forwardToReplicas bool) ApiDeleteRuleRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
DeleteRule Delete a rule. Wraps DeleteRuleWithContext using context.Background.

Delete a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).

Request can be constructed by NewApiDeleteRuleRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique identifier of a rule object.
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) DeleteRule(r ApiDeleteRuleRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.DeleteRuleWithContext(context.Background(), r, opts...)
}

/*
DeleteRule Delete a rule.

Delete a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).

Request can be constructed by NewApiDeleteRuleRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique identifier of a rule object.
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) DeleteRuleWithContext(ctx context.Context, r ApiDeleteRuleRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/rules/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["source"]; ok {
		err = json.Unmarshal(v, &r.source)
		if err != nil {
			err = json.Unmarshal(b, &r.source)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteSourceRequest represents the request with all the parameters for the API call.
type ApiDeleteSourceRequest struct {
	source string
}

// NewApiDeleteSourceRequest creates an instance of the ApiDeleteSourceRequest to be used for the API call.
func (c *APIClient) NewApiDeleteSourceRequest(source string) ApiDeleteSourceRequest {
	return ApiDeleteSourceRequest{
		source: source,
	}
}

/*
DeleteSource Remove a source. Wraps DeleteSourceWithContext using context.Background.

Remove a source from the list of allowed sources.

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param source string - IP address range of the source.
	@return DeleteSourceResponse
*/
func (c *APIClient) DeleteSource(r ApiDeleteSourceRequest, opts ...Option) (*DeleteSourceResponse, error) {
	return c.DeleteSourceWithContext(context.Background(), r, opts...)
}

/*
DeleteSource Remove a source.

Remove a source from the list of allowed sources.

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param source string - IP address range of the source.
	@return DeleteSourceResponse
*/
func (c *APIClient) DeleteSourceWithContext(ctx context.Context, r ApiDeleteSourceRequest, opts ...Option) (*DeleteSourceResponse, error) {
	var (
		postBody    any
		returnValue *DeleteSourceResponse
	)

	requestPath := "/1/security/sources/{source}"
	requestPath = strings.Replace(requestPath, "{"+"source"+"}", url.PathEscape(parameterToString(r.source)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteSynonymRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteSynonymRequest represents the request with all the parameters for the API call.
type ApiDeleteSynonymRequest struct {
	indexName         string
	objectID          string
	forwardToReplicas bool
}

// NewApiDeleteSynonymRequest creates an instance of the ApiDeleteSynonymRequest to be used for the API call.
func (c *APIClient) NewApiDeleteSynonymRequest(indexName string, objectID string) ApiDeleteSynonymRequest {
	return ApiDeleteSynonymRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiDeleteSynonymRequest and returns the request for chaining.
func (r ApiDeleteSynonymRequest) WithForwardToReplicas(forwardToReplicas bool) ApiDeleteSynonymRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
DeleteSynonym Delete a synonym. Wraps DeleteSynonymWithContext using context.Background.

Delete a synonym by its `objectID`. To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

Request can be constructed by NewApiDeleteSynonymRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique identifier of a synonym object.
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteSynonym(r ApiDeleteSynonymRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteSynonymWithContext(context.Background(), r, opts...)
}

/*
DeleteSynonym Delete a synonym.

Delete a synonym by its `objectID`. To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

Request can be constructed by NewApiDeleteSynonymRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique identifier of a synonym object.
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteSynonymWithContext(ctx context.Context, r ApiDeleteSynonymRequest, opts ...Option) (*DeletedAtResponse, error) {
	var (
		postBody    any
		returnValue *DeletedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/synonyms/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetRequest represents the request with all the parameters for the API call.
type ApiGetRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiGetRequest creates an instance of the ApiGetRequest to be used for the API call.
func (c *APIClient) NewApiGetRequest(path string) ApiGetRequest {
	return ApiGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiGetRequest and returns the request for chaining.
func (r ApiGetRequest) WithParameters(parameters map[string]interface{}) ApiGetRequest {
	r.parameters = parameters
	return r
}

/*
Get Send requests to the Algolia REST API. Wraps GetWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) Get(r ApiGetRequest, opts ...Option) (map[string]interface{}, error) {
	return c.GetWithContext(context.Background(), r, opts...)
}

/*
Get Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) GetWithContext(ctx context.Context, r ApiGetRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["key"]; ok {
		err = json.Unmarshal(v, &r.key)
		if err != nil {
			err = json.Unmarshal(b, &r.key)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetApiKeyRequest represents the request with all the parameters for the API call.
type ApiGetApiKeyRequest struct {
	key string
}

// NewApiGetApiKeyRequest creates an instance of the ApiGetApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiGetApiKeyRequest(key string) ApiGetApiKeyRequest {
	return ApiGetApiKeyRequest{
		key: key,
	}
}

/*
GetApiKey Get API key permissions. Wraps GetApiKeyWithContext using context.Background.

Get the permissions and restrictions of a specific API key.
When authenticating with the admin API key, you can request information for any of your application's keys. When authenticating with other API keys, you can only retrieve information for that key.

Request can be constructed by NewApiGetApiKeyRequest with parameters below.

	@param key string - API key.
	@return GetApiKeyResponse
*/
func (c *APIClient) GetApiKey(r ApiGetApiKeyRequest, opts ...Option) (*GetApiKeyResponse, error) {
	return c.GetApiKeyWithContext(context.Background(), r, opts...)
}

/*
GetApiKey Get API key permissions.

Get the permissions and restrictions of a specific API key.
When authenticating with the admin API key, you can request information for any of your application's keys. When authenticating with other API keys, you can only retrieve information for that key.

Request can be constructed by NewApiGetApiKeyRequest with parameters below.

	@param key string - API key.
	@return GetApiKeyResponse
*/
func (c *APIClient) GetApiKeyWithContext(ctx context.Context, r ApiGetApiKeyRequest, opts ...Option) (*GetApiKeyResponse, error) {
	var (
		postBody    any
		returnValue *GetApiKeyResponse
	)

	requestPath := "/1/keys/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(parameterToString(r.key)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetDictionaryLanguages List available languages. Wraps GetDictionaryLanguagesWithContext using context.Background.

Lists Algolia's [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/) and any customizations applied to each language's [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) features.

Request can be constructed by NewApiGetDictionaryLanguagesRequest with parameters below.

	@return map[string]Languages
*/
func (c *APIClient) GetDictionaryLanguages(opts ...Option) (*map[string]Languages, error) {
	return c.GetDictionaryLanguagesWithContext(context.Background(), opts...)
}

/*
GetDictionaryLanguages List available languages.

Lists Algolia's [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/) and any customizations applied to each language's [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) features.

Request can be constructed by NewApiGetDictionaryLanguagesRequest with parameters below.

	@return map[string]Languages
*/
func (c *APIClient) GetDictionaryLanguagesWithContext(ctx context.Context, opts ...Option) (*map[string]Languages, error) {
	var (
		postBody    any
		returnValue *map[string]Languages
	)

	requestPath := "/1/dictionaries/*/languages"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetDictionarySettings Get stop word settings. Wraps GetDictionarySettingsWithContext using context.Background.

Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).

Request can be constructed by NewApiGetDictionarySettingsRequest with parameters below.

	@return GetDictionarySettingsResponse
*/
func (c *APIClient) GetDictionarySettings(opts ...Option) (*GetDictionarySettingsResponse, error) {
	return c.GetDictionarySettingsWithContext(context.Background(), opts...)
}

/*
GetDictionarySettings Get stop word settings.

Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).

Request can be constructed by NewApiGetDictionarySettingsRequest with parameters below.

	@return GetDictionarySettingsResponse
*/
func (c *APIClient) GetDictionarySettingsWithContext(ctx context.Context, opts ...Option) (*GetDictionarySettingsResponse, error) {
	var (
		postBody    any
		returnValue *GetDictionarySettingsResponse
	)

	requestPath := "/1/dictionaries/*/settings"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetLogsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["length"]; ok {
		err = json.Unmarshal(v, &r.length)
		if err != nil {
			err = json.Unmarshal(b, &r.length)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetLogsRequest represents the request with all the parameters for the API call.
type ApiGetLogsRequest struct {
	offset    int32
	length    int32
	indexName string
	type_     *LogType
}

// NewApiGetLogsRequest creates an instance of the ApiGetLogsRequest to be used for the API call.
func (c *APIClient) NewApiGetLogsRequest() ApiGetLogsRequest {
	return ApiGetLogsRequest{}
}

// WithOffset adds the offset to the ApiGetLogsRequest and returns the request for chaining.
func (r ApiGetLogsRequest) WithOffset(offset int32) ApiGetLogsRequest {
	r.offset = offset
	return r
}

// WithLength adds the length to the ApiGetLogsRequest and returns the request for chaining.
func (r ApiGetLogsRequest) WithLength(length int32) ApiGetLogsRequest {
	r.length = length
	return r
}

// WithIndexName adds the indexName to the ApiGetLogsRequest and returns the request for chaining.
func (r ApiGetLogsRequest) WithIndexName(indexName string) ApiGetLogsRequest {
	r.indexName = indexName
	return r
}

// WithType_ adds the type_ to the ApiGetLogsRequest and returns the request for chaining.
func (r ApiGetLogsRequest) WithType_(type_ *LogType) ApiGetLogsRequest {
	r.type_ = type_
	return r
}

/*
GetLogs Return the latest log entries. Wraps GetLogsWithContext using context.Background.

The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).
Logs are held for the last seven days. There's also a logging limit of 1,000 API calls per server.
This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself.
> **Note**: To fetch the logs for a Distributed Search Network (DSN) cluster, target the [DSN's endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).

Request can be constructed by NewApiGetLogsRequest with parameters below.

	@param offset int32 - First log entry to retrieve. Sorted by decreasing date with 0 being the most recent.
	@param length int32 - Maximum number of entries to retrieve.
	@param indexName string - Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices.
	@param type_ LogType - Type of log entries to retrieve. When omitted, all log entries are retrieved.
	@return GetLogsResponse
*/
func (c *APIClient) GetLogs(r ApiGetLogsRequest, opts ...Option) (*GetLogsResponse, error) {
	return c.GetLogsWithContext(context.Background(), r, opts...)
}

/*
GetLogs Return the latest log entries.

The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).
Logs are held for the last seven days. There's also a logging limit of 1,000 API calls per server.
This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself.
> **Note**: To fetch the logs for a Distributed Search Network (DSN) cluster, target the [DSN's endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).

Request can be constructed by NewApiGetLogsRequest with parameters below.

	@param offset int32 - First log entry to retrieve. Sorted by decreasing date with 0 being the most recent.
	@param length int32 - Maximum number of entries to retrieve.
	@param indexName string - Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices.
	@param type_ LogType - Type of log entries to retrieve. When omitted, all log entries are retrieved.
	@return GetLogsResponse
*/
func (c *APIClient) GetLogsWithContext(ctx context.Context, r ApiGetLogsRequest, opts ...Option) (*GetLogsResponse, error) {
	var (
		postBody    any
		returnValue *GetLogsResponse
	)

	requestPath := "/1/logs"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.offset) {
		queryParams.Set("offset", parameterToString(r.offset))
	}
	if !isNilorEmpty(r.length) {
		queryParams.Set("length", parameterToString(r.length))
	}
	if !isNilorEmpty(r.indexName) {
		queryParams.Set("indexName", parameterToString(r.indexName))
	}
	if !isNilorEmpty(r.type_) {
		queryParams.Set("type", parameterToString(*r.type_))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["attributesToRetrieve"]; ok {
		err = json.Unmarshal(v, &r.attributesToRetrieve)
		if err != nil {
			err = json.Unmarshal(b, &r.attributesToRetrieve)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetObjectRequest represents the request with all the parameters for the API call.
type ApiGetObjectRequest struct {
	indexName            string
	objectID             string
	attributesToRetrieve []string
}

// NewApiGetObjectRequest creates an instance of the ApiGetObjectRequest to be used for the API call.
func (c *APIClient) NewApiGetObjectRequest(indexName string, objectID string) ApiGetObjectRequest {
	return ApiGetObjectRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

// WithAttributesToRetrieve adds the attributesToRetrieve to the ApiGetObjectRequest and returns the request for chaining.
func (r ApiGetObjectRequest) WithAttributesToRetrieve(attributesToRetrieve []string) ApiGetObjectRequest {
	r.attributesToRetrieve = attributesToRetrieve
	return r
}

/*
GetObject Get a record. Wraps GetObjectWithContext using context.Background.

To get more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).

Request can be constructed by NewApiGetObjectRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique record (object) identifier.
	@param attributesToRetrieve []string - Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. `objectID` is always retrieved, even when not specified. [`unretrievableAttributes`](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won't be retrieved unless the request is authenticated with the admin API key.
	@return map[string]string
*/
func (c *APIClient) GetObject(r ApiGetObjectRequest, opts ...Option) (map[string]string, error) {
	return c.GetObjectWithContext(context.Background(), r, opts...)
}

/*
GetObject Get a record.

To get more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).

Request can be constructed by NewApiGetObjectRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique record (object) identifier.
	@param attributesToRetrieve []string - Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. `objectID` is always retrieved, even when not specified. [`unretrievableAttributes`](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won't be retrieved unless the request is authenticated with the admin API key.
	@return map[string]string
*/
func (c *APIClient) GetObjectWithContext(ctx context.Context, r ApiGetObjectRequest, opts ...Option) (map[string]string, error) {
	var (
		postBody    any
		returnValue map[string]string
	)

	requestPath := "/1/indexes/{indexName}/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.attributesToRetrieve) {
		queryParams.Set("attributesToRetrieve", parameterToString(r.attributesToRetrieve))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetObjectsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["getObjectsParams"]; ok {
		err = json.Unmarshal(v, &r.getObjectsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.getObjectsParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.getObjectsParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiGetObjectsRequest represents the request with all the parameters for the API call.
type ApiGetObjectsRequest struct {
	getObjectsParams *GetObjectsParams
}

// NewApiGetObjectsRequest creates an instance of the ApiGetObjectsRequest to be used for the API call.
func (c *APIClient) NewApiGetObjectsRequest(getObjectsParams *GetObjectsParams) ApiGetObjectsRequest {
	return ApiGetObjectsRequest{
		getObjectsParams: getObjectsParams,
	}
}

/*
GetObjects Get multiple records. Wraps GetObjectsWithContext using context.Background.

Retrieve one or more records, potentially from different indices, in a single API operation. Results will be received in the same order as the requests.

Request can be constructed by NewApiGetObjectsRequest with parameters below.

	@param getObjectsParams GetObjectsParams - Request object.
	@return GetObjectsResponse
*/
func (c *APIClient) GetObjects(r ApiGetObjectsRequest, opts ...Option) (*GetObjectsResponse, error) {
	return c.GetObjectsWithContext(context.Background(), r, opts...)
}

/*
GetObjects Get multiple records.

Retrieve one or more records, potentially from different indices, in a single API operation. Results will be received in the same order as the requests.

Request can be constructed by NewApiGetObjectsRequest with parameters below.

	@param getObjectsParams GetObjectsParams - Request object.
	@return GetObjectsResponse
*/
func (c *APIClient) GetObjectsWithContext(ctx context.Context, r ApiGetObjectsRequest, opts ...Option) (*GetObjectsResponse, error) {
	var (
		postBody    any
		returnValue *GetObjectsResponse
	)

	requestPath := "/1/indexes/*/objects"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.getObjectsParams == nil {
		return returnValue, reportError("getObjectsParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.getObjectsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetRuleRequest represents the request with all the parameters for the API call.
type ApiGetRuleRequest struct {
	indexName string
	objectID  string
}

// NewApiGetRuleRequest creates an instance of the ApiGetRuleRequest to be used for the API call.
func (c *APIClient) NewApiGetRuleRequest(indexName string, objectID string) ApiGetRuleRequest {
	return ApiGetRuleRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

/*
GetRule Get a rule. Wraps GetRuleWithContext using context.Background.

Get a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).

Request can be constructed by NewApiGetRuleRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique identifier of a rule object.
	@return Rule
*/
func (c *APIClient) GetRule(r ApiGetRuleRequest, opts ...Option) (*Rule, error) {
	return c.GetRuleWithContext(context.Background(), r, opts...)
}

/*
GetRule Get a rule.

Get a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).

Request can be constructed by NewApiGetRuleRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique identifier of a rule object.
	@return Rule
*/
func (c *APIClient) GetRuleWithContext(ctx context.Context, r ApiGetRuleRequest, opts ...Option) (*Rule, error) {
	var (
		postBody    any
		returnValue *Rule
	)

	requestPath := "/1/indexes/{indexName}/rules/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSettingsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetSettingsRequest represents the request with all the parameters for the API call.
type ApiGetSettingsRequest struct {
	indexName string
}

// NewApiGetSettingsRequest creates an instance of the ApiGetSettingsRequest to be used for the API call.
func (c *APIClient) NewApiGetSettingsRequest(indexName string) ApiGetSettingsRequest {
	return ApiGetSettingsRequest{
		indexName: indexName,
	}
}

/*
GetSettings Get index settings. Wraps GetSettingsWithContext using context.Background.

Return an object containing an index's [configuration settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).

Request can be constructed by NewApiGetSettingsRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@return IndexSettings
*/
func (c *APIClient) GetSettings(r ApiGetSettingsRequest, opts ...Option) (*IndexSettings, error) {
	return c.GetSettingsWithContext(context.Background(), r, opts...)
}

/*
GetSettings Get index settings.

Return an object containing an index's [configuration settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).

Request can be constructed by NewApiGetSettingsRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@return IndexSettings
*/
func (c *APIClient) GetSettingsWithContext(ctx context.Context, r ApiGetSettingsRequest, opts ...Option) (*IndexSettings, error) {
	var (
		postBody    any
		returnValue *IndexSettings
	)

	requestPath := "/1/indexes/{indexName}/settings"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetSources Get all allowed IP addresses. Wraps GetSourcesWithContext using context.Background.

Get all allowed sources (IP addresses).

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@return []Source
*/
func (c *APIClient) GetSources(opts ...Option) ([]Source, error) {
	return c.GetSourcesWithContext(context.Background(), opts...)
}

/*
GetSources Get all allowed IP addresses.

Get all allowed sources (IP addresses).

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@return []Source
*/
func (c *APIClient) GetSourcesWithContext(ctx context.Context, opts ...Option) ([]Source, error) {
	var (
		postBody    any
		returnValue []Source
	)

	requestPath := "/1/security/sources"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSynonymRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetSynonymRequest represents the request with all the parameters for the API call.
type ApiGetSynonymRequest struct {
	indexName string
	objectID  string
}

// NewApiGetSynonymRequest creates an instance of the ApiGetSynonymRequest to be used for the API call.
func (c *APIClient) NewApiGetSynonymRequest(indexName string, objectID string) ApiGetSynonymRequest {
	return ApiGetSynonymRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

/*
GetSynonym Get a synonym object. Wraps GetSynonymWithContext using context.Background.

Get a syonym by its `objectID`. To find the object IDs for your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

Request can be constructed by NewApiGetSynonymRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique identifier of a synonym object.
	@return SynonymHit
*/
func (c *APIClient) GetSynonym(r ApiGetSynonymRequest, opts ...Option) (*SynonymHit, error) {
	return c.GetSynonymWithContext(context.Background(), r, opts...)
}

/*
GetSynonym Get a synonym object.

Get a syonym by its `objectID`. To find the object IDs for your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

Request can be constructed by NewApiGetSynonymRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique identifier of a synonym object.
	@return SynonymHit
*/
func (c *APIClient) GetSynonymWithContext(ctx context.Context, r ApiGetSynonymRequest, opts ...Option) (*SynonymHit, error) {
	var (
		postBody    any
		returnValue *SynonymHit
	)

	requestPath := "/1/indexes/{indexName}/synonyms/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetTaskRequest represents the request with all the parameters for the API call.
type ApiGetTaskRequest struct {
	indexName string
	taskID    int64
}

// NewApiGetTaskRequest creates an instance of the ApiGetTaskRequest to be used for the API call.
func (c *APIClient) NewApiGetTaskRequest(indexName string, taskID int64) ApiGetTaskRequest {
	return ApiGetTaskRequest{
		indexName: indexName,
		taskID:    taskID,
	}
}

/*
GetTask Check a task's status. Wraps GetTaskWithContext using context.Background.

Some operations, such as copying an index, will respond with a `taskID` value. Use this value here to check the status of that task.

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param taskID int64 - Unique task identifier.
	@return GetTaskResponse
*/
func (c *APIClient) GetTask(r ApiGetTaskRequest, opts ...Option) (*GetTaskResponse, error) {
	return c.GetTaskWithContext(context.Background(), r, opts...)
}

/*
GetTask Check a task's status.

Some operations, such as copying an index, will respond with a `taskID` value. Use this value here to check the status of that task.

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param taskID int64 - Unique task identifier.
	@return GetTaskResponse
*/
func (c *APIClient) GetTaskWithContext(ctx context.Context, r ApiGetTaskRequest, opts ...Option) (*GetTaskResponse, error) {
	var (
		postBody    any
		returnValue *GetTaskResponse
	)

	requestPath := "/1/indexes/{indexName}/task/{taskID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"taskID"+"}", url.PathEscape(parameterToString(r.taskID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetTopUserIds Get top userID. Wraps GetTopUserIdsWithContext using context.Background.

Get the IDs of the 10 users with the highest number of records per cluster.
Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.

Request can be constructed by NewApiGetTopUserIdsRequest with parameters below.

	@return GetTopUserIdsResponse
*/
func (c *APIClient) GetTopUserIds(opts ...Option) (*GetTopUserIdsResponse, error) {
	return c.GetTopUserIdsWithContext(context.Background(), opts...)
}

/*
GetTopUserIds Get top userID.

Get the IDs of the 10 users with the highest number of records per cluster.
Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.

Request can be constructed by NewApiGetTopUserIdsRequest with parameters below.

	@return GetTopUserIdsResponse
*/
func (c *APIClient) GetTopUserIdsWithContext(ctx context.Context, opts ...Option) (*GetTopUserIdsResponse, error) {
	var (
		postBody    any
		returnValue *GetTopUserIdsResponse
	)

	requestPath := "/1/clusters/mapping/top"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetUserIdRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["userID"]; ok {
		err = json.Unmarshal(v, &r.userID)
		if err != nil {
			err = json.Unmarshal(b, &r.userID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetUserIdRequest represents the request with all the parameters for the API call.
type ApiGetUserIdRequest struct {
	userID string
}

// NewApiGetUserIdRequest creates an instance of the ApiGetUserIdRequest to be used for the API call.
func (c *APIClient) NewApiGetUserIdRequest(userID string) ApiGetUserIdRequest {
	return ApiGetUserIdRequest{
		userID: userID,
	}
}

/*
GetUserId Get userID. Wraps GetUserIdWithContext using context.Background.

Returns the userID data stored in the mapping.
Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.

Request can be constructed by NewApiGetUserIdRequest with parameters below.

	@param userID string - userID to assign.
	@return UserId
*/
func (c *APIClient) GetUserId(r ApiGetUserIdRequest, opts ...Option) (*UserId, error) {
	return c.GetUserIdWithContext(context.Background(), r, opts...)
}

/*
GetUserId Get userID.

Returns the userID data stored in the mapping.
Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.

Request can be constructed by NewApiGetUserIdRequest with parameters below.

	@param userID string - userID to assign.
	@return UserId
*/
func (c *APIClient) GetUserIdWithContext(ctx context.Context, r ApiGetUserIdRequest, opts ...Option) (*UserId, error) {
	var (
		postBody    any
		returnValue *UserId
	)

	requestPath := "/1/clusters/mapping/{userID}"
	requestPath = strings.Replace(requestPath, "{"+"userID"+"}", url.PathEscape(parameterToString(r.userID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiHasPendingMappingsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["getClusters"]; ok {
		err = json.Unmarshal(v, &r.getClusters)
		if err != nil {
			err = json.Unmarshal(b, &r.getClusters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiHasPendingMappingsRequest represents the request with all the parameters for the API call.
type ApiHasPendingMappingsRequest struct {
	getClusters bool
}

// NewApiHasPendingMappingsRequest creates an instance of the ApiHasPendingMappingsRequest to be used for the API call.
func (c *APIClient) NewApiHasPendingMappingsRequest() ApiHasPendingMappingsRequest {
	return ApiHasPendingMappingsRequest{}
}

// WithGetClusters adds the getClusters to the ApiHasPendingMappingsRequest and returns the request for chaining.
func (r ApiHasPendingMappingsRequest) WithGetClusters(getClusters bool) ApiHasPendingMappingsRequest {
	r.getClusters = getClusters
	return r
}

/*
HasPendingMappings Get migration and user mapping status. Wraps HasPendingMappingsWithContext using context.Background.

To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.

Request can be constructed by NewApiHasPendingMappingsRequest with parameters below.

	@param getClusters bool - Indicates whether to include the cluster's pending mapping state in the response.
	@return HasPendingMappingsResponse
*/
func (c *APIClient) HasPendingMappings(r ApiHasPendingMappingsRequest, opts ...Option) (*HasPendingMappingsResponse, error) {
	return c.HasPendingMappingsWithContext(context.Background(), r, opts...)
}

/*
HasPendingMappings Get migration and user mapping status.

To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.

Request can be constructed by NewApiHasPendingMappingsRequest with parameters below.

	@param getClusters bool - Indicates whether to include the cluster's pending mapping state in the response.
	@return HasPendingMappingsResponse
*/
func (c *APIClient) HasPendingMappingsWithContext(ctx context.Context, r ApiHasPendingMappingsRequest, opts ...Option) (*HasPendingMappingsResponse, error) {
	var (
		postBody    any
		returnValue *HasPendingMappingsResponse
	)

	requestPath := "/1/clusters/mapping/pending"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.getClusters) {
		queryParams.Set("getClusters", parameterToString(r.getClusters))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
ListApiKeys List API keys. Wraps ListApiKeysWithContext using context.Background.

List all API keys associated with your Algolia application, including their permissions and restrictions.

Request can be constructed by NewApiListApiKeysRequest with parameters below.

	@return ListApiKeysResponse
*/
func (c *APIClient) ListApiKeys(opts ...Option) (*ListApiKeysResponse, error) {
	return c.ListApiKeysWithContext(context.Background(), opts...)
}

/*
ListApiKeys List API keys.

List all API keys associated with your Algolia application, including their permissions and restrictions.

Request can be constructed by NewApiListApiKeysRequest with parameters below.

	@return ListApiKeysResponse
*/
func (c *APIClient) ListApiKeysWithContext(ctx context.Context, opts ...Option) (*ListApiKeysResponse, error) {
	var (
		postBody    any
		returnValue *ListApiKeysResponse
	)

	requestPath := "/1/keys"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
ListClusters List clusters. Wraps ListClustersWithContext using context.Background.

List the available clusters in a multi-cluster setup.

Request can be constructed by NewApiListClustersRequest with parameters below.

	@return ListClustersResponse
*/
func (c *APIClient) ListClusters(opts ...Option) (*ListClustersResponse, error) {
	return c.ListClustersWithContext(context.Background(), opts...)
}

/*
ListClusters List clusters.

List the available clusters in a multi-cluster setup.

Request can be constructed by NewApiListClustersRequest with parameters below.

	@return ListClustersResponse
*/
func (c *APIClient) ListClustersWithContext(ctx context.Context, opts ...Option) (*ListClustersResponse, error) {
	var (
		postBody    any
		returnValue *ListClustersResponse
	)

	requestPath := "/1/clusters"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListIndicesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["hitsPerPage"]; ok {
		err = json.Unmarshal(v, &r.hitsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.hitsPerPage)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiListIndicesRequest represents the request with all the parameters for the API call.
type ApiListIndicesRequest struct {
	page        int32
	hitsPerPage int32
}

// NewApiListIndicesRequest creates an instance of the ApiListIndicesRequest to be used for the API call.
func (c *APIClient) NewApiListIndicesRequest() ApiListIndicesRequest {
	return ApiListIndicesRequest{}
}

// WithPage adds the page to the ApiListIndicesRequest and returns the request for chaining.
func (r ApiListIndicesRequest) WithPage(page int32) ApiListIndicesRequest {
	r.page = page
	return r
}

// WithHitsPerPage adds the hitsPerPage to the ApiListIndicesRequest and returns the request for chaining.
func (r ApiListIndicesRequest) WithHitsPerPage(hitsPerPage int32) ApiListIndicesRequest {
	r.hitsPerPage = hitsPerPage
	return r
}

/*
ListIndices List indices. Wraps ListIndicesWithContext using context.Background.

List indices in an Algolia application.

Request can be constructed by NewApiListIndicesRequest with parameters below.

	@param page int32 - Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
	@param hitsPerPage int32 - Maximum number of hits per page.
	@return ListIndicesResponse
*/
func (c *APIClient) ListIndices(r ApiListIndicesRequest, opts ...Option) (*ListIndicesResponse, error) {
	return c.ListIndicesWithContext(context.Background(), r, opts...)
}

/*
ListIndices List indices.

List indices in an Algolia application.

Request can be constructed by NewApiListIndicesRequest with parameters below.

	@param page int32 - Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
	@param hitsPerPage int32 - Maximum number of hits per page.
	@return ListIndicesResponse
*/
func (c *APIClient) ListIndicesWithContext(ctx context.Context, r ApiListIndicesRequest, opts ...Option) (*ListIndicesResponse, error) {
	var (
		postBody    any
		returnValue *ListIndicesResponse
	)

	requestPath := "/1/indexes"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.page) {
		queryParams.Set("page", parameterToString(r.page))
	}
	if !isNilorEmpty(r.hitsPerPage) {
		queryParams.Set("hitsPerPage", parameterToString(r.hitsPerPage))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListUserIdsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["hitsPerPage"]; ok {
		err = json.Unmarshal(v, &r.hitsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.hitsPerPage)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiListUserIdsRequest represents the request with all the parameters for the API call.
type ApiListUserIdsRequest struct {
	page        int32
	hitsPerPage int32
}

// NewApiListUserIdsRequest creates an instance of the ApiListUserIdsRequest to be used for the API call.
func (c *APIClient) NewApiListUserIdsRequest() ApiListUserIdsRequest {
	return ApiListUserIdsRequest{}
}

// WithPage adds the page to the ApiListUserIdsRequest and returns the request for chaining.
func (r ApiListUserIdsRequest) WithPage(page int32) ApiListUserIdsRequest {
	r.page = page
	return r
}

// WithHitsPerPage adds the hitsPerPage to the ApiListUserIdsRequest and returns the request for chaining.
func (r ApiListUserIdsRequest) WithHitsPerPage(hitsPerPage int32) ApiListUserIdsRequest {
	r.hitsPerPage = hitsPerPage
	return r
}

/*
ListUserIds List userIDs. Wraps ListUserIdsWithContext using context.Background.

List the userIDs assigned to a multi-cluster application.
Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.

Request can be constructed by NewApiListUserIdsRequest with parameters below.

	@param page int32 - Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
	@param hitsPerPage int32 - Maximum number of hits per page.
	@return ListUserIdsResponse
*/
func (c *APIClient) ListUserIds(r ApiListUserIdsRequest, opts ...Option) (*ListUserIdsResponse, error) {
	return c.ListUserIdsWithContext(context.Background(), r, opts...)
}

/*
ListUserIds List userIDs.

List the userIDs assigned to a multi-cluster application.
Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.

Request can be constructed by NewApiListUserIdsRequest with parameters below.

	@param page int32 - Returns the requested page number. The page size is determined by the `hitsPerPage` parameter. You can see the number of available pages in the `nbPages` response attribute. When `page` is null, the API response is not paginated.
	@param hitsPerPage int32 - Maximum number of hits per page.
	@return ListUserIdsResponse
*/
func (c *APIClient) ListUserIdsWithContext(ctx context.Context, r ApiListUserIdsRequest, opts ...Option) (*ListUserIdsResponse, error) {
	var (
		postBody    any
		returnValue *ListUserIdsResponse
	)

	requestPath := "/1/clusters/mapping"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.page) {
		queryParams.Set("page", parameterToString(r.page))
	}
	if !isNilorEmpty(r.hitsPerPage) {
		queryParams.Set("hitsPerPage", parameterToString(r.hitsPerPage))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiMultipleBatchRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["batchParams"]; ok {
		err = json.Unmarshal(v, &r.batchParams)
		if err != nil {
			err = json.Unmarshal(b, &r.batchParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.batchParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiMultipleBatchRequest represents the request with all the parameters for the API call.
type ApiMultipleBatchRequest struct {
	batchParams *BatchParams
}

// NewApiMultipleBatchRequest creates an instance of the ApiMultipleBatchRequest to be used for the API call.
func (c *APIClient) NewApiMultipleBatchRequest(batchParams *BatchParams) ApiMultipleBatchRequest {
	return ApiMultipleBatchRequest{
		batchParams: batchParams,
	}
}

/*
MultipleBatch Batch write operations on multiple indices. Wraps MultipleBatchWithContext using context.Background.

To reduce the time spent on network round trips, you can perform several write actions in a single request. It's a multi-index version of the [`batch` operation](#tag/Records/operation/batch). Actions are applied in the order they are specified.
The supported actions are equivalent to the individual operations of the same name.

Request can be constructed by NewApiMultipleBatchRequest with parameters below.

	@param batchParams BatchParams
	@return MultipleBatchResponse
*/
func (c *APIClient) MultipleBatch(r ApiMultipleBatchRequest, opts ...Option) (*MultipleBatchResponse, error) {
	return c.MultipleBatchWithContext(context.Background(), r, opts...)
}

/*
MultipleBatch Batch write operations on multiple indices.

To reduce the time spent on network round trips, you can perform several write actions in a single request. It's a multi-index version of the [`batch` operation](#tag/Records/operation/batch). Actions are applied in the order they are specified.
The supported actions are equivalent to the individual operations of the same name.

Request can be constructed by NewApiMultipleBatchRequest with parameters below.

	@param batchParams BatchParams
	@return MultipleBatchResponse
*/
func (c *APIClient) MultipleBatchWithContext(ctx context.Context, r ApiMultipleBatchRequest, opts ...Option) (*MultipleBatchResponse, error) {
	var (
		postBody    any
		returnValue *MultipleBatchResponse
	)

	requestPath := "/1/indexes/*/batch"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.batchParams == nil {
		return returnValue, reportError("batchParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.batchParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiOperationIndexRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["operationIndexParams"]; ok {
		err = json.Unmarshal(v, &r.operationIndexParams)
		if err != nil {
			err = json.Unmarshal(b, &r.operationIndexParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.operationIndexParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiOperationIndexRequest represents the request with all the parameters for the API call.
type ApiOperationIndexRequest struct {
	indexName            string
	operationIndexParams *OperationIndexParams
}

// NewApiOperationIndexRequest creates an instance of the ApiOperationIndexRequest to be used for the API call.
func (c *APIClient) NewApiOperationIndexRequest(indexName string, operationIndexParams *OperationIndexParams) ApiOperationIndexRequest {
	return ApiOperationIndexRequest{
		indexName:            indexName,
		operationIndexParams: operationIndexParams,
	}
}

/*
OperationIndex Copy, move, or rename an index. Wraps OperationIndexWithContext using context.Background.

This `operation`, _copy_ or _move_, will copy or move a source index's (`IndexName`) records, settings, synonyms, and rules to a `destination` index.
If the destination index exists, it will be replaced, except for index-specific API keys and analytics data.
If the destination index doesn't exist, it will be created.

The choice between moving or copying an index depends on your needs. Choose:

- **Move** to rename an index.
- **Copy** to create a new index with the same records and configuration as an existing one.

> **Note**: When considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits) on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).

Request can be constructed by NewApiOperationIndexRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param operationIndexParams OperationIndexParams
	@return UpdatedAtResponse
*/
func (c *APIClient) OperationIndex(r ApiOperationIndexRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.OperationIndexWithContext(context.Background(), r, opts...)
}

/*
OperationIndex Copy, move, or rename an index.

This `operation`, _copy_ or _move_, will copy or move a source index's (`IndexName`) records, settings, synonyms, and rules to a `destination` index.
If the destination index exists, it will be replaced, except for index-specific API keys and analytics data.
If the destination index doesn't exist, it will be created.

The choice between moving or copying an index depends on your needs. Choose:

- **Move** to rename an index.
- **Copy** to create a new index with the same records and configuration as an existing one.

> **Note**: When considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits) on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).

Request can be constructed by NewApiOperationIndexRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param operationIndexParams OperationIndexParams
	@return UpdatedAtResponse
*/
func (c *APIClient) OperationIndexWithContext(ctx context.Context, r ApiOperationIndexRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/operation"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.operationIndexParams == nil {
		return returnValue, reportError("operationIndexParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.operationIndexParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPartialUpdateObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["attributesToUpdate"]; ok {
		err = json.Unmarshal(v, &r.attributesToUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.attributesToUpdate)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.attributesToUpdate)
		if err != nil {
			return err
		}
	}
	if v, ok := req["createIfNotExists"]; ok {
		err = json.Unmarshal(v, &r.createIfNotExists)
		if err != nil {
			err = json.Unmarshal(b, &r.createIfNotExists)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiPartialUpdateObjectRequest represents the request with all the parameters for the API call.
type ApiPartialUpdateObjectRequest struct {
	indexName          string
	objectID           string
	attributesToUpdate *map[string]AttributeToUpdate
	createIfNotExists  bool
}

// NewApiPartialUpdateObjectRequest creates an instance of the ApiPartialUpdateObjectRequest to be used for the API call.
func (c *APIClient) NewApiPartialUpdateObjectRequest(indexName string, objectID string, attributesToUpdate *map[string]AttributeToUpdate) ApiPartialUpdateObjectRequest {
	return ApiPartialUpdateObjectRequest{
		indexName:          indexName,
		objectID:           objectID,
		attributesToUpdate: attributesToUpdate,
	}
}

// WithCreateIfNotExists adds the createIfNotExists to the ApiPartialUpdateObjectRequest and returns the request for chaining.
func (r ApiPartialUpdateObjectRequest) WithCreateIfNotExists(createIfNotExists bool) ApiPartialUpdateObjectRequest {
	r.createIfNotExists = createIfNotExists
	return r
}

/*
PartialUpdateObject Update record attributes. Wraps PartialUpdateObjectWithContext using context.Background.

Add new attributes or update current ones in an existing record.
You can use any first-level attribute but not nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/), the engine treats it as a replacement for its first-level ancestor.

Request can be constructed by NewApiPartialUpdateObjectRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique record (object) identifier.
	@param attributesToUpdate map[string]AttributeToUpdate - Object with attributes to update.
	@param createIfNotExists bool - Indicates whether to create a new record if it doesn't exist yet.
	@return UpdatedAtWithObjectIdResponse
*/
func (c *APIClient) PartialUpdateObject(r ApiPartialUpdateObjectRequest, opts ...Option) (*UpdatedAtWithObjectIdResponse, error) {
	return c.PartialUpdateObjectWithContext(context.Background(), r, opts...)
}

/*
PartialUpdateObject Update record attributes.

Add new attributes or update current ones in an existing record.
You can use any first-level attribute but not nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/), the engine treats it as a replacement for its first-level ancestor.

Request can be constructed by NewApiPartialUpdateObjectRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique record (object) identifier.
	@param attributesToUpdate map[string]AttributeToUpdate - Object with attributes to update.
	@param createIfNotExists bool - Indicates whether to create a new record if it doesn't exist yet.
	@return UpdatedAtWithObjectIdResponse
*/
func (c *APIClient) PartialUpdateObjectWithContext(ctx context.Context, r ApiPartialUpdateObjectRequest, opts ...Option) (*UpdatedAtWithObjectIdResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtWithObjectIdResponse
	)

	requestPath := "/1/indexes/{indexName}/{objectID}/partial"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.attributesToUpdate == nil {
		return returnValue, reportError("attributesToUpdate is required and must be specified")
	}

	if !isNilorEmpty(r.createIfNotExists) {
		queryParams.Set("createIfNotExists", parameterToString(r.createIfNotExists))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.attributesToUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiPostRequest represents the request with all the parameters for the API call.
type ApiPostRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiPostRequest creates an instance of the ApiPostRequest to be used for the API call.
func (c *APIClient) NewApiPostRequest(path string) ApiPostRequest {
	return ApiPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiPostRequest and returns the request for chaining.
func (r ApiPostRequest) WithParameters(parameters map[string]interface{}) ApiPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiPostRequest and returns the request for chaining.
func (r ApiPostRequest) WithBody(body map[string]interface{}) ApiPostRequest {
	r.body = body
	return r
}

/*
Post Send requests to the Algolia REST API. Wraps PostWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) Post(r ApiPostRequest, opts ...Option) (map[string]interface{}, error) {
	return c.PostWithContext(context.Background(), r, opts...)
}

/*
Post Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) PostWithContext(ctx context.Context, r ApiPostRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiPutRequest represents the request with all the parameters for the API call.
type ApiPutRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiPutRequest creates an instance of the ApiPutRequest to be used for the API call.
func (c *APIClient) NewApiPutRequest(path string) ApiPutRequest {
	return ApiPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiPutRequest and returns the request for chaining.
func (r ApiPutRequest) WithParameters(parameters map[string]interface{}) ApiPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiPutRequest and returns the request for chaining.
func (r ApiPutRequest) WithBody(body map[string]interface{}) ApiPutRequest {
	r.body = body
	return r
}

/*
Put Send requests to the Algolia REST API. Wraps PutWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) Put(r ApiPutRequest, opts ...Option) (map[string]interface{}, error) {
	return c.PutWithContext(context.Background(), r, opts...)
}

/*
Put Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) PutWithContext(ctx context.Context, r ApiPutRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRemoveUserIdRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["userID"]; ok {
		err = json.Unmarshal(v, &r.userID)
		if err != nil {
			err = json.Unmarshal(b, &r.userID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiRemoveUserIdRequest represents the request with all the parameters for the API call.
type ApiRemoveUserIdRequest struct {
	userID string
}

// NewApiRemoveUserIdRequest creates an instance of the ApiRemoveUserIdRequest to be used for the API call.
func (c *APIClient) NewApiRemoveUserIdRequest(userID string) ApiRemoveUserIdRequest {
	return ApiRemoveUserIdRequest{
		userID: userID,
	}
}

/*
RemoveUserId Remove userID. Wraps RemoveUserIdWithContext using context.Background.

Remove a userID and its associated data from the multi-clusters.

Request can be constructed by NewApiRemoveUserIdRequest with parameters below.

	@param userID string - userID to assign.
	@return RemoveUserIdResponse
*/
func (c *APIClient) RemoveUserId(r ApiRemoveUserIdRequest, opts ...Option) (*RemoveUserIdResponse, error) {
	return c.RemoveUserIdWithContext(context.Background(), r, opts...)
}

/*
RemoveUserId Remove userID.

Remove a userID and its associated data from the multi-clusters.

Request can be constructed by NewApiRemoveUserIdRequest with parameters below.

	@param userID string - userID to assign.
	@return RemoveUserIdResponse
*/
func (c *APIClient) RemoveUserIdWithContext(ctx context.Context, r ApiRemoveUserIdRequest, opts ...Option) (*RemoveUserIdResponse, error) {
	var (
		postBody    any
		returnValue *RemoveUserIdResponse
	)

	requestPath := "/1/clusters/mapping/{userID}"
	requestPath = strings.Replace(requestPath, "{"+"userID"+"}", url.PathEscape(parameterToString(r.userID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiReplaceSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["source"]; ok {
		err = json.Unmarshal(v, &r.source)
		if err != nil {
			err = json.Unmarshal(b, &r.source)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.source)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiReplaceSourcesRequest represents the request with all the parameters for the API call.
type ApiReplaceSourcesRequest struct {
	source []Source
}

// NewApiReplaceSourcesRequest creates an instance of the ApiReplaceSourcesRequest to be used for the API call.
func (c *APIClient) NewApiReplaceSourcesRequest(source []Source) ApiReplaceSourcesRequest {
	return ApiReplaceSourcesRequest{
		source: source,
	}
}

/*
ReplaceSources Replace all sources. Wraps ReplaceSourcesWithContext using context.Background.

Replace all allowed sources.

Request can be constructed by NewApiReplaceSourcesRequest with parameters below.

	@param source []Source - Allowed sources.
	@return ReplaceSourceResponse
*/
func (c *APIClient) ReplaceSources(r ApiReplaceSourcesRequest, opts ...Option) (*ReplaceSourceResponse, error) {
	return c.ReplaceSourcesWithContext(context.Background(), r, opts...)
}

/*
ReplaceSources Replace all sources.

Replace all allowed sources.

Request can be constructed by NewApiReplaceSourcesRequest with parameters below.

	@param source []Source - Allowed sources.
	@return ReplaceSourceResponse
*/
func (c *APIClient) ReplaceSourcesWithContext(ctx context.Context, r ApiReplaceSourcesRequest, opts ...Option) (*ReplaceSourceResponse, error) {
	var (
		postBody    any
		returnValue *ReplaceSourceResponse
	)

	requestPath := "/1/security/sources"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.source == nil {
		return returnValue, reportError("source is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.source
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRestoreApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["key"]; ok {
		err = json.Unmarshal(v, &r.key)
		if err != nil {
			err = json.Unmarshal(b, &r.key)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiRestoreApiKeyRequest represents the request with all the parameters for the API call.
type ApiRestoreApiKeyRequest struct {
	key string
}

// NewApiRestoreApiKeyRequest creates an instance of the ApiRestoreApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiRestoreApiKeyRequest(key string) ApiRestoreApiKeyRequest {
	return ApiRestoreApiKeyRequest{
		key: key,
	}
}

/*
RestoreApiKey Restore API key. Wraps RestoreApiKeyWithContext using context.Background.

Restore a deleted API key, along with its associated permissions.
The request must be authenticated with the admin API key.

Request can be constructed by NewApiRestoreApiKeyRequest with parameters below.

	@param key string - API key.
	@return AddApiKeyResponse
*/
func (c *APIClient) RestoreApiKey(r ApiRestoreApiKeyRequest, opts ...Option) (*AddApiKeyResponse, error) {
	return c.RestoreApiKeyWithContext(context.Background(), r, opts...)
}

/*
RestoreApiKey Restore API key.

Restore a deleted API key, along with its associated permissions.
The request must be authenticated with the admin API key.

Request can be constructed by NewApiRestoreApiKeyRequest with parameters below.

	@param key string - API key.
	@return AddApiKeyResponse
*/
func (c *APIClient) RestoreApiKeyWithContext(ctx context.Context, r ApiRestoreApiKeyRequest, opts ...Option) (*AddApiKeyResponse, error) {
	var (
		postBody    any
		returnValue *AddApiKeyResponse
	)

	requestPath := "/1/keys/{key}/restore"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(parameterToString(r.key)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.body)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSaveObjectRequest represents the request with all the parameters for the API call.
type ApiSaveObjectRequest struct {
	indexName string
	body      map[string]interface{}
}

// NewApiSaveObjectRequest creates an instance of the ApiSaveObjectRequest to be used for the API call.
func (c *APIClient) NewApiSaveObjectRequest(indexName string, body map[string]interface{}) ApiSaveObjectRequest {
	return ApiSaveObjectRequest{
		indexName: indexName,
		body:      body,
	}
}

/*
SaveObject Add or update a record. Wraps SaveObjectWithContext using context.Background.

Add a record (object) to an index or replace it.
If the record doesn't contain an `objectID`, Algolia automatically adds it.
If you use an existing `objectID`, the existing record is replaced with the new one.
To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).

Request can be constructed by NewApiSaveObjectRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param body map[string]interface{} - The Algolia record.
	@return SaveObjectResponse
*/
func (c *APIClient) SaveObject(r ApiSaveObjectRequest, opts ...Option) (*SaveObjectResponse, error) {
	return c.SaveObjectWithContext(context.Background(), r, opts...)
}

/*
SaveObject Add or update a record.

Add a record (object) to an index or replace it.
If the record doesn't contain an `objectID`, Algolia automatically adds it.
If you use an existing `objectID`, the existing record is replaced with the new one.
To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).

Request can be constructed by NewApiSaveObjectRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param body map[string]interface{} - The Algolia record.
	@return SaveObjectResponse
*/
func (c *APIClient) SaveObjectWithContext(ctx context.Context, r ApiSaveObjectRequest, opts ...Option) (*SaveObjectResponse, error) {
	var (
		postBody    any
		returnValue *SaveObjectResponse
	)

	requestPath := "/1/indexes/{indexName}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.body
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["rule"]; ok {
		err = json.Unmarshal(v, &r.rule)
		if err != nil {
			err = json.Unmarshal(b, &r.rule)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.rule)
		if err != nil {
			return err
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSaveRuleRequest represents the request with all the parameters for the API call.
type ApiSaveRuleRequest struct {
	indexName         string
	objectID          string
	rule              *Rule
	forwardToReplicas bool
}

// NewApiSaveRuleRequest creates an instance of the ApiSaveRuleRequest to be used for the API call.
func (c *APIClient) NewApiSaveRuleRequest(indexName string, objectID string, rule *Rule) ApiSaveRuleRequest {
	return ApiSaveRuleRequest{
		indexName: indexName,
		objectID:  objectID,
		rule:      rule,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSaveRuleRequest and returns the request for chaining.
func (r ApiSaveRuleRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSaveRuleRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
SaveRule Create or update a rule. Wraps SaveRuleWithContext using context.Background.

To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).

Request can be constructed by NewApiSaveRuleRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique identifier of a rule object.
	@param rule Rule
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return UpdatedRuleResponse
*/
func (c *APIClient) SaveRule(r ApiSaveRuleRequest, opts ...Option) (*UpdatedRuleResponse, error) {
	return c.SaveRuleWithContext(context.Background(), r, opts...)
}

/*
SaveRule Create or update a rule.

To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).

Request can be constructed by NewApiSaveRuleRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique identifier of a rule object.
	@param rule Rule
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return UpdatedRuleResponse
*/
func (c *APIClient) SaveRuleWithContext(ctx context.Context, r ApiSaveRuleRequest, opts ...Option) (*UpdatedRuleResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedRuleResponse
	)

	requestPath := "/1/indexes/{indexName}/rules/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.rule == nil {
		return returnValue, reportError("rule is required and must be specified")
	}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.rule
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveRulesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["rules"]; ok {
		err = json.Unmarshal(v, &r.rules)
		if err != nil {
			err = json.Unmarshal(b, &r.rules)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.rules)
		if err != nil {
			return err
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["clearExistingRules"]; ok {
		err = json.Unmarshal(v, &r.clearExistingRules)
		if err != nil {
			err = json.Unmarshal(b, &r.clearExistingRules)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSaveRulesRequest represents the request with all the parameters for the API call.
type ApiSaveRulesRequest struct {
	indexName          string
	rules              []Rule
	forwardToReplicas  bool
	clearExistingRules bool
}

// NewApiSaveRulesRequest creates an instance of the ApiSaveRulesRequest to be used for the API call.
func (c *APIClient) NewApiSaveRulesRequest(indexName string, rules []Rule) ApiSaveRulesRequest {
	return ApiSaveRulesRequest{
		indexName: indexName,
		rules:     rules,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSaveRulesRequest and returns the request for chaining.
func (r ApiSaveRulesRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSaveRulesRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

// WithClearExistingRules adds the clearExistingRules to the ApiSaveRulesRequest and returns the request for chaining.
func (r ApiSaveRulesRequest) WithClearExistingRules(clearExistingRules bool) ApiSaveRulesRequest {
	r.clearExistingRules = clearExistingRules
	return r
}

/*
SaveRules Save a batch of rules. Wraps SaveRulesWithContext using context.Background.

Create or update multiple rules.

Request can be constructed by NewApiSaveRulesRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param rules []Rule
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@param clearExistingRules bool - Indicates whether existing rules should be deleted before adding this batch.
	@return UpdatedAtResponse
*/
func (c *APIClient) SaveRules(r ApiSaveRulesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SaveRulesWithContext(context.Background(), r, opts...)
}

/*
SaveRules Save a batch of rules.

Create or update multiple rules.

Request can be constructed by NewApiSaveRulesRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param rules []Rule
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@param clearExistingRules bool - Indicates whether existing rules should be deleted before adding this batch.
	@return UpdatedAtResponse
*/
func (c *APIClient) SaveRulesWithContext(ctx context.Context, r ApiSaveRulesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/rules/batch"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.rules == nil {
		return returnValue, reportError("rules is required and must be specified")
	}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}
	if !isNilorEmpty(r.clearExistingRules) {
		queryParams.Set("clearExistingRules", parameterToString(r.clearExistingRules))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.rules
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveSynonymRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["synonymHit"]; ok {
		err = json.Unmarshal(v, &r.synonymHit)
		if err != nil {
			err = json.Unmarshal(b, &r.synonymHit)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.synonymHit)
		if err != nil {
			return err
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSaveSynonymRequest represents the request with all the parameters for the API call.
type ApiSaveSynonymRequest struct {
	indexName         string
	objectID          string
	synonymHit        *SynonymHit
	forwardToReplicas bool
}

// NewApiSaveSynonymRequest creates an instance of the ApiSaveSynonymRequest to be used for the API call.
func (c *APIClient) NewApiSaveSynonymRequest(indexName string, objectID string, synonymHit *SynonymHit) ApiSaveSynonymRequest {
	return ApiSaveSynonymRequest{
		indexName:  indexName,
		objectID:   objectID,
		synonymHit: synonymHit,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSaveSynonymRequest and returns the request for chaining.
func (r ApiSaveSynonymRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSaveSynonymRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
SaveSynonym Save a synonym. Wraps SaveSynonymWithContext using context.Background.

Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms) to an index or replace it.
If the synonym `objectID` doesn't exist, Algolia adds a new one.
If you use an existing synonym `objectID`, the existing synonym is replaced with the new one.
To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).

Request can be constructed by NewApiSaveSynonymRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique identifier of a synonym object.
	@param synonymHit SynonymHit
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return SaveSynonymResponse
*/
func (c *APIClient) SaveSynonym(r ApiSaveSynonymRequest, opts ...Option) (*SaveSynonymResponse, error) {
	return c.SaveSynonymWithContext(context.Background(), r, opts...)
}

/*
SaveSynonym Save a synonym.

Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms) to an index or replace it.
If the synonym `objectID` doesn't exist, Algolia adds a new one.
If you use an existing synonym `objectID`, the existing synonym is replaced with the new one.
To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).

Request can be constructed by NewApiSaveSynonymRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param objectID string - Unique identifier of a synonym object.
	@param synonymHit SynonymHit
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return SaveSynonymResponse
*/
func (c *APIClient) SaveSynonymWithContext(ctx context.Context, r ApiSaveSynonymRequest, opts ...Option) (*SaveSynonymResponse, error) {
	var (
		postBody    any
		returnValue *SaveSynonymResponse
	)

	requestPath := "/1/indexes/{indexName}/synonyms/{objectID}"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"objectID"+"}", url.PathEscape(parameterToString(r.objectID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.synonymHit == nil {
		return returnValue, reportError("synonymHit is required and must be specified")
	}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.synonymHit
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveSynonymsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["synonymHit"]; ok {
		err = json.Unmarshal(v, &r.synonymHit)
		if err != nil {
			err = json.Unmarshal(b, &r.synonymHit)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.synonymHit)
		if err != nil {
			return err
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["replaceExistingSynonyms"]; ok {
		err = json.Unmarshal(v, &r.replaceExistingSynonyms)
		if err != nil {
			err = json.Unmarshal(b, &r.replaceExistingSynonyms)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSaveSynonymsRequest represents the request with all the parameters for the API call.
type ApiSaveSynonymsRequest struct {
	indexName               string
	synonymHit              []SynonymHit
	forwardToReplicas       bool
	replaceExistingSynonyms bool
}

// NewApiSaveSynonymsRequest creates an instance of the ApiSaveSynonymsRequest to be used for the API call.
func (c *APIClient) NewApiSaveSynonymsRequest(indexName string, synonymHit []SynonymHit) ApiSaveSynonymsRequest {
	return ApiSaveSynonymsRequest{
		indexName:  indexName,
		synonymHit: synonymHit,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSaveSynonymsRequest and returns the request for chaining.
func (r ApiSaveSynonymsRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSaveSynonymsRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

// WithReplaceExistingSynonyms adds the replaceExistingSynonyms to the ApiSaveSynonymsRequest and returns the request for chaining.
func (r ApiSaveSynonymsRequest) WithReplaceExistingSynonyms(replaceExistingSynonyms bool) ApiSaveSynonymsRequest {
	r.replaceExistingSynonyms = replaceExistingSynonyms
	return r
}

/*
SaveSynonyms Save a batch of synonyms. Wraps SaveSynonymsWithContext using context.Background.

Create or update multiple synonyms.

Request can be constructed by NewApiSaveSynonymsRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param synonymHit []SynonymHit
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@param replaceExistingSynonyms bool - Indicates whether to replace all synonyms in the index with the ones sent with this request.
	@return UpdatedAtResponse
*/
func (c *APIClient) SaveSynonyms(r ApiSaveSynonymsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SaveSynonymsWithContext(context.Background(), r, opts...)
}

/*
SaveSynonyms Save a batch of synonyms.

Create or update multiple synonyms.

Request can be constructed by NewApiSaveSynonymsRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param synonymHit []SynonymHit
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@param replaceExistingSynonyms bool - Indicates whether to replace all synonyms in the index with the ones sent with this request.
	@return UpdatedAtResponse
*/
func (c *APIClient) SaveSynonymsWithContext(ctx context.Context, r ApiSaveSynonymsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/synonyms/batch"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.synonymHit == nil {
		return returnValue, reportError("synonymHit is required and must be specified")
	}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}
	if !isNilorEmpty(r.replaceExistingSynonyms) {
		queryParams.Set("replaceExistingSynonyms", parameterToString(r.replaceExistingSynonyms))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.synonymHit
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["searchMethodParams"]; ok {
		err = json.Unmarshal(v, &r.searchMethodParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchMethodParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.searchMethodParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSearchRequest represents the request with all the parameters for the API call.
type ApiSearchRequest struct {
	searchMethodParams *SearchMethodParams
}

// NewApiSearchRequest creates an instance of the ApiSearchRequest to be used for the API call.
func (c *APIClient) NewApiSearchRequest(searchMethodParams *SearchMethodParams) ApiSearchRequest {
	return ApiSearchRequest{
		searchMethodParams: searchMethodParams,
	}
}

/*
Search Search multiple indices. Wraps SearchWithContext using context.Background.

Send multiple search queries to one or more indices.

Request can be constructed by NewApiSearchRequest with parameters below.

	@param searchMethodParams SearchMethodParams - Query requests and strategies. Results will be received in the same order as the queries.
	@return SearchResponses
*/
func (c *APIClient) Search(r ApiSearchRequest, opts ...Option) (*SearchResponses, error) {
	return c.SearchWithContext(context.Background(), r, opts...)
}

/*
Search Search multiple indices.

Send multiple search queries to one or more indices.

Request can be constructed by NewApiSearchRequest with parameters below.

	@param searchMethodParams SearchMethodParams - Query requests and strategies. Results will be received in the same order as the queries.
	@return SearchResponses
*/
func (c *APIClient) SearchWithContext(ctx context.Context, r ApiSearchRequest, opts ...Option) (*SearchResponses, error) {
	var (
		postBody    any
		returnValue *SearchResponses
	)

	requestPath := "/1/indexes/*/queries"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.searchMethodParams == nil {
		return returnValue, reportError("searchMethodParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.searchMethodParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchDictionaryEntriesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["dictionaryName"]; ok {
		err = json.Unmarshal(v, &r.dictionaryName)
		if err != nil {
			err = json.Unmarshal(b, &r.dictionaryName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["searchDictionaryEntriesParams"]; ok {
		err = json.Unmarshal(v, &r.searchDictionaryEntriesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchDictionaryEntriesParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.searchDictionaryEntriesParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSearchDictionaryEntriesRequest represents the request with all the parameters for the API call.
type ApiSearchDictionaryEntriesRequest struct {
	dictionaryName                DictionaryType
	searchDictionaryEntriesParams *SearchDictionaryEntriesParams
}

// NewApiSearchDictionaryEntriesRequest creates an instance of the ApiSearchDictionaryEntriesRequest to be used for the API call.
func (c *APIClient) NewApiSearchDictionaryEntriesRequest(dictionaryName DictionaryType, searchDictionaryEntriesParams *SearchDictionaryEntriesParams) ApiSearchDictionaryEntriesRequest {
	return ApiSearchDictionaryEntriesRequest{
		dictionaryName:                dictionaryName,
		searchDictionaryEntriesParams: searchDictionaryEntriesParams,
	}
}

/*
SearchDictionaryEntries Search dictionary entries. Wraps SearchDictionaryEntriesWithContext using context.Background.

Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/) entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) dictionaries.

Request can be constructed by NewApiSearchDictionaryEntriesRequest with parameters below.

	@param dictionaryName DictionaryType - Dictionary to search in.
	@param searchDictionaryEntriesParams SearchDictionaryEntriesParams
	@return UpdatedAtResponse
*/
func (c *APIClient) SearchDictionaryEntries(r ApiSearchDictionaryEntriesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SearchDictionaryEntriesWithContext(context.Background(), r, opts...)
}

/*
SearchDictionaryEntries Search dictionary entries.

Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/) entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) dictionaries.

Request can be constructed by NewApiSearchDictionaryEntriesRequest with parameters below.

	@param dictionaryName DictionaryType - Dictionary to search in.
	@param searchDictionaryEntriesParams SearchDictionaryEntriesParams
	@return UpdatedAtResponse
*/
func (c *APIClient) SearchDictionaryEntriesWithContext(ctx context.Context, r ApiSearchDictionaryEntriesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/dictionaries/{dictionaryName}/search"
	requestPath = strings.Replace(requestPath, "{"+"dictionaryName"+"}", url.PathEscape(parameterToString(r.dictionaryName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.searchDictionaryEntriesParams == nil {
		return returnValue, reportError("searchDictionaryEntriesParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.searchDictionaryEntriesParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchForFacetValuesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["facetName"]; ok {
		err = json.Unmarshal(v, &r.facetName)
		if err != nil {
			err = json.Unmarshal(b, &r.facetName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["searchForFacetValuesRequest"]; ok {
		err = json.Unmarshal(v, &r.searchForFacetValuesRequest)
		if err != nil {
			err = json.Unmarshal(b, &r.searchForFacetValuesRequest)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSearchForFacetValuesRequest represents the request with all the parameters for the API call.
type ApiSearchForFacetValuesRequest struct {
	indexName                   string
	facetName                   string
	searchForFacetValuesRequest *SearchForFacetValuesRequest
}

// NewApiSearchForFacetValuesRequest creates an instance of the ApiSearchForFacetValuesRequest to be used for the API call.
func (c *APIClient) NewApiSearchForFacetValuesRequest(indexName string, facetName string) ApiSearchForFacetValuesRequest {
	return ApiSearchForFacetValuesRequest{
		indexName: indexName,
		facetName: facetName,
	}
}

// WithSearchForFacetValuesRequest adds the searchForFacetValuesRequest to the ApiSearchForFacetValuesRequest and returns the request for chaining.
func (r ApiSearchForFacetValuesRequest) WithSearchForFacetValuesRequest(searchForFacetValuesRequest *SearchForFacetValuesRequest) ApiSearchForFacetValuesRequest {
	r.searchForFacetValuesRequest = searchForFacetValuesRequest
	return r
}

/*
SearchForFacetValues Search for facet values. Wraps SearchForFacetValuesWithContext using context.Background.

[Search for a facet's values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values), optionally restricting the returned values to those contained in records matching other search criteria.
> **Note**: Pagination isn't supported (`page` and `hitsPerPage` are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with `maxFacetHits`.

Request can be constructed by NewApiSearchForFacetValuesRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param facetName string - Facet name.
	@param searchForFacetValuesRequest SearchForFacetValuesRequest
	@return SearchForFacetValuesResponse
*/
func (c *APIClient) SearchForFacetValues(r ApiSearchForFacetValuesRequest, opts ...Option) (*SearchForFacetValuesResponse, error) {
	return c.SearchForFacetValuesWithContext(context.Background(), r, opts...)
}

/*
SearchForFacetValues Search for facet values.

[Search for a facet's values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values), optionally restricting the returned values to those contained in records matching other search criteria.
> **Note**: Pagination isn't supported (`page` and `hitsPerPage` are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with `maxFacetHits`.

Request can be constructed by NewApiSearchForFacetValuesRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param facetName string - Facet name.
	@param searchForFacetValuesRequest SearchForFacetValuesRequest
	@return SearchForFacetValuesResponse
*/
func (c *APIClient) SearchForFacetValuesWithContext(ctx context.Context, r ApiSearchForFacetValuesRequest, opts ...Option) (*SearchForFacetValuesResponse, error) {
	var (
		postBody    any
		returnValue *SearchForFacetValuesResponse
	)

	requestPath := "/1/indexes/{indexName}/facets/{facetName}/query"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)
	requestPath = strings.Replace(requestPath, "{"+"facetName"+"}", url.PathEscape(parameterToString(r.facetName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.searchForFacetValuesRequest) {
		postBody = "{}"
	} else {
		postBody = r.searchForFacetValuesRequest
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchRulesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["searchRulesParams"]; ok {
		err = json.Unmarshal(v, &r.searchRulesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchRulesParams)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSearchRulesRequest represents the request with all the parameters for the API call.
type ApiSearchRulesRequest struct {
	indexName         string
	searchRulesParams *SearchRulesParams
}

// NewApiSearchRulesRequest creates an instance of the ApiSearchRulesRequest to be used for the API call.
func (c *APIClient) NewApiSearchRulesRequest(indexName string) ApiSearchRulesRequest {
	return ApiSearchRulesRequest{
		indexName: indexName,
	}
}

// WithSearchRulesParams adds the searchRulesParams to the ApiSearchRulesRequest and returns the request for chaining.
func (r ApiSearchRulesRequest) WithSearchRulesParams(searchRulesParams *SearchRulesParams) ApiSearchRulesRequest {
	r.searchRulesParams = searchRulesParams
	return r
}

/*
SearchRules Search for rules. Wraps SearchRulesWithContext using context.Background.

Search for rules in your index. You can control the search with parameters. To list all rules, send an empty request body.

Request can be constructed by NewApiSearchRulesRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param searchRulesParams SearchRulesParams
	@return SearchRulesResponse
*/
func (c *APIClient) SearchRules(r ApiSearchRulesRequest, opts ...Option) (*SearchRulesResponse, error) {
	return c.SearchRulesWithContext(context.Background(), r, opts...)
}

/*
SearchRules Search for rules.

Search for rules in your index. You can control the search with parameters. To list all rules, send an empty request body.

Request can be constructed by NewApiSearchRulesRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param searchRulesParams SearchRulesParams
	@return SearchRulesResponse
*/
func (c *APIClient) SearchRulesWithContext(ctx context.Context, r ApiSearchRulesRequest, opts ...Option) (*SearchRulesResponse, error) {
	var (
		postBody    any
		returnValue *SearchRulesResponse
	)

	requestPath := "/1/indexes/{indexName}/rules/search"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.searchRulesParams) {
		postBody = "{}"
	} else {
		postBody = r.searchRulesParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchSingleIndexRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["searchParams"]; ok {
		err = json.Unmarshal(v, &r.searchParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchParams)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSearchSingleIndexRequest represents the request with all the parameters for the API call.
type ApiSearchSingleIndexRequest struct {
	indexName    string
	searchParams *SearchParams
}

// NewApiSearchSingleIndexRequest creates an instance of the ApiSearchSingleIndexRequest to be used for the API call.
func (c *APIClient) NewApiSearchSingleIndexRequest(indexName string) ApiSearchSingleIndexRequest {
	return ApiSearchSingleIndexRequest{
		indexName: indexName,
	}
}

// WithSearchParams adds the searchParams to the ApiSearchSingleIndexRequest and returns the request for chaining.
func (r ApiSearchSingleIndexRequest) WithSearchParams(searchParams *SearchParams) ApiSearchSingleIndexRequest {
	r.searchParams = searchParams
	return r
}

/*
SearchSingleIndex Search an index. Wraps SearchSingleIndexWithContext using context.Background.

Return records that match the query.

Request can be constructed by NewApiSearchSingleIndexRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param searchParams SearchParams
	@return SearchResponse
*/
func (c *APIClient) SearchSingleIndex(r ApiSearchSingleIndexRequest, opts ...Option) (*SearchResponse, error) {
	return c.SearchSingleIndexWithContext(context.Background(), r, opts...)
}

/*
SearchSingleIndex Search an index.

Return records that match the query.

Request can be constructed by NewApiSearchSingleIndexRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param searchParams SearchParams
	@return SearchResponse
*/
func (c *APIClient) SearchSingleIndexWithContext(ctx context.Context, r ApiSearchSingleIndexRequest, opts ...Option) (*SearchResponse, error) {
	var (
		postBody    any
		returnValue *SearchResponse
	)

	requestPath := "/1/indexes/{indexName}/query"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.searchParams) {
		postBody = "{}"
	} else {
		postBody = r.searchParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchSynonymsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["hitsPerPage"]; ok {
		err = json.Unmarshal(v, &r.hitsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.hitsPerPage)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["searchSynonymsParams"]; ok {
		err = json.Unmarshal(v, &r.searchSynonymsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchSynonymsParams)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSearchSynonymsRequest represents the request with all the parameters for the API call.
type ApiSearchSynonymsRequest struct {
	indexName            string
	type_                *SynonymType
	page                 int32
	hitsPerPage          int32
	searchSynonymsParams *SearchSynonymsParams
}

// NewApiSearchSynonymsRequest creates an instance of the ApiSearchSynonymsRequest to be used for the API call.
func (c *APIClient) NewApiSearchSynonymsRequest(indexName string) ApiSearchSynonymsRequest {
	return ApiSearchSynonymsRequest{
		indexName: indexName,
	}
}

// WithType_ adds the type_ to the ApiSearchSynonymsRequest and returns the request for chaining.
func (r ApiSearchSynonymsRequest) WithType_(type_ *SynonymType) ApiSearchSynonymsRequest {
	r.type_ = type_
	return r
}

// WithPage adds the page to the ApiSearchSynonymsRequest and returns the request for chaining.
func (r ApiSearchSynonymsRequest) WithPage(page int32) ApiSearchSynonymsRequest {
	r.page = page
	return r
}

// WithHitsPerPage adds the hitsPerPage to the ApiSearchSynonymsRequest and returns the request for chaining.
func (r ApiSearchSynonymsRequest) WithHitsPerPage(hitsPerPage int32) ApiSearchSynonymsRequest {
	r.hitsPerPage = hitsPerPage
	return r
}

// WithSearchSynonymsParams adds the searchSynonymsParams to the ApiSearchSynonymsRequest and returns the request for chaining.
func (r ApiSearchSynonymsRequest) WithSearchSynonymsParams(searchSynonymsParams *SearchSynonymsParams) ApiSearchSynonymsRequest {
	r.searchSynonymsParams = searchSynonymsParams
	return r
}

/*
SearchSynonyms Search for synonyms. Wraps SearchSynonymsWithContext using context.Background.

Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms, send an empty request body.

Request can be constructed by NewApiSearchSynonymsRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param type_ SynonymType - Search for specific [types of synonyms](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms).
	@param page int32 - Returns the requested page number (the first page is 0). Page size is set by `hitsPerPage`. When null, there's no pagination.
	@param hitsPerPage int32 - Maximum number of hits per page.
	@param searchSynonymsParams SearchSynonymsParams - Body of the `searchSynonyms` operation.
	@return SearchSynonymsResponse
*/
func (c *APIClient) SearchSynonyms(r ApiSearchSynonymsRequest, opts ...Option) (*SearchSynonymsResponse, error) {
	return c.SearchSynonymsWithContext(context.Background(), r, opts...)
}

/*
SearchSynonyms Search for synonyms.

Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms, send an empty request body.

Request can be constructed by NewApiSearchSynonymsRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param type_ SynonymType - Search for specific [types of synonyms](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms).
	@param page int32 - Returns the requested page number (the first page is 0). Page size is set by `hitsPerPage`. When null, there's no pagination.
	@param hitsPerPage int32 - Maximum number of hits per page.
	@param searchSynonymsParams SearchSynonymsParams - Body of the `searchSynonyms` operation.
	@return SearchSynonymsResponse
*/
func (c *APIClient) SearchSynonymsWithContext(ctx context.Context, r ApiSearchSynonymsRequest, opts ...Option) (*SearchSynonymsResponse, error) {
	var (
		postBody    any
		returnValue *SearchSynonymsResponse
	)

	requestPath := "/1/indexes/{indexName}/synonyms/search"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.type_) {
		queryParams.Set("type", parameterToString(*r.type_))
	}
	if !isNilorEmpty(r.page) {
		queryParams.Set("page", parameterToString(r.page))
	}
	if !isNilorEmpty(r.hitsPerPage) {
		queryParams.Set("hitsPerPage", parameterToString(r.hitsPerPage))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.searchSynonymsParams) {
		postBody = "{}"
	} else {
		postBody = r.searchSynonymsParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchUserIdsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["searchUserIdsParams"]; ok {
		err = json.Unmarshal(v, &r.searchUserIdsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchUserIdsParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.searchUserIdsParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSearchUserIdsRequest represents the request with all the parameters for the API call.
type ApiSearchUserIdsRequest struct {
	searchUserIdsParams *SearchUserIdsParams
}

// NewApiSearchUserIdsRequest creates an instance of the ApiSearchUserIdsRequest to be used for the API call.
func (c *APIClient) NewApiSearchUserIdsRequest(searchUserIdsParams *SearchUserIdsParams) ApiSearchUserIdsRequest {
	return ApiSearchUserIdsRequest{
		searchUserIdsParams: searchUserIdsParams,
	}
}

/*
SearchUserIds Search for a user ID. Wraps SearchUserIdsWithContext using context.Background.

Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).

Request can be constructed by NewApiSearchUserIdsRequest with parameters below.

	@param searchUserIdsParams SearchUserIdsParams
	@return SearchUserIdsResponse
*/
func (c *APIClient) SearchUserIds(r ApiSearchUserIdsRequest, opts ...Option) (*SearchUserIdsResponse, error) {
	return c.SearchUserIdsWithContext(context.Background(), r, opts...)
}

/*
SearchUserIds Search for a user ID.

Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).

Request can be constructed by NewApiSearchUserIdsRequest with parameters below.

	@param searchUserIdsParams SearchUserIdsParams
	@return SearchUserIdsResponse
*/
func (c *APIClient) SearchUserIdsWithContext(ctx context.Context, r ApiSearchUserIdsRequest, opts ...Option) (*SearchUserIdsResponse, error) {
	var (
		postBody    any
		returnValue *SearchUserIdsResponse
	)

	requestPath := "/1/clusters/mapping/search"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.searchUserIdsParams == nil {
		return returnValue, reportError("searchUserIdsParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.searchUserIdsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Read)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSetDictionarySettingsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["dictionarySettingsParams"]; ok {
		err = json.Unmarshal(v, &r.dictionarySettingsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.dictionarySettingsParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.dictionarySettingsParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSetDictionarySettingsRequest represents the request with all the parameters for the API call.
type ApiSetDictionarySettingsRequest struct {
	dictionarySettingsParams *DictionarySettingsParams
}

// NewApiSetDictionarySettingsRequest creates an instance of the ApiSetDictionarySettingsRequest to be used for the API call.
func (c *APIClient) NewApiSetDictionarySettingsRequest(dictionarySettingsParams *DictionarySettingsParams) ApiSetDictionarySettingsRequest {
	return ApiSetDictionarySettingsRequest{
		dictionarySettingsParams: dictionarySettingsParams,
	}
}

/*
SetDictionarySettings Set stop word settings. Wraps SetDictionarySettingsWithContext using context.Background.

Set stop word settings for a specific language.

Request can be constructed by NewApiSetDictionarySettingsRequest with parameters below.

	@param dictionarySettingsParams DictionarySettingsParams
	@return UpdatedAtResponse
*/
func (c *APIClient) SetDictionarySettings(r ApiSetDictionarySettingsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SetDictionarySettingsWithContext(context.Background(), r, opts...)
}

/*
SetDictionarySettings Set stop word settings.

Set stop word settings for a specific language.

Request can be constructed by NewApiSetDictionarySettingsRequest with parameters below.

	@param dictionarySettingsParams DictionarySettingsParams
	@return UpdatedAtResponse
*/
func (c *APIClient) SetDictionarySettingsWithContext(ctx context.Context, r ApiSetDictionarySettingsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/dictionaries/*/settings"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.dictionarySettingsParams == nil {
		return returnValue, reportError("dictionarySettingsParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.dictionarySettingsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSetSettingsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["indexSettings"]; ok {
		err = json.Unmarshal(v, &r.indexSettings)
		if err != nil {
			err = json.Unmarshal(b, &r.indexSettings)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.indexSettings)
		if err != nil {
			return err
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSetSettingsRequest represents the request with all the parameters for the API call.
type ApiSetSettingsRequest struct {
	indexName         string
	indexSettings     *IndexSettings
	forwardToReplicas bool
}

// NewApiSetSettingsRequest creates an instance of the ApiSetSettingsRequest to be used for the API call.
func (c *APIClient) NewApiSetSettingsRequest(indexName string, indexSettings *IndexSettings) ApiSetSettingsRequest {
	return ApiSetSettingsRequest{
		indexName:     indexName,
		indexSettings: indexSettings,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSetSettingsRequest and returns the request for chaining.
func (r ApiSetSettingsRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSetSettingsRequest {
	r.forwardToReplicas = forwardToReplicas
	return r
}

/*
SetSettings Update index settings. Wraps SetSettingsWithContext using context.Background.

Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/). Specifying null for a setting resets it to its default value.

Request can be constructed by NewApiSetSettingsRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param indexSettings IndexSettings
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) SetSettings(r ApiSetSettingsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SetSettingsWithContext(context.Background(), r, opts...)
}

/*
SetSettings Update index settings.

Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/). Specifying null for a setting resets it to its default value.

Request can be constructed by NewApiSetSettingsRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param indexSettings IndexSettings
	@param forwardToReplicas bool - Indicates whether changed index settings are forwarded to the replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) SetSettingsWithContext(ctx context.Context, r ApiSetSettingsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var (
		postBody    any
		returnValue *UpdatedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/settings"
	requestPath = strings.Replace(requestPath, "{"+"indexName"+"}", url.PathEscape(parameterToString(r.indexName)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexSettings == nil {
		return returnValue, reportError("indexSettings is required and must be specified")
	}

	if !isNilorEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", parameterToString(r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.indexSettings
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["key"]; ok {
		err = json.Unmarshal(v, &r.key)
		if err != nil {
			err = json.Unmarshal(b, &r.key)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["apiKey"]; ok {
		err = json.Unmarshal(v, &r.apiKey)
		if err != nil {
			err = json.Unmarshal(b, &r.apiKey)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.apiKey)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiUpdateApiKeyRequest represents the request with all the parameters for the API call.
type ApiUpdateApiKeyRequest struct {
	key    string
	apiKey *ApiKey
}

// NewApiUpdateApiKeyRequest creates an instance of the ApiUpdateApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiUpdateApiKeyRequest(key string, apiKey *ApiKey) ApiUpdateApiKeyRequest {
	return ApiUpdateApiKeyRequest{
		key:    key,
		apiKey: apiKey,
	}
}

/*
UpdateApiKey Update an API key. Wraps UpdateApiKeyWithContext using context.Background.

Replace the permissions of an existing API key.
Any unspecified parameter resets that permission to its default value.
The request must be authenticated with the admin API key.

Request can be constructed by NewApiUpdateApiKeyRequest with parameters below.

	@param key string - API key.
	@param apiKey ApiKey
	@return UpdateApiKeyResponse
*/
func (c *APIClient) UpdateApiKey(r ApiUpdateApiKeyRequest, opts ...Option) (*UpdateApiKeyResponse, error) {
	return c.UpdateApiKeyWithContext(context.Background(), r, opts...)
}

/*
UpdateApiKey Update an API key.

Replace the permissions of an existing API key.
Any unspecified parameter resets that permission to its default value.
The request must be authenticated with the admin API key.

Request can be constructed by NewApiUpdateApiKeyRequest with parameters below.

	@param key string - API key.
	@param apiKey ApiKey
	@return UpdateApiKeyResponse
*/
func (c *APIClient) UpdateApiKeyWithContext(ctx context.Context, r ApiUpdateApiKeyRequest, opts ...Option) (*UpdateApiKeyResponse, error) {
	var (
		postBody    any
		returnValue *UpdateApiKeyResponse
	)

	requestPath := "/1/keys/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(parameterToString(r.key)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.apiKey == nil {
		return returnValue, reportError("apiKey is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.apiKey
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
WaitForTask waits for a task to be published.
Wraps WaitForTaskWithContext with context.Background().
It returns the task response if the operation was successful.
It returns an error if the operation failed.

The maxRetries parameter is the maximum number of retries.
The initialDelay parameter is the initial delay between each retry.
The maxDelay parameter is the maximum delay between each retry.

	@param indexName string - Index name.
	@param taskID int64 - Task ID.
	@param maxRetries *int - Maximum number of retries.
	@param initialDelay *time.Duration - Initial delay between retries.
	@param maxDelay *time.Duration - Maximum delay between retries.
	@param opts ...Option - Optional parameters for the request.
	@return *GetTaskResponse - Task response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForTask(
	indexName string,
	taskID int64,
	maxRetries *int,
	initialDelay *time.Duration,
	maxDelay *time.Duration,
	opts ...Option,
) (*GetTaskResponse, error) {
	return c.WaitForTaskWithContext(
		context.Background(),
		indexName,
		taskID,
		maxRetries,
		initialDelay,
		maxDelay,
		opts...,
	)
}

/*
WaitForTaskWithContext waits for a task to be published.
It returns the task response if the operation was successful.
It returns an error if the operation failed.

The maxRetries parameter is the maximum number of retries.
The initialDelay parameter is the initial delay between each retry.
The maxDelay parameter is the maximum delay between each retry.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param indexName string - Index name.
	@param taskID int64 - Task ID.
	@param maxRetries *int - Maximum number of retries.
	@param initialDelay *time.Duration - Initial delay between retries.
	@param maxDelay *time.Duration - Maximum delay between retries.
	@param opts ...Option - Optional parameters for the request.
	@return *GetTaskResponse - Task response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForTaskWithContext(
	ctx context.Context,
	indexName string,
	taskID int64,
	maxRetries *int,
	initialDelay *time.Duration,
	maxDelay *time.Duration,
	opts ...Option,
) (*GetTaskResponse, error) {
	return RetryUntil(
		func() (*GetTaskResponse, error) {
			return c.GetTaskWithContext(ctx, c.NewApiGetTaskRequest(indexName, taskID), opts...)
		},
		func(response *GetTaskResponse, err error) bool {
			return response.Status == TASKSTATUS_PUBLISHED
		},
		maxRetries,
		initialDelay,
		maxDelay,
	)
}

/*
WaitForApiKey waits for an API key to be created, deleted or updated.
Wraps WaitForApiKeyWithContext with context.Background().
It returns the API key response if the operation was successful.
It returns an error if the operation failed.

The operation can be one of the following:
  - "add": wait for the API key to be created
  - "delete": wait for the API key to be deleted
  - "update": wait for the API key to be updated

The maxRetries parameter is the maximum number of retries.
The initialDelay parameter is the initial delay between each retry.
The maxDelay parameter is the maximum delay between each retry.

If the operation is "update", the apiKey parameter must be set.
If the operation is "delete" or "add", the apiKey parameter is not used.

	@param key string - API key.
	@param apiKey *ApiKey - API key structure - required for update operation.
	@param operation string - Operation type - add, delete or update.
	@param maxRetries *int - Maximum number of retries.
	@param initialDelay *time.Duration - Initial delay between retries.
	@param maxDelay *time.Duration - Maximum delay between retries.
	@param opts ...Option - Optional parameters for the request.
	@return *GetApiKeyResponse - API key response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForApiKey(
	key string,
	apiKey *ApiKey,
	operation string,
	maxRetries *int,
	initialDelay *time.Duration,
	maxDelay *time.Duration,
	opts ...Option,
) (*GetApiKeyResponse, error) {
	return c.WaitForApiKeyWithContext(
		context.Background(),
		key,
		apiKey,
		operation,
		maxRetries,
		initialDelay,
		maxDelay,
		opts...,
	)
}

/*
WaitForApiKeyWithContext waits for an API key to be created, deleted or updated.
It returns the API key response if the operation was successful.
It returns an error if the operation failed.

The operation can be one of the following:
  - "add": wait for the API key to be created
  - "delete": wait for the API key to be deleted
  - "update": wait for the API key to be updated

The maxRetries parameter is the maximum number of retries.
The initialDelay parameter is the initial delay between each retry.
The maxDelay parameter is the maximum delay between each retry.

If the operation is "update", the apiKey parameter must be set.
If the operation is "delete" or "add", the apiKey parameter is not used.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param key string - API key.
	@param apiKey *ApiKey - API key structure - required for update operation.
	@param operation string - Operation type - add, delete or update.
	@param maxRetries *int - Maximum number of retries.
	@param initialDelay *time.Duration - Initial delay between retries.
	@param maxDelay *time.Duration - Maximum delay between retries.
	@param opts ...Option - Optional parameters for the request.
	@return *GetApiKeyResponse - API key response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForApiKeyWithContext(
	ctx context.Context,
	key string,
	apiKey *ApiKey,
	operation string,
	maxRetries *int,
	initialDelay *time.Duration,
	maxDelay *time.Duration,
	opts ...Option,
) (*GetApiKeyResponse, error) {
	if operation != "add" && operation != "delete" && operation != "update" {
		return nil, &errs.WaitKeyOperationError{}
	}

	if operation == "update" {
		if apiKey == nil {
			return nil, &errs.WaitKeyUpdateError{}
		}

		return RetryUntil(
			func() (*GetApiKeyResponse, error) {
				return c.GetApiKeyWithContext(ctx, c.NewApiGetApiKeyRequest(key), opts...)
			},
			func(response *GetApiKeyResponse, err error) bool {
				if err != nil || response == nil {
					return false
				}

				if apiKey.GetDescription() != response.GetDescription() {
					return false
				}

				if apiKey.GetQueryParameters() != response.GetQueryParameters() {
					return false
				}

				if apiKey.GetMaxHitsPerQuery() != response.GetMaxHitsPerQuery() {
					return false
				}

				if apiKey.GetMaxQueriesPerIPPerHour() != response.GetMaxQueriesPerIPPerHour() {
					return false
				}

				if apiKey.GetValidity() != response.GetValidity() {
					return false
				}

				if apiKey.GetValidity() != response.GetValidity() {
					return false
				}

				slices.Sort(apiKey.Acl)
				slices.Sort(response.Acl)

				if slices.Equal(apiKey.Acl, response.Acl) == false {
					return false
				}

				slices.Sort(apiKey.Indexes)
				slices.Sort(response.Indexes)

				if slices.Equal(apiKey.Indexes, response.Indexes) == false {
					return false
				}

				slices.Sort(apiKey.Referers)
				slices.Sort(response.Referers)

				if slices.Equal(apiKey.Referers, response.Referers) == false {
					return false
				}

				return true
			},
			maxRetries,
			initialDelay,
			maxDelay,
		)
	}

	return RetryUntil(
		func() (*GetApiKeyResponse, error) {
			return c.GetApiKeyWithContext(ctx, c.NewApiGetApiKeyRequest(key), opts...)
		},
		func(response *GetApiKeyResponse, err error) bool {
			switch operation {
			case "add":
				return err == nil && response != nil && response.CreatedAt > 0
			case "delete":
				if _, ok := err.(*APIError); ok {
					apiErr := err.(*APIError)

					return apiErr.Status == 404
				}

				return false
			}
			return false
		},
		maxRetries,
		initialDelay,
		maxDelay,
	)
}
