// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package search

import (
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/errs"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       queryParameterToString(name),
		value:      queryParameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

func (r *ApiAddApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["apiKey"]; ok {
		err = json.Unmarshal(v, &r.apiKey)
		if err != nil {
			err = json.Unmarshal(b, &r.apiKey)
			if err != nil {
				return fmt.Errorf("cannot unmarshal apiKey: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.apiKey)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter apiKey: %w", err)
		}
	}

	return nil
}

// ApiAddApiKeyRequest represents the request with all the parameters for the API call.
type ApiAddApiKeyRequest struct {
	apiKey *ApiKey
}

// NewApiAddApiKeyRequest creates an instance of the ApiAddApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiAddApiKeyRequest(apiKey *ApiKey) ApiAddApiKeyRequest {
	return ApiAddApiKeyRequest{
		apiKey: apiKey,
	}
}

/*
AddApiKey calls the API and returns the raw response from it.

	  Creates a new API key with specific permissions and restrictions.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiAddApiKeyRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param apiKey ApiKey
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) AddApiKeyWithHTTPInfo(ctx context.Context, r ApiAddApiKeyRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/keys"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.apiKey == nil {
		return nil, nil, reportError("Parameter `apiKey` is required when calling `AddApiKey`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.apiKey
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
AddApiKey wraps AddApiKeyWithContext using context.Background.

Creates a new API key with specific permissions and restrictions.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiAddApiKeyRequest with parameters below.

	@param apiKey ApiKey
	@return AddApiKeyResponse
*/
func (c *APIClient) AddApiKey(r ApiAddApiKeyRequest, opts ...Option) (*AddApiKeyResponse, error) {
	return c.AddApiKeyWithContext(context.Background(), r, opts...)
}

/*
AddApiKey casts the HTTP response body to a defined struct.

Creates a new API key with specific permissions and restrictions.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiAddApiKeyRequest with parameters below.

	@param apiKey ApiKey
	@return AddApiKeyResponse
*/
func (c *APIClient) AddApiKeyWithContext(ctx context.Context, r ApiAddApiKeyRequest, opts ...Option) (*AddApiKeyResponse, error) {
	var returnValue *AddApiKeyResponse

	res, resBody, err := c.AddApiKeyWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiAddOrUpdateObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal objectID: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.body)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter body: %w", err)
		}
	}

	return nil
}

// ApiAddOrUpdateObjectRequest represents the request with all the parameters for the API call.
type ApiAddOrUpdateObjectRequest struct {
	indexName string
	objectID  string
	body      map[string]any
}

// NewApiAddOrUpdateObjectRequest creates an instance of the ApiAddOrUpdateObjectRequest to be used for the API call.
func (c *APIClient) NewApiAddOrUpdateObjectRequest(indexName string, objectID string, body map[string]any) ApiAddOrUpdateObjectRequest {
	return ApiAddOrUpdateObjectRequest{
		indexName: indexName,
		objectID:  objectID,
		body:      body,
	}
}

/*
AddOrUpdateObject calls the API and returns the raw response from it.

	If a record with the specified object ID exists, the existing record is replaced.

Otherwise, a new record is added to the index.

To update _some_ attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead.
To add, update, or replace multiple records, use the [`batch` operation](#tag/Records/operation/batch).

	    Required API Key ACLs:
	    - addObject

	Request can be constructed by NewApiAddOrUpdateObjectRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param objectID string - Unique record identifier.
	  @param body map[string]any - The record, a schemaless object with attributes that are useful in the context of search and discovery.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) AddOrUpdateObjectWithHTTPInfo(ctx context.Context, r ApiAddOrUpdateObjectRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(parameterToString(r.objectID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `AddOrUpdateObject`.")
	}
	if r.objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `AddOrUpdateObject`.")
	}

	if len(r.body) == 0 {
		return nil, nil, reportError("Parameter `body` is required when calling `AddOrUpdateObject`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.body
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
AddOrUpdateObject wraps AddOrUpdateObjectWithContext using context.Background.

If a record with the specified object ID exists, the existing record is replaced.
Otherwise, a new record is added to the index.

To update _some_ attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead.
To add, update, or replace multiple records, use the [`batch` operation](#tag/Records/operation/batch).

Required API Key ACLs:
  - addObject

Request can be constructed by NewApiAddOrUpdateObjectRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique record identifier.
	@param body map[string]any - The record, a schemaless object with attributes that are useful in the context of search and discovery.
	@return UpdatedAtWithObjectIdResponse
*/
func (c *APIClient) AddOrUpdateObject(r ApiAddOrUpdateObjectRequest, opts ...Option) (*UpdatedAtWithObjectIdResponse, error) {
	return c.AddOrUpdateObjectWithContext(context.Background(), r, opts...)
}

/*
AddOrUpdateObject casts the HTTP response body to a defined struct.

If a record with the specified object ID exists, the existing record is replaced.
Otherwise, a new record is added to the index.

To update _some_ attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead.
To add, update, or replace multiple records, use the [`batch` operation](#tag/Records/operation/batch).

Required API Key ACLs:
  - addObject

Request can be constructed by NewApiAddOrUpdateObjectRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique record identifier.
	@param body map[string]any - The record, a schemaless object with attributes that are useful in the context of search and discovery.
	@return UpdatedAtWithObjectIdResponse
*/
func (c *APIClient) AddOrUpdateObjectWithContext(ctx context.Context, r ApiAddOrUpdateObjectRequest, opts ...Option) (*UpdatedAtWithObjectIdResponse, error) {
	var returnValue *UpdatedAtWithObjectIdResponse

	res, resBody, err := c.AddOrUpdateObjectWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiAppendSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["source"]; ok {
		err = json.Unmarshal(v, &r.source)
		if err != nil {
			err = json.Unmarshal(b, &r.source)
			if err != nil {
				return fmt.Errorf("cannot unmarshal source: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.source)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter source: %w", err)
		}
	}

	return nil
}

// ApiAppendSourceRequest represents the request with all the parameters for the API call.
type ApiAppendSourceRequest struct {
	source *Source
}

// NewApiAppendSourceRequest creates an instance of the ApiAppendSourceRequest to be used for the API call.
func (c *APIClient) NewApiAppendSourceRequest(source *Source) ApiAppendSourceRequest {
	return ApiAppendSourceRequest{
		source: source,
	}
}

/*
AppendSource calls the API and returns the raw response from it.

	  Adds a source to the list of allowed sources.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiAppendSourceRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param source Source - Source to add.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) AppendSourceWithHTTPInfo(ctx context.Context, r ApiAppendSourceRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/security/sources/append"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.source == nil {
		return nil, nil, reportError("Parameter `source` is required when calling `AppendSource`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.source
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
AppendSource wraps AppendSourceWithContext using context.Background.

Adds a source to the list of allowed sources.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiAppendSourceRequest with parameters below.

	@param source Source - Source to add.
	@return CreatedAtResponse
*/
func (c *APIClient) AppendSource(r ApiAppendSourceRequest, opts ...Option) (*CreatedAtResponse, error) {
	return c.AppendSourceWithContext(context.Background(), r, opts...)
}

/*
AppendSource casts the HTTP response body to a defined struct.

Adds a source to the list of allowed sources.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiAppendSourceRequest with parameters below.

	@param source Source - Source to add.
	@return CreatedAtResponse
*/
func (c *APIClient) AppendSourceWithContext(ctx context.Context, r ApiAppendSourceRequest, opts ...Option) (*CreatedAtResponse, error) {
	var returnValue *CreatedAtResponse

	res, resBody, err := c.AppendSourceWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiAssignUserIdRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["xAlgoliaUserID"]; ok {
		err = json.Unmarshal(v, &r.xAlgoliaUserID)
		if err != nil {
			err = json.Unmarshal(b, &r.xAlgoliaUserID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal xAlgoliaUserID: %w", err)
			}
		}
	}
	if v, ok := req["assignUserIdParams"]; ok {
		err = json.Unmarshal(v, &r.assignUserIdParams)
		if err != nil {
			err = json.Unmarshal(b, &r.assignUserIdParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal assignUserIdParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.assignUserIdParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter assignUserIdParams: %w", err)
		}
	}

	return nil
}

// ApiAssignUserIdRequest represents the request with all the parameters for the API call.
type ApiAssignUserIdRequest struct {
	xAlgoliaUserID     string
	assignUserIdParams *AssignUserIdParams
}

// NewApiAssignUserIdRequest creates an instance of the ApiAssignUserIdRequest to be used for the API call.
func (c *APIClient) NewApiAssignUserIdRequest(xAlgoliaUserID string, assignUserIdParams *AssignUserIdParams) ApiAssignUserIdRequest {
	return ApiAssignUserIdRequest{
		xAlgoliaUserID:     xAlgoliaUserID,
		assignUserIdParams: assignUserIdParams,
	}
}

/*
AssignUserId calls the API and returns the raw response from it.

	Assigns or moves a user ID to a cluster.

The time it takes to move a user is proportional to the amount of data linked to the user ID.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiAssignUserIdRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param xAlgoliaUserID string - Unique identifier of the user who makes the search request.
	  @param assignUserIdParams AssignUserIdParams
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) AssignUserIdWithHTTPInfo(ctx context.Context, r ApiAssignUserIdRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/clusters/mapping"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.xAlgoliaUserID == "" {
		return nil, nil, reportError("Parameter `xAlgoliaUserID` is required when calling `AssignUserId`.")
	}

	if r.assignUserIdParams == nil {
		return nil, nil, reportError("Parameter `assignUserIdParams` is required when calling `AssignUserId`.")
	}

	headers["X-Algolia-User-ID"] = parameterToString(r.xAlgoliaUserID)

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.assignUserIdParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
AssignUserId wraps AssignUserIdWithContext using context.Background.

Assigns or moves a user ID to a cluster.

The time it takes to move a user is proportional to the amount of data linked to the user ID.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiAssignUserIdRequest with parameters below.

	@param xAlgoliaUserID string - Unique identifier of the user who makes the search request.
	@param assignUserIdParams AssignUserIdParams
	@return CreatedAtResponse
*/
func (c *APIClient) AssignUserId(r ApiAssignUserIdRequest, opts ...Option) (*CreatedAtResponse, error) {
	return c.AssignUserIdWithContext(context.Background(), r, opts...)
}

/*
AssignUserId casts the HTTP response body to a defined struct.

Assigns or moves a user ID to a cluster.

The time it takes to move a user is proportional to the amount of data linked to the user ID.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiAssignUserIdRequest with parameters below.

	@param xAlgoliaUserID string - Unique identifier of the user who makes the search request.
	@param assignUserIdParams AssignUserIdParams
	@return CreatedAtResponse
*/
func (c *APIClient) AssignUserIdWithContext(ctx context.Context, r ApiAssignUserIdRequest, opts ...Option) (*CreatedAtResponse, error) {
	var returnValue *CreatedAtResponse

	res, resBody, err := c.AssignUserIdWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiBatchRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["batchWriteParams"]; ok {
		err = json.Unmarshal(v, &r.batchWriteParams)
		if err != nil {
			err = json.Unmarshal(b, &r.batchWriteParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal batchWriteParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.batchWriteParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter batchWriteParams: %w", err)
		}
	}

	return nil
}

// ApiBatchRequest represents the request with all the parameters for the API call.
type ApiBatchRequest struct {
	indexName        string
	batchWriteParams *BatchWriteParams
}

// NewApiBatchRequest creates an instance of the ApiBatchRequest to be used for the API call.
func (c *APIClient) NewApiBatchRequest(indexName string, batchWriteParams *BatchWriteParams) ApiBatchRequest {
	return ApiBatchRequest{
		indexName:        indexName,
		batchWriteParams: batchWriteParams,
	}
}

/*
Batch calls the API and returns the raw response from it.

	Adds, updates, or deletes records in one index with a single API request.

Batching index updates reduces latency and increases data integrity.

- Actions are applied in the order they're specified.
- Actions are equivalent to the individual API requests of the same name.

	Request can be constructed by NewApiBatchRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param batchWriteParams BatchWriteParams
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) BatchWithHTTPInfo(ctx context.Context, r ApiBatchRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/batch"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `Batch`.")
	}

	if r.batchWriteParams == nil {
		return nil, nil, reportError("Parameter `batchWriteParams` is required when calling `Batch`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.batchWriteParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
Batch wraps BatchWithContext using context.Background.

Adds, updates, or deletes records in one index with a single API request.

Batching index updates reduces latency and increases data integrity.

- Actions are applied in the order they're specified.
- Actions are equivalent to the individual API requests of the same name.

Request can be constructed by NewApiBatchRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param batchWriteParams BatchWriteParams
	@return BatchResponse
*/
func (c *APIClient) Batch(r ApiBatchRequest, opts ...Option) (*BatchResponse, error) {
	return c.BatchWithContext(context.Background(), r, opts...)
}

/*
Batch casts the HTTP response body to a defined struct.

Adds, updates, or deletes records in one index with a single API request.

Batching index updates reduces latency and increases data integrity.

- Actions are applied in the order they're specified.
- Actions are equivalent to the individual API requests of the same name.

Request can be constructed by NewApiBatchRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param batchWriteParams BatchWriteParams
	@return BatchResponse
*/
func (c *APIClient) BatchWithContext(ctx context.Context, r ApiBatchRequest, opts ...Option) (*BatchResponse, error) {
	var returnValue *BatchResponse

	res, resBody, err := c.BatchWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiBatchAssignUserIdsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["xAlgoliaUserID"]; ok {
		err = json.Unmarshal(v, &r.xAlgoliaUserID)
		if err != nil {
			err = json.Unmarshal(b, &r.xAlgoliaUserID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal xAlgoliaUserID: %w", err)
			}
		}
	}
	if v, ok := req["batchAssignUserIdsParams"]; ok {
		err = json.Unmarshal(v, &r.batchAssignUserIdsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.batchAssignUserIdsParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal batchAssignUserIdsParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.batchAssignUserIdsParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter batchAssignUserIdsParams: %w", err)
		}
	}

	return nil
}

// ApiBatchAssignUserIdsRequest represents the request with all the parameters for the API call.
type ApiBatchAssignUserIdsRequest struct {
	xAlgoliaUserID           string
	batchAssignUserIdsParams *BatchAssignUserIdsParams
}

// NewApiBatchAssignUserIdsRequest creates an instance of the ApiBatchAssignUserIdsRequest to be used for the API call.
func (c *APIClient) NewApiBatchAssignUserIdsRequest(xAlgoliaUserID string, batchAssignUserIdsParams *BatchAssignUserIdsParams) ApiBatchAssignUserIdsRequest {
	return ApiBatchAssignUserIdsRequest{
		xAlgoliaUserID:           xAlgoliaUserID,
		batchAssignUserIdsParams: batchAssignUserIdsParams,
	}
}

/*
BatchAssignUserIds calls the API and returns the raw response from it.

	Assigns multiple user IDs to a cluster.

**You can't move users with this operation**.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiBatchAssignUserIdsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param xAlgoliaUserID string - Unique identifier of the user who makes the search request.
	  @param batchAssignUserIdsParams BatchAssignUserIdsParams
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) BatchAssignUserIdsWithHTTPInfo(ctx context.Context, r ApiBatchAssignUserIdsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/clusters/mapping/batch"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.xAlgoliaUserID == "" {
		return nil, nil, reportError("Parameter `xAlgoliaUserID` is required when calling `BatchAssignUserIds`.")
	}

	if r.batchAssignUserIdsParams == nil {
		return nil, nil, reportError("Parameter `batchAssignUserIdsParams` is required when calling `BatchAssignUserIds`.")
	}

	headers["X-Algolia-User-ID"] = parameterToString(r.xAlgoliaUserID)

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.batchAssignUserIdsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
BatchAssignUserIds wraps BatchAssignUserIdsWithContext using context.Background.

Assigns multiple user IDs to a cluster.

**You can't move users with this operation**.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiBatchAssignUserIdsRequest with parameters below.

	@param xAlgoliaUserID string - Unique identifier of the user who makes the search request.
	@param batchAssignUserIdsParams BatchAssignUserIdsParams
	@return CreatedAtResponse
*/
func (c *APIClient) BatchAssignUserIds(r ApiBatchAssignUserIdsRequest, opts ...Option) (*CreatedAtResponse, error) {
	return c.BatchAssignUserIdsWithContext(context.Background(), r, opts...)
}

/*
BatchAssignUserIds casts the HTTP response body to a defined struct.

Assigns multiple user IDs to a cluster.

**You can't move users with this operation**.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiBatchAssignUserIdsRequest with parameters below.

	@param xAlgoliaUserID string - Unique identifier of the user who makes the search request.
	@param batchAssignUserIdsParams BatchAssignUserIdsParams
	@return CreatedAtResponse
*/
func (c *APIClient) BatchAssignUserIdsWithContext(ctx context.Context, r ApiBatchAssignUserIdsRequest, opts ...Option) (*CreatedAtResponse, error) {
	var returnValue *CreatedAtResponse

	res, resBody, err := c.BatchAssignUserIdsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiBatchDictionaryEntriesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["dictionaryName"]; ok {
		err = json.Unmarshal(v, &r.dictionaryName)
		if err != nil {
			err = json.Unmarshal(b, &r.dictionaryName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal dictionaryName: %w", err)
			}
		}
	}
	if v, ok := req["batchDictionaryEntriesParams"]; ok {
		err = json.Unmarshal(v, &r.batchDictionaryEntriesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.batchDictionaryEntriesParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal batchDictionaryEntriesParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.batchDictionaryEntriesParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter batchDictionaryEntriesParams: %w", err)
		}
	}

	return nil
}

// ApiBatchDictionaryEntriesRequest represents the request with all the parameters for the API call.
type ApiBatchDictionaryEntriesRequest struct {
	dictionaryName               DictionaryType
	batchDictionaryEntriesParams *BatchDictionaryEntriesParams
}

// NewApiBatchDictionaryEntriesRequest creates an instance of the ApiBatchDictionaryEntriesRequest to be used for the API call.
func (c *APIClient) NewApiBatchDictionaryEntriesRequest(dictionaryName DictionaryType, batchDictionaryEntriesParams *BatchDictionaryEntriesParams) ApiBatchDictionaryEntriesRequest {
	return ApiBatchDictionaryEntriesRequest{
		dictionaryName:               dictionaryName,
		batchDictionaryEntriesParams: batchDictionaryEntriesParams,
	}
}

/*
BatchDictionaryEntries calls the API and returns the raw response from it.

	  Adds or deletes multiple entries from your plurals, segmentation, or stop word dictionaries.

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiBatchDictionaryEntriesRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param dictionaryName DictionaryType - Dictionary type in which to search.
	  @param batchDictionaryEntriesParams BatchDictionaryEntriesParams
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) BatchDictionaryEntriesWithHTTPInfo(ctx context.Context, r ApiBatchDictionaryEntriesRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/dictionaries/{dictionaryName}/batch"
	requestPath = strings.ReplaceAll(requestPath, "{dictionaryName}", url.PathEscape(parameterToString(r.dictionaryName)))

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.batchDictionaryEntriesParams == nil {
		return nil, nil, reportError("Parameter `batchDictionaryEntriesParams` is required when calling `BatchDictionaryEntries`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.batchDictionaryEntriesParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
BatchDictionaryEntries wraps BatchDictionaryEntriesWithContext using context.Background.

Adds or deletes multiple entries from your plurals, segmentation, or stop word dictionaries.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiBatchDictionaryEntriesRequest with parameters below.

	@param dictionaryName DictionaryType - Dictionary type in which to search.
	@param batchDictionaryEntriesParams BatchDictionaryEntriesParams
	@return UpdatedAtResponse
*/
func (c *APIClient) BatchDictionaryEntries(r ApiBatchDictionaryEntriesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.BatchDictionaryEntriesWithContext(context.Background(), r, opts...)
}

/*
BatchDictionaryEntries casts the HTTP response body to a defined struct.

Adds or deletes multiple entries from your plurals, segmentation, or stop word dictionaries.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiBatchDictionaryEntriesRequest with parameters below.

	@param dictionaryName DictionaryType - Dictionary type in which to search.
	@param batchDictionaryEntriesParams BatchDictionaryEntriesParams
	@return UpdatedAtResponse
*/
func (c *APIClient) BatchDictionaryEntriesWithContext(ctx context.Context, r ApiBatchDictionaryEntriesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.BatchDictionaryEntriesWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiBrowseRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["browseParams"]; ok {
		err = json.Unmarshal(v, &r.browseParams)
		if err != nil {
			err = json.Unmarshal(b, &r.browseParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal browseParams: %w", err)
			}
		}
	}

	return nil
}

// ApiBrowseRequest represents the request with all the parameters for the API call.
type ApiBrowseRequest struct {
	indexName    string
	browseParams *BrowseParams
}

// NewApiBrowseRequest creates an instance of the ApiBrowseRequest to be used for the API call.
func (c *APIClient) NewApiBrowseRequest(indexName string) ApiBrowseRequest {
	return ApiBrowseRequest{
		indexName: indexName,
	}
}

// WithBrowseParams adds the browseParams to the ApiBrowseRequest and returns the request for chaining.
func (r ApiBrowseRequest) WithBrowseParams(browseParams *BrowseParams) ApiBrowseRequest {
	r.browseParams = browseParams
	return r
}

/*
Browse calls the API and returns the raw response from it.

	Retrieves records from an index, up to 1,000 per request.

While searching retrieves _hits_ (records augmented with attributes for highlighting and ranking details),
browsing _just_ returns matching records.
This can be useful if you want to export your indices.

- The Analytics API doesn't collect data when using `browse`.
- Records are ranked by attributes and custom ranking.
- Deduplication (`distinct`) is turned off.
- There's no ranking for: typo-tolerance, number of matched words, proximity, geo distance.

	    Required API Key ACLs:
	    - browse

	Request can be constructed by NewApiBrowseRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param browseParams BrowseParams
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) BrowseWithHTTPInfo(ctx context.Context, r ApiBrowseRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/browse"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `Browse`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.browseParams) {
		postBody = "{}"
	} else {
		postBody = r.browseParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
Browse wraps BrowseWithContext using context.Background.

Retrieves records from an index, up to 1,000 per request.

While searching retrieves _hits_ (records augmented with attributes for highlighting and ranking details),
browsing _just_ returns matching records.
This can be useful if you want to export your indices.

- The Analytics API doesn't collect data when using `browse`.
- Records are ranked by attributes and custom ranking.
- Deduplication (`distinct`) is turned off.
- There's no ranking for: typo-tolerance, number of matched words, proximity, geo distance.

Required API Key ACLs:
  - browse

Request can be constructed by NewApiBrowseRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param browseParams BrowseParams
	@return BrowseResponse
*/
func (c *APIClient) Browse(r ApiBrowseRequest, opts ...Option) (*BrowseResponse, error) {
	return c.BrowseWithContext(context.Background(), r, opts...)
}

/*
Browse casts the HTTP response body to a defined struct.

Retrieves records from an index, up to 1,000 per request.

While searching retrieves _hits_ (records augmented with attributes for highlighting and ranking details),
browsing _just_ returns matching records.
This can be useful if you want to export your indices.

- The Analytics API doesn't collect data when using `browse`.
- Records are ranked by attributes and custom ranking.
- Deduplication (`distinct`) is turned off.
- There's no ranking for: typo-tolerance, number of matched words, proximity, geo distance.

Required API Key ACLs:
  - browse

Request can be constructed by NewApiBrowseRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param browseParams BrowseParams
	@return BrowseResponse
*/
func (c *APIClient) BrowseWithContext(ctx context.Context, r ApiBrowseRequest, opts ...Option) (*BrowseResponse, error) {
	var returnValue *BrowseResponse

	res, resBody, err := c.BrowseWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiClearObjectsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	return nil
}

// ApiClearObjectsRequest represents the request with all the parameters for the API call.
type ApiClearObjectsRequest struct {
	indexName string
}

// NewApiClearObjectsRequest creates an instance of the ApiClearObjectsRequest to be used for the API call.
func (c *APIClient) NewApiClearObjectsRequest(indexName string) ApiClearObjectsRequest {
	return ApiClearObjectsRequest{
		indexName: indexName,
	}
}

/*
ClearObjects calls the API and returns the raw response from it.

	  Deletes only the records from an index while keeping settings, synonyms, and rules.

	    Required API Key ACLs:
	    - deleteIndex

	Request can be constructed by NewApiClearObjectsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ClearObjectsWithHTTPInfo(ctx context.Context, r ApiClearObjectsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/clear"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `ClearObjects`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ClearObjects wraps ClearObjectsWithContext using context.Background.

Deletes only the records from an index while keeping settings, synonyms, and rules.

Required API Key ACLs:
  - deleteIndex

Request can be constructed by NewApiClearObjectsRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearObjects(r ApiClearObjectsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.ClearObjectsWithContext(context.Background(), r, opts...)
}

/*
ClearObjects casts the HTTP response body to a defined struct.

Deletes only the records from an index while keeping settings, synonyms, and rules.

Required API Key ACLs:
  - deleteIndex

Request can be constructed by NewApiClearObjectsRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearObjectsWithContext(ctx context.Context, r ApiClearObjectsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.ClearObjectsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiClearRulesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return fmt.Errorf("cannot unmarshal forwardToReplicas: %w", err)
			}
		}
	}

	return nil
}

// ApiClearRulesRequest represents the request with all the parameters for the API call.
type ApiClearRulesRequest struct {
	indexName         string
	forwardToReplicas *bool
}

// NewApiClearRulesRequest creates an instance of the ApiClearRulesRequest to be used for the API call.
func (c *APIClient) NewApiClearRulesRequest(indexName string) ApiClearRulesRequest {
	return ApiClearRulesRequest{
		indexName: indexName,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiClearRulesRequest and returns the request for chaining.
func (r ApiClearRulesRequest) WithForwardToReplicas(forwardToReplicas bool) ApiClearRulesRequest {
	r.forwardToReplicas = &forwardToReplicas
	return r
}

/*
ClearRules calls the API and returns the raw response from it.

	  Deletes all rules from the index.

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiClearRulesRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param forwardToReplicas bool - Whether changes are applied to replica indices.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ClearRulesWithHTTPInfo(ctx context.Context, r ApiClearRulesRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/rules/clear"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `ClearRules`.")
	}

	if !utils.IsNilOrEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", queryParameterToString(*r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ClearRules wraps ClearRulesWithContext using context.Background.

Deletes all rules from the index.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiClearRulesRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearRules(r ApiClearRulesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.ClearRulesWithContext(context.Background(), r, opts...)
}

/*
ClearRules casts the HTTP response body to a defined struct.

Deletes all rules from the index.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiClearRulesRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearRulesWithContext(ctx context.Context, r ApiClearRulesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.ClearRulesWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiClearSynonymsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return fmt.Errorf("cannot unmarshal forwardToReplicas: %w", err)
			}
		}
	}

	return nil
}

// ApiClearSynonymsRequest represents the request with all the parameters for the API call.
type ApiClearSynonymsRequest struct {
	indexName         string
	forwardToReplicas *bool
}

// NewApiClearSynonymsRequest creates an instance of the ApiClearSynonymsRequest to be used for the API call.
func (c *APIClient) NewApiClearSynonymsRequest(indexName string) ApiClearSynonymsRequest {
	return ApiClearSynonymsRequest{
		indexName: indexName,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiClearSynonymsRequest and returns the request for chaining.
func (r ApiClearSynonymsRequest) WithForwardToReplicas(forwardToReplicas bool) ApiClearSynonymsRequest {
	r.forwardToReplicas = &forwardToReplicas
	return r
}

/*
ClearSynonyms calls the API and returns the raw response from it.

	  Deletes all synonyms from the index.

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiClearSynonymsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param forwardToReplicas bool - Whether changes are applied to replica indices.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ClearSynonymsWithHTTPInfo(ctx context.Context, r ApiClearSynonymsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/synonyms/clear"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `ClearSynonyms`.")
	}

	if !utils.IsNilOrEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", queryParameterToString(*r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ClearSynonyms wraps ClearSynonymsWithContext using context.Background.

Deletes all synonyms from the index.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiClearSynonymsRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearSynonyms(r ApiClearSynonymsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.ClearSynonymsWithContext(context.Background(), r, opts...)
}

/*
ClearSynonyms casts the HTTP response body to a defined struct.

Deletes all synonyms from the index.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiClearSynonymsRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) ClearSynonymsWithContext(ctx context.Context, r ApiClearSynonymsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.ClearSynonymsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomDeleteRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomDeleteRequest represents the request with all the parameters for the API call.
type ApiCustomDeleteRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomDeleteRequest creates an instance of the ApiCustomDeleteRequest to be used for the API call.
func (c *APIClient) NewApiCustomDeleteRequest(path string) ApiCustomDeleteRequest {
	return ApiCustomDeleteRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomDeleteRequest and returns the request for chaining.
func (r ApiCustomDeleteRequest) WithParameters(parameters map[string]any) ApiCustomDeleteRequest {
	r.parameters = parameters
	return r
}

/*
CustomDelete calls the API and returns the raw response from it.

	  This method allow you to send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomDeleteRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param path string - Path of the endpoint, anything after \"/1\" must be specified.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomDeleteWithHTTPInfo(ctx context.Context, r ApiCustomDeleteRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomDelete wraps CustomDeleteWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomDelete(r ApiCustomDeleteRequest, opts ...Option) (*map[string]any, error) {
	return c.CustomDeleteWithContext(context.Background(), r, opts...)
}

/*
CustomDelete casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomDeleteWithContext(ctx context.Context, r ApiCustomDeleteRequest, opts ...Option) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomGetRequest represents the request with all the parameters for the API call.
type ApiCustomGetRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomGetRequest creates an instance of the ApiCustomGetRequest to be used for the API call.
func (c *APIClient) NewApiCustomGetRequest(path string) ApiCustomGetRequest {
	return ApiCustomGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomGetRequest and returns the request for chaining.
func (r ApiCustomGetRequest) WithParameters(parameters map[string]any) ApiCustomGetRequest {
	r.parameters = parameters
	return r
}

/*
CustomGet calls the API and returns the raw response from it.

	  This method allow you to send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomGetRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param path string - Path of the endpoint, anything after \"/1\" must be specified.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomGetWithHTTPInfo(ctx context.Context, r ApiCustomGetRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomGet wraps CustomGetWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomGet(r ApiCustomGetRequest, opts ...Option) (*map[string]any, error) {
	return c.CustomGetWithContext(context.Background(), r, opts...)
}

/*
CustomGet casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomGetWithContext(ctx context.Context, r ApiCustomGetRequest, opts ...Option) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPostRequest represents the request with all the parameters for the API call.
type ApiCustomPostRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPostRequest creates an instance of the ApiCustomPostRequest to be used for the API call.
func (c *APIClient) NewApiCustomPostRequest(path string) ApiCustomPostRequest {
	return ApiCustomPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithParameters(parameters map[string]any) ApiCustomPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithBody(body map[string]any) ApiCustomPostRequest {
	r.body = body
	return r
}

/*
CustomPost calls the API and returns the raw response from it.

	  This method allow you to send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomPostRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param path string - Path of the endpoint, anything after \"/1\" must be specified.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	  @param body map[string]any - Parameters to send with the custom request.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomPostWithHTTPInfo(ctx context.Context, r ApiCustomPostRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomPost wraps CustomPostWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPost(r ApiCustomPostRequest, opts ...Option) (*map[string]any, error) {
	return c.CustomPostWithContext(context.Background(), r, opts...)
}

/*
CustomPost casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPostWithContext(ctx context.Context, r ApiCustomPostRequest, opts ...Option) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPutRequest represents the request with all the parameters for the API call.
type ApiCustomPutRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPutRequest creates an instance of the ApiCustomPutRequest to be used for the API call.
func (c *APIClient) NewApiCustomPutRequest(path string) ApiCustomPutRequest {
	return ApiCustomPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithParameters(parameters map[string]any) ApiCustomPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithBody(body map[string]any) ApiCustomPutRequest {
	r.body = body
	return r
}

/*
CustomPut calls the API and returns the raw response from it.

	  This method allow you to send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomPutRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param path string - Path of the endpoint, anything after \"/1\" must be specified.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	  @param body map[string]any - Parameters to send with the custom request.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomPutWithHTTPInfo(ctx context.Context, r ApiCustomPutRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomPut wraps CustomPutWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPut(r ApiCustomPutRequest, opts ...Option) (*map[string]any, error) {
	return c.CustomPutWithContext(context.Background(), r, opts...)
}

/*
CustomPut casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPutWithContext(ctx context.Context, r ApiCustomPutRequest, opts ...Option) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["key"]; ok {
		err = json.Unmarshal(v, &r.key)
		if err != nil {
			err = json.Unmarshal(b, &r.key)
			if err != nil {
				return fmt.Errorf("cannot unmarshal key: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteApiKeyRequest represents the request with all the parameters for the API call.
type ApiDeleteApiKeyRequest struct {
	key string
}

// NewApiDeleteApiKeyRequest creates an instance of the ApiDeleteApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiDeleteApiKeyRequest(key string) ApiDeleteApiKeyRequest {
	return ApiDeleteApiKeyRequest{
		key: key,
	}
}

/*
DeleteApiKey calls the API and returns the raw response from it.

	  Deletes the API key.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiDeleteApiKeyRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param key string - API key.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteApiKeyWithHTTPInfo(ctx context.Context, r ApiDeleteApiKeyRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/keys/{key}"
	requestPath = strings.ReplaceAll(requestPath, "{key}", url.PathEscape(parameterToString(r.key)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.key == "" {
		return nil, nil, reportError("Parameter `key` is required when calling `DeleteApiKey`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteApiKey wraps DeleteApiKeyWithContext using context.Background.

Deletes the API key.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiDeleteApiKeyRequest with parameters below.

	@param key string - API key.
	@return DeleteApiKeyResponse
*/
func (c *APIClient) DeleteApiKey(r ApiDeleteApiKeyRequest, opts ...Option) (*DeleteApiKeyResponse, error) {
	return c.DeleteApiKeyWithContext(context.Background(), r, opts...)
}

/*
DeleteApiKey casts the HTTP response body to a defined struct.

Deletes the API key.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiDeleteApiKeyRequest with parameters below.

	@param key string - API key.
	@return DeleteApiKeyResponse
*/
func (c *APIClient) DeleteApiKeyWithContext(ctx context.Context, r ApiDeleteApiKeyRequest, opts ...Option) (*DeleteApiKeyResponse, error) {
	var returnValue *DeleteApiKeyResponse

	res, resBody, err := c.DeleteApiKeyWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteByRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["deleteByParams"]; ok {
		err = json.Unmarshal(v, &r.deleteByParams)
		if err != nil {
			err = json.Unmarshal(b, &r.deleteByParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal deleteByParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.deleteByParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter deleteByParams: %w", err)
		}
	}

	return nil
}

// ApiDeleteByRequest represents the request with all the parameters for the API call.
type ApiDeleteByRequest struct {
	indexName      string
	deleteByParams *DeleteByParams
}

// NewApiDeleteByRequest creates an instance of the ApiDeleteByRequest to be used for the API call.
func (c *APIClient) NewApiDeleteByRequest(indexName string, deleteByParams *DeleteByParams) ApiDeleteByRequest {
	return ApiDeleteByRequest{
		indexName:      indexName,
		deleteByParams: deleteByParams,
	}
}

/*
DeleteBy calls the API and returns the raw response from it.

	This operation doesn't accept empty queries or filters.

It's more efficient to get a list of object IDs with the [`browse` operation](#tag/Search/operation/browse),
and then delete the records using the [`batch` operation](tag/Records/operation/batch).

	    Required API Key ACLs:
	    - deleteIndex

	Request can be constructed by NewApiDeleteByRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param deleteByParams DeleteByParams
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteByWithHTTPInfo(ctx context.Context, r ApiDeleteByRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/deleteByQuery"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteBy`.")
	}

	if r.deleteByParams == nil {
		return nil, nil, reportError("Parameter `deleteByParams` is required when calling `DeleteBy`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.deleteByParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteBy wraps DeleteByWithContext using context.Background.

This operation doesn't accept empty queries or filters.

It's more efficient to get a list of object IDs with the [`browse` operation](#tag/Search/operation/browse),
and then delete the records using the [`batch` operation](tag/Records/operation/batch).

Required API Key ACLs:
  - deleteIndex

Request can be constructed by NewApiDeleteByRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param deleteByParams DeleteByParams
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteBy(r ApiDeleteByRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteByWithContext(context.Background(), r, opts...)
}

/*
DeleteBy casts the HTTP response body to a defined struct.

This operation doesn't accept empty queries or filters.

It's more efficient to get a list of object IDs with the [`browse` operation](#tag/Search/operation/browse),
and then delete the records using the [`batch` operation](tag/Records/operation/batch).

Required API Key ACLs:
  - deleteIndex

Request can be constructed by NewApiDeleteByRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param deleteByParams DeleteByParams
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteByWithContext(ctx context.Context, r ApiDeleteByRequest, opts ...Option) (*DeletedAtResponse, error) {
	var returnValue *DeletedAtResponse

	res, resBody, err := c.DeleteByWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteIndexRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteIndexRequest represents the request with all the parameters for the API call.
type ApiDeleteIndexRequest struct {
	indexName string
}

// NewApiDeleteIndexRequest creates an instance of the ApiDeleteIndexRequest to be used for the API call.
func (c *APIClient) NewApiDeleteIndexRequest(indexName string) ApiDeleteIndexRequest {
	return ApiDeleteIndexRequest{
		indexName: indexName,
	}
}

/*
DeleteIndex calls the API and returns the raw response from it.

		Deletes an index and all its settings.

	  - Deleting an index doesn't delete its analytics data.

	  - If you try to delete a non-existing index, the operation is ignored without warning.

	  - If the index you want to delete has replica indices, the replicas become independent indices.

	  - If the index you want to delete is a replica index, you must first unlink it from its primary index before you can delete it.
	    For more information, see [Delete replica indices](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/how-to/deleting-replicas/).

	    Required API Key ACLs:

	  - deleteIndex

	    Request can be constructed by NewApiDeleteIndexRequest with parameters below.
	    @param ctx context.Context - Context of the request
	    @param indexName string - Name of the index on which to perform the operation.
	    @param opts ...Option - Optional parameters for the API call
	    @return *http.Response - The raw response from the API
	    @return []byte - The raw response body from the API
	    @return error - An error if the API call fails
*/
func (c *APIClient) DeleteIndexWithHTTPInfo(ctx context.Context, r ApiDeleteIndexRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteIndex`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteIndex wraps DeleteIndexWithContext using context.Background.

Deletes an index and all its settings.

  - Deleting an index doesn't delete its analytics data.
  - If you try to delete a non-existing index, the operation is ignored without warning.
  - If the index you want to delete has replica indices, the replicas become independent indices.
  - If the index you want to delete is a replica index, you must first unlink it from its primary index before you can delete it.
    For more information, see [Delete replica indices](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/how-to/deleting-replicas/).

Required API Key ACLs:
  - deleteIndex

Request can be constructed by NewApiDeleteIndexRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteIndex(r ApiDeleteIndexRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteIndexWithContext(context.Background(), r, opts...)
}

/*
DeleteIndex casts the HTTP response body to a defined struct.

Deletes an index and all its settings.

  - Deleting an index doesn't delete its analytics data.
  - If you try to delete a non-existing index, the operation is ignored without warning.
  - If the index you want to delete has replica indices, the replicas become independent indices.
  - If the index you want to delete is a replica index, you must first unlink it from its primary index before you can delete it.
    For more information, see [Delete replica indices](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/how-to/deleting-replicas/).

Required API Key ACLs:
  - deleteIndex

Request can be constructed by NewApiDeleteIndexRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteIndexWithContext(ctx context.Context, r ApiDeleteIndexRequest, opts ...Option) (*DeletedAtResponse, error) {
	var returnValue *DeletedAtResponse

	res, resBody, err := c.DeleteIndexWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal objectID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteObjectRequest represents the request with all the parameters for the API call.
type ApiDeleteObjectRequest struct {
	indexName string
	objectID  string
}

// NewApiDeleteObjectRequest creates an instance of the ApiDeleteObjectRequest to be used for the API call.
func (c *APIClient) NewApiDeleteObjectRequest(indexName string, objectID string) ApiDeleteObjectRequest {
	return ApiDeleteObjectRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

/*
DeleteObject calls the API and returns the raw response from it.

	Deletes a record by its object ID.

To delete more than one record, use the [`batch` operation](#tag/Records/operation/batch).
To delete records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy).

	    Required API Key ACLs:
	    - deleteObject

	Request can be constructed by NewApiDeleteObjectRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param objectID string - Unique record identifier.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteObjectWithHTTPInfo(ctx context.Context, r ApiDeleteObjectRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(parameterToString(r.objectID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteObject`.")
	}
	if r.objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `DeleteObject`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteObject wraps DeleteObjectWithContext using context.Background.

Deletes a record by its object ID.

To delete more than one record, use the [`batch` operation](#tag/Records/operation/batch).
To delete records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy).

Required API Key ACLs:
  - deleteObject

Request can be constructed by NewApiDeleteObjectRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique record identifier.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteObject(r ApiDeleteObjectRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteObjectWithContext(context.Background(), r, opts...)
}

/*
DeleteObject casts the HTTP response body to a defined struct.

Deletes a record by its object ID.

To delete more than one record, use the [`batch` operation](#tag/Records/operation/batch).
To delete records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy).

Required API Key ACLs:
  - deleteObject

Request can be constructed by NewApiDeleteObjectRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique record identifier.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteObjectWithContext(ctx context.Context, r ApiDeleteObjectRequest, opts ...Option) (*DeletedAtResponse, error) {
	var returnValue *DeletedAtResponse

	res, resBody, err := c.DeleteObjectWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal objectID: %w", err)
			}
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return fmt.Errorf("cannot unmarshal forwardToReplicas: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteRuleRequest represents the request with all the parameters for the API call.
type ApiDeleteRuleRequest struct {
	indexName         string
	objectID          string
	forwardToReplicas *bool
}

// NewApiDeleteRuleRequest creates an instance of the ApiDeleteRuleRequest to be used for the API call.
func (c *APIClient) NewApiDeleteRuleRequest(indexName string, objectID string) ApiDeleteRuleRequest {
	return ApiDeleteRuleRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiDeleteRuleRequest and returns the request for chaining.
func (r ApiDeleteRuleRequest) WithForwardToReplicas(forwardToReplicas bool) ApiDeleteRuleRequest {
	r.forwardToReplicas = &forwardToReplicas
	return r
}

/*
DeleteRule calls the API and returns the raw response from it.

	Deletes a rule by its ID.

To find the object ID for rules,
use the [`search` operation](#tag/Rules/operation/searchRules).

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiDeleteRuleRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param objectID string - Unique identifier of a rule object.
	  @param forwardToReplicas bool - Whether changes are applied to replica indices.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteRuleWithHTTPInfo(ctx context.Context, r ApiDeleteRuleRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(parameterToString(r.objectID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteRule`.")
	}
	if r.objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `DeleteRule`.")
	}

	if !utils.IsNilOrEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", queryParameterToString(*r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteRule wraps DeleteRuleWithContext using context.Background.

Deletes a rule by its ID.
To find the object ID for rules,
use the [`search` operation](#tag/Rules/operation/searchRules).

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiDeleteRuleRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique identifier of a rule object.
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) DeleteRule(r ApiDeleteRuleRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.DeleteRuleWithContext(context.Background(), r, opts...)
}

/*
DeleteRule casts the HTTP response body to a defined struct.

Deletes a rule by its ID.
To find the object ID for rules,
use the [`search` operation](#tag/Rules/operation/searchRules).

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiDeleteRuleRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique identifier of a rule object.
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) DeleteRuleWithContext(ctx context.Context, r ApiDeleteRuleRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.DeleteRuleWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["source"]; ok {
		err = json.Unmarshal(v, &r.source)
		if err != nil {
			err = json.Unmarshal(b, &r.source)
			if err != nil {
				return fmt.Errorf("cannot unmarshal source: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteSourceRequest represents the request with all the parameters for the API call.
type ApiDeleteSourceRequest struct {
	source string
}

// NewApiDeleteSourceRequest creates an instance of the ApiDeleteSourceRequest to be used for the API call.
func (c *APIClient) NewApiDeleteSourceRequest(source string) ApiDeleteSourceRequest {
	return ApiDeleteSourceRequest{
		source: source,
	}
}

/*
DeleteSource calls the API and returns the raw response from it.

	  Deletes a source from the list of allowed sources.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiDeleteSourceRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param source string - IP address range of the source.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteSourceWithHTTPInfo(ctx context.Context, r ApiDeleteSourceRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/security/sources/{source}"
	requestPath = strings.ReplaceAll(requestPath, "{source}", url.PathEscape(parameterToString(r.source)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.source == "" {
		return nil, nil, reportError("Parameter `source` is required when calling `DeleteSource`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteSource wraps DeleteSourceWithContext using context.Background.

Deletes a source from the list of allowed sources.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param source string - IP address range of the source.
	@return DeleteSourceResponse
*/
func (c *APIClient) DeleteSource(r ApiDeleteSourceRequest, opts ...Option) (*DeleteSourceResponse, error) {
	return c.DeleteSourceWithContext(context.Background(), r, opts...)
}

/*
DeleteSource casts the HTTP response body to a defined struct.

Deletes a source from the list of allowed sources.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param source string - IP address range of the source.
	@return DeleteSourceResponse
*/
func (c *APIClient) DeleteSourceWithContext(ctx context.Context, r ApiDeleteSourceRequest, opts ...Option) (*DeleteSourceResponse, error) {
	var returnValue *DeleteSourceResponse

	res, resBody, err := c.DeleteSourceWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteSynonymRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal objectID: %w", err)
			}
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return fmt.Errorf("cannot unmarshal forwardToReplicas: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteSynonymRequest represents the request with all the parameters for the API call.
type ApiDeleteSynonymRequest struct {
	indexName         string
	objectID          string
	forwardToReplicas *bool
}

// NewApiDeleteSynonymRequest creates an instance of the ApiDeleteSynonymRequest to be used for the API call.
func (c *APIClient) NewApiDeleteSynonymRequest(indexName string, objectID string) ApiDeleteSynonymRequest {
	return ApiDeleteSynonymRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiDeleteSynonymRequest and returns the request for chaining.
func (r ApiDeleteSynonymRequest) WithForwardToReplicas(forwardToReplicas bool) ApiDeleteSynonymRequest {
	r.forwardToReplicas = &forwardToReplicas
	return r
}

/*
DeleteSynonym calls the API and returns the raw response from it.

	Deletes a synonym by its ID.

To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiDeleteSynonymRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param objectID string - Unique identifier of a synonym object.
	  @param forwardToReplicas bool - Whether changes are applied to replica indices.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteSynonymWithHTTPInfo(ctx context.Context, r ApiDeleteSynonymRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/synonyms/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(parameterToString(r.objectID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteSynonym`.")
	}
	if r.objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `DeleteSynonym`.")
	}

	if !utils.IsNilOrEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", queryParameterToString(*r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteSynonym wraps DeleteSynonymWithContext using context.Background.

Deletes a synonym by its ID.
To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiDeleteSynonymRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique identifier of a synonym object.
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteSynonym(r ApiDeleteSynonymRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteSynonymWithContext(context.Background(), r, opts...)
}

/*
DeleteSynonym casts the HTTP response body to a defined struct.

Deletes a synonym by its ID.
To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiDeleteSynonymRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique identifier of a synonym object.
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteSynonymWithContext(ctx context.Context, r ApiDeleteSynonymRequest, opts ...Option) (*DeletedAtResponse, error) {
	var returnValue *DeletedAtResponse

	res, resBody, err := c.DeleteSynonymWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["key"]; ok {
		err = json.Unmarshal(v, &r.key)
		if err != nil {
			err = json.Unmarshal(b, &r.key)
			if err != nil {
				return fmt.Errorf("cannot unmarshal key: %w", err)
			}
		}
	}

	return nil
}

// ApiGetApiKeyRequest represents the request with all the parameters for the API call.
type ApiGetApiKeyRequest struct {
	key string
}

// NewApiGetApiKeyRequest creates an instance of the ApiGetApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiGetApiKeyRequest(key string) ApiGetApiKeyRequest {
	return ApiGetApiKeyRequest{
		key: key,
	}
}

/*
GetApiKey calls the API and returns the raw response from it.

	Gets the permissions and restrictions of an API key.

When authenticating with the admin API key, you can request information for any of your application's keys.
When authenticating with other API keys, you can only retrieve information for that key.

	Request can be constructed by NewApiGetApiKeyRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param key string - API key.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetApiKeyWithHTTPInfo(ctx context.Context, r ApiGetApiKeyRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/keys/{key}"
	requestPath = strings.ReplaceAll(requestPath, "{key}", url.PathEscape(parameterToString(r.key)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.key == "" {
		return nil, nil, reportError("Parameter `key` is required when calling `GetApiKey`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetApiKey wraps GetApiKeyWithContext using context.Background.

Gets the permissions and restrictions of an API key.

When authenticating with the admin API key, you can request information for any of your application's keys.
When authenticating with other API keys, you can only retrieve information for that key.

Request can be constructed by NewApiGetApiKeyRequest with parameters below.

	@param key string - API key.
	@return GetApiKeyResponse
*/
func (c *APIClient) GetApiKey(r ApiGetApiKeyRequest, opts ...Option) (*GetApiKeyResponse, error) {
	return c.GetApiKeyWithContext(context.Background(), r, opts...)
}

/*
GetApiKey casts the HTTP response body to a defined struct.

Gets the permissions and restrictions of an API key.

When authenticating with the admin API key, you can request information for any of your application's keys.
When authenticating with other API keys, you can only retrieve information for that key.

Request can be constructed by NewApiGetApiKeyRequest with parameters below.

	@param key string - API key.
	@return GetApiKeyResponse
*/
func (c *APIClient) GetApiKeyWithContext(ctx context.Context, r ApiGetApiKeyRequest, opts ...Option) (*GetApiKeyResponse, error) {
	var returnValue *GetApiKeyResponse

	res, resBody, err := c.GetApiKeyWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetAppTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetAppTaskRequest represents the request with all the parameters for the API call.
type ApiGetAppTaskRequest struct {
	taskID int64
}

// NewApiGetAppTaskRequest creates an instance of the ApiGetAppTaskRequest to be used for the API call.
func (c *APIClient) NewApiGetAppTaskRequest(taskID int64) ApiGetAppTaskRequest {
	return ApiGetAppTaskRequest{
		taskID: taskID,
	}
}

/*
GetAppTask calls the API and returns the raw response from it.

	  Checks the status of a given application task.


	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiGetAppTaskRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param taskID int64 - Unique task identifier.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetAppTaskWithHTTPInfo(ctx context.Context, r ApiGetAppTaskRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/task/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetAppTask wraps GetAppTaskWithContext using context.Background.

Checks the status of a given application task.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiGetAppTaskRequest with parameters below.

	@param taskID int64 - Unique task identifier.
	@return GetTaskResponse
*/
func (c *APIClient) GetAppTask(r ApiGetAppTaskRequest, opts ...Option) (*GetTaskResponse, error) {
	return c.GetAppTaskWithContext(context.Background(), r, opts...)
}

/*
GetAppTask casts the HTTP response body to a defined struct.

Checks the status of a given application task.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiGetAppTaskRequest with parameters below.

	@param taskID int64 - Unique task identifier.
	@return GetTaskResponse
*/
func (c *APIClient) GetAppTaskWithContext(ctx context.Context, r ApiGetAppTaskRequest, opts ...Option) (*GetTaskResponse, error) {
	var returnValue *GetTaskResponse

	res, resBody, err := c.GetAppTaskWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetDictionaryLanguages calls the API and returns the raw response from it.

	  Lists supported languages with their supported dictionary types and number of custom entries.


	    Required API Key ACLs:
	    - settings

	Request can be constructed by NewApiGetDictionaryLanguagesRequest with parameters below.
	@param ctx context.Context - Context of the request
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetDictionaryLanguagesWithHTTPInfo(ctx context.Context, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/dictionaries/*/languages"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetDictionaryLanguages wraps GetDictionaryLanguagesWithContext using context.Background.

Lists supported languages with their supported dictionary types and number of custom entries.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetDictionaryLanguagesRequest with parameters below.

	@return map[string]Languages
*/
func (c *APIClient) GetDictionaryLanguages(opts ...Option) (*map[string]Languages, error) {
	return c.GetDictionaryLanguagesWithContext(context.Background(), opts...)
}

/*
GetDictionaryLanguages casts the HTTP response body to a defined struct.

Lists supported languages with their supported dictionary types and number of custom entries.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetDictionaryLanguagesRequest with parameters below.

	@return map[string]Languages
*/
func (c *APIClient) GetDictionaryLanguagesWithContext(ctx context.Context, opts ...Option) (*map[string]Languages, error) {
	var returnValue *map[string]Languages

	res, resBody, err := c.GetDictionaryLanguagesWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetDictionarySettings calls the API and returns the raw response from it.

	  Retrieves the languages for which standard dictionary entries are turned off.

	    Required API Key ACLs:
	    - settings

	Request can be constructed by NewApiGetDictionarySettingsRequest with parameters below.
	@param ctx context.Context - Context of the request
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetDictionarySettingsWithHTTPInfo(ctx context.Context, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/dictionaries/*/settings"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetDictionarySettings wraps GetDictionarySettingsWithContext using context.Background.

Retrieves the languages for which standard dictionary entries are turned off.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetDictionarySettingsRequest with parameters below.

	@return GetDictionarySettingsResponse
*/
func (c *APIClient) GetDictionarySettings(opts ...Option) (*GetDictionarySettingsResponse, error) {
	return c.GetDictionarySettingsWithContext(context.Background(), opts...)
}

/*
GetDictionarySettings casts the HTTP response body to a defined struct.

Retrieves the languages for which standard dictionary entries are turned off.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetDictionarySettingsRequest with parameters below.

	@return GetDictionarySettingsResponse
*/
func (c *APIClient) GetDictionarySettingsWithContext(ctx context.Context, opts ...Option) (*GetDictionarySettingsResponse, error) {
	var returnValue *GetDictionarySettingsResponse

	res, resBody, err := c.GetDictionarySettingsWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetLogsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["offset"]; ok {
		err = json.Unmarshal(v, &r.offset)
		if err != nil {
			err = json.Unmarshal(b, &r.offset)
			if err != nil {
				return fmt.Errorf("cannot unmarshal offset: %w", err)
			}
		}
	}
	if v, ok := req["length"]; ok {
		err = json.Unmarshal(v, &r.length)
		if err != nil {
			err = json.Unmarshal(b, &r.length)
			if err != nil {
				return fmt.Errorf("cannot unmarshal length: %w", err)
			}
		}
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}

	return nil
}

// ApiGetLogsRequest represents the request with all the parameters for the API call.
type ApiGetLogsRequest struct {
	offset    *int32
	length    *int32
	indexName *string
	type_     LogType
}

// NewApiGetLogsRequest creates an instance of the ApiGetLogsRequest to be used for the API call.
func (c *APIClient) NewApiGetLogsRequest() ApiGetLogsRequest {
	return ApiGetLogsRequest{}
}

// WithOffset adds the offset to the ApiGetLogsRequest and returns the request for chaining.
func (r ApiGetLogsRequest) WithOffset(offset int32) ApiGetLogsRequest {
	r.offset = &offset
	return r
}

// WithLength adds the length to the ApiGetLogsRequest and returns the request for chaining.
func (r ApiGetLogsRequest) WithLength(length int32) ApiGetLogsRequest {
	r.length = &length
	return r
}

// WithIndexName adds the indexName to the ApiGetLogsRequest and returns the request for chaining.
func (r ApiGetLogsRequest) WithIndexName(indexName string) ApiGetLogsRequest {
	r.indexName = &indexName
	return r
}

// WithType adds the type_ to the ApiGetLogsRequest and returns the request for chaining.
func (r ApiGetLogsRequest) WithType(type_ LogType) ApiGetLogsRequest {
	r.type_ = type_
	return r
}

/*
GetLogs calls the API and returns the raw response from it.

	The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).

- Logs are held for the last seven days.
- Up to 1,000 API requests per server are logged.
- This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself.

	    Required API Key ACLs:
	    - logs

	Request can be constructed by NewApiGetLogsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param offset int32 - First log entry to retrieve. The most recent entries are listed first.
	  @param length int32 - Maximum number of entries to retrieve.
	  @param indexName string - Index for which to retrieve log entries. By default, log entries are retrieved for all indices.
	  @param type_ LogType - Type of log entries to retrieve. By default, all log entries are retrieved.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetLogsWithHTTPInfo(ctx context.Context, r ApiGetLogsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/logs"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.offset) {
		queryParams.Set("offset", queryParameterToString(*r.offset))
	}
	if !utils.IsNilOrEmpty(r.length) {
		queryParams.Set("length", queryParameterToString(*r.length))
	}
	if !utils.IsNilOrEmpty(r.indexName) {
		queryParams.Set("indexName", queryParameterToString(*r.indexName))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		queryParams.Set("type", queryParameterToString(r.type_))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetLogs wraps GetLogsWithContext using context.Background.

The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).

- Logs are held for the last seven days.
- Up to 1,000 API requests per server are logged.
- This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself.

Required API Key ACLs:
  - logs

Request can be constructed by NewApiGetLogsRequest with parameters below.

	@param offset int32 - First log entry to retrieve. The most recent entries are listed first.
	@param length int32 - Maximum number of entries to retrieve.
	@param indexName string - Index for which to retrieve log entries. By default, log entries are retrieved for all indices.
	@param type_ LogType - Type of log entries to retrieve. By default, all log entries are retrieved.
	@return GetLogsResponse
*/
func (c *APIClient) GetLogs(r ApiGetLogsRequest, opts ...Option) (*GetLogsResponse, error) {
	return c.GetLogsWithContext(context.Background(), r, opts...)
}

/*
GetLogs casts the HTTP response body to a defined struct.

The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).

- Logs are held for the last seven days.
- Up to 1,000 API requests per server are logged.
- This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself.

Required API Key ACLs:
  - logs

Request can be constructed by NewApiGetLogsRequest with parameters below.

	@param offset int32 - First log entry to retrieve. The most recent entries are listed first.
	@param length int32 - Maximum number of entries to retrieve.
	@param indexName string - Index for which to retrieve log entries. By default, log entries are retrieved for all indices.
	@param type_ LogType - Type of log entries to retrieve. By default, all log entries are retrieved.
	@return GetLogsResponse
*/
func (c *APIClient) GetLogsWithContext(ctx context.Context, r ApiGetLogsRequest, opts ...Option) (*GetLogsResponse, error) {
	var returnValue *GetLogsResponse

	res, resBody, err := c.GetLogsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal objectID: %w", err)
			}
		}
	}
	if v, ok := req["attributesToRetrieve"]; ok {
		err = json.Unmarshal(v, &r.attributesToRetrieve)
		if err != nil {
			err = json.Unmarshal(b, &r.attributesToRetrieve)
			if err != nil {
				return fmt.Errorf("cannot unmarshal attributesToRetrieve: %w", err)
			}
		}
	}

	return nil
}

// ApiGetObjectRequest represents the request with all the parameters for the API call.
type ApiGetObjectRequest struct {
	indexName            string
	objectID             string
	attributesToRetrieve []string
}

// NewApiGetObjectRequest creates an instance of the ApiGetObjectRequest to be used for the API call.
func (c *APIClient) NewApiGetObjectRequest(indexName string, objectID string) ApiGetObjectRequest {
	return ApiGetObjectRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

// WithAttributesToRetrieve adds the attributesToRetrieve to the ApiGetObjectRequest and returns the request for chaining.
func (r ApiGetObjectRequest) WithAttributesToRetrieve(attributesToRetrieve []string) ApiGetObjectRequest {
	r.attributesToRetrieve = attributesToRetrieve
	return r
}

/*
GetObject calls the API and returns the raw response from it.

	Retrieves one record by its object ID.

To retrieve more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).

	    Required API Key ACLs:
	    - search

	Request can be constructed by NewApiGetObjectRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param objectID string - Unique record identifier.
	  @param attributesToRetrieve []string - Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned.  `objectID` is always retrieved.  Attributes included in `unretrievableAttributes` won't be retrieved unless the request is authenticated with the admin API key.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetObjectWithHTTPInfo(ctx context.Context, r ApiGetObjectRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(parameterToString(r.objectID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetObject`.")
	}
	if r.objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `GetObject`.")
	}

	if !utils.IsNilOrEmpty(r.attributesToRetrieve) {
		queryParams.Set("attributesToRetrieve", queryParameterToString(r.attributesToRetrieve))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetObject wraps GetObjectWithContext using context.Background.

Retrieves one record by its object ID.

To retrieve more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).

Required API Key ACLs:
  - search

Request can be constructed by NewApiGetObjectRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique record identifier.
	@param attributesToRetrieve []string - Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned.  `objectID` is always retrieved.  Attributes included in `unretrievableAttributes` won't be retrieved unless the request is authenticated with the admin API key.
	@return map[string]string
*/
func (c *APIClient) GetObject(r ApiGetObjectRequest, opts ...Option) (map[string]string, error) {
	return c.GetObjectWithContext(context.Background(), r, opts...)
}

/*
GetObject casts the HTTP response body to a defined struct.

Retrieves one record by its object ID.

To retrieve more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).

Required API Key ACLs:
  - search

Request can be constructed by NewApiGetObjectRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique record identifier.
	@param attributesToRetrieve []string - Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned.  `objectID` is always retrieved.  Attributes included in `unretrievableAttributes` won't be retrieved unless the request is authenticated with the admin API key.
	@return map[string]string
*/
func (c *APIClient) GetObjectWithContext(ctx context.Context, r ApiGetObjectRequest, opts ...Option) (map[string]string, error) {
	var returnValue map[string]string

	res, resBody, err := c.GetObjectWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetObjectsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["getObjectsParams"]; ok {
		err = json.Unmarshal(v, &r.getObjectsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.getObjectsParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal getObjectsParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.getObjectsParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter getObjectsParams: %w", err)
		}
	}

	return nil
}

// ApiGetObjectsRequest represents the request with all the parameters for the API call.
type ApiGetObjectsRequest struct {
	getObjectsParams *GetObjectsParams
}

// NewApiGetObjectsRequest creates an instance of the ApiGetObjectsRequest to be used for the API call.
func (c *APIClient) NewApiGetObjectsRequest(getObjectsParams *GetObjectsParams) ApiGetObjectsRequest {
	return ApiGetObjectsRequest{
		getObjectsParams: getObjectsParams,
	}
}

/*
GetObjects calls the API and returns the raw response from it.

	Retrieves one or more records, potentially from different indices.

Records are returned in the same order as the requests.

	    Required API Key ACLs:
	    - search

	Request can be constructed by NewApiGetObjectsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param getObjectsParams GetObjectsParams - Request object.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetObjectsWithHTTPInfo(ctx context.Context, r ApiGetObjectsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/*/objects"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.getObjectsParams == nil {
		return nil, nil, reportError("Parameter `getObjectsParams` is required when calling `GetObjects`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.getObjectsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true)
}

/*
GetObjects wraps GetObjectsWithContext using context.Background.

Retrieves one or more records, potentially from different indices.

Records are returned in the same order as the requests.

Required API Key ACLs:
  - search

Request can be constructed by NewApiGetObjectsRequest with parameters below.

	@param getObjectsParams GetObjectsParams - Request object.
	@return GetObjectsResponse
*/
func (c *APIClient) GetObjects(r ApiGetObjectsRequest, opts ...Option) (*GetObjectsResponse, error) {
	return c.GetObjectsWithContext(context.Background(), r, opts...)
}

/*
GetObjects casts the HTTP response body to a defined struct.

Retrieves one or more records, potentially from different indices.

Records are returned in the same order as the requests.

Required API Key ACLs:
  - search

Request can be constructed by NewApiGetObjectsRequest with parameters below.

	@param getObjectsParams GetObjectsParams - Request object.
	@return GetObjectsResponse
*/
func (c *APIClient) GetObjectsWithContext(ctx context.Context, r ApiGetObjectsRequest, opts ...Option) (*GetObjectsResponse, error) {
	var returnValue *GetObjectsResponse

	res, resBody, err := c.GetObjectsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal objectID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetRuleRequest represents the request with all the parameters for the API call.
type ApiGetRuleRequest struct {
	indexName string
	objectID  string
}

// NewApiGetRuleRequest creates an instance of the ApiGetRuleRequest to be used for the API call.
func (c *APIClient) NewApiGetRuleRequest(indexName string, objectID string) ApiGetRuleRequest {
	return ApiGetRuleRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

/*
GetRule calls the API and returns the raw response from it.

	Retrieves a rule by its ID.

To find the object ID of rules, use the [`search` operation](#tag/Rules/operation/searchRules).

	    Required API Key ACLs:
	    - settings

	Request can be constructed by NewApiGetRuleRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param objectID string - Unique identifier of a rule object.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetRuleWithHTTPInfo(ctx context.Context, r ApiGetRuleRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(parameterToString(r.objectID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetRule`.")
	}
	if r.objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `GetRule`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetRule wraps GetRuleWithContext using context.Background.

Retrieves a rule by its ID.
To find the object ID of rules, use the [`search` operation](#tag/Rules/operation/searchRules).

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetRuleRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique identifier of a rule object.
	@return Rule
*/
func (c *APIClient) GetRule(r ApiGetRuleRequest, opts ...Option) (*Rule, error) {
	return c.GetRuleWithContext(context.Background(), r, opts...)
}

/*
GetRule casts the HTTP response body to a defined struct.

Retrieves a rule by its ID.
To find the object ID of rules, use the [`search` operation](#tag/Rules/operation/searchRules).

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetRuleRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique identifier of a rule object.
	@return Rule
*/
func (c *APIClient) GetRuleWithContext(ctx context.Context, r ApiGetRuleRequest, opts ...Option) (*Rule, error) {
	var returnValue *Rule

	res, resBody, err := c.GetRuleWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSettingsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSettingsRequest represents the request with all the parameters for the API call.
type ApiGetSettingsRequest struct {
	indexName string
}

// NewApiGetSettingsRequest creates an instance of the ApiGetSettingsRequest to be used for the API call.
func (c *APIClient) NewApiGetSettingsRequest(indexName string) ApiGetSettingsRequest {
	return ApiGetSettingsRequest{
		indexName: indexName,
	}
}

/*
GetSettings calls the API and returns the raw response from it.

	  Retrieves an object with non-null index settings.

	    Required API Key ACLs:
	    - search

	Request can be constructed by NewApiGetSettingsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetSettingsWithHTTPInfo(ctx context.Context, r ApiGetSettingsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/settings"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetSettings`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetSettings wraps GetSettingsWithContext using context.Background.

Retrieves an object with non-null index settings.

Required API Key ACLs:
  - search

Request can be constructed by NewApiGetSettingsRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@return IndexSettings
*/
func (c *APIClient) GetSettings(r ApiGetSettingsRequest, opts ...Option) (*IndexSettings, error) {
	return c.GetSettingsWithContext(context.Background(), r, opts...)
}

/*
GetSettings casts the HTTP response body to a defined struct.

Retrieves an object with non-null index settings.

Required API Key ACLs:
  - search

Request can be constructed by NewApiGetSettingsRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@return IndexSettings
*/
func (c *APIClient) GetSettingsWithContext(ctx context.Context, r ApiGetSettingsRequest, opts ...Option) (*IndexSettings, error) {
	var returnValue *IndexSettings

	res, resBody, err := c.GetSettingsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetSources calls the API and returns the raw response from it.

	  Retrieves all allowed IP addresses with access to your application.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiGetSourcesRequest with parameters below.
	@param ctx context.Context - Context of the request
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetSourcesWithHTTPInfo(ctx context.Context, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/security/sources"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetSources wraps GetSourcesWithContext using context.Background.

Retrieves all allowed IP addresses with access to your application.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@return []Source
*/
func (c *APIClient) GetSources(opts ...Option) ([]Source, error) {
	return c.GetSourcesWithContext(context.Background(), opts...)
}

/*
GetSources casts the HTTP response body to a defined struct.

Retrieves all allowed IP addresses with access to your application.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@return []Source
*/
func (c *APIClient) GetSourcesWithContext(ctx context.Context, opts ...Option) ([]Source, error) {
	var returnValue []Source

	res, resBody, err := c.GetSourcesWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSynonymRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal objectID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSynonymRequest represents the request with all the parameters for the API call.
type ApiGetSynonymRequest struct {
	indexName string
	objectID  string
}

// NewApiGetSynonymRequest creates an instance of the ApiGetSynonymRequest to be used for the API call.
func (c *APIClient) NewApiGetSynonymRequest(indexName string, objectID string) ApiGetSynonymRequest {
	return ApiGetSynonymRequest{
		indexName: indexName,
		objectID:  objectID,
	}
}

/*
GetSynonym calls the API and returns the raw response from it.

	Retrieves a syonym by its ID.

To find the object IDs for your synonyms,
use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

	    Required API Key ACLs:
	    - settings

	Request can be constructed by NewApiGetSynonymRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param objectID string - Unique identifier of a synonym object.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetSynonymWithHTTPInfo(ctx context.Context, r ApiGetSynonymRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/synonyms/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(parameterToString(r.objectID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetSynonym`.")
	}
	if r.objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `GetSynonym`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetSynonym wraps GetSynonymWithContext using context.Background.

Retrieves a syonym by its ID.
To find the object IDs for your synonyms,
use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetSynonymRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique identifier of a synonym object.
	@return SynonymHit
*/
func (c *APIClient) GetSynonym(r ApiGetSynonymRequest, opts ...Option) (*SynonymHit, error) {
	return c.GetSynonymWithContext(context.Background(), r, opts...)
}

/*
GetSynonym casts the HTTP response body to a defined struct.

Retrieves a syonym by its ID.
To find the object IDs for your synonyms,
use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetSynonymRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique identifier of a synonym object.
	@return SynonymHit
*/
func (c *APIClient) GetSynonymWithContext(ctx context.Context, r ApiGetSynonymRequest, opts ...Option) (*SynonymHit, error) {
	var returnValue *SynonymHit

	res, resBody, err := c.GetSynonymWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTaskRequest represents the request with all the parameters for the API call.
type ApiGetTaskRequest struct {
	indexName string
	taskID    int64
}

// NewApiGetTaskRequest creates an instance of the ApiGetTaskRequest to be used for the API call.
func (c *APIClient) NewApiGetTaskRequest(indexName string, taskID int64) ApiGetTaskRequest {
	return ApiGetTaskRequest{
		indexName: indexName,
		taskID:    taskID,
	}
}

/*
GetTask calls the API and returns the raw response from it.

	Checks the status of a given task.

Indexing tasks are asynchronous.
When you add, update, or delete records or indices,
a task is created on a queue and completed depending on the load on the server.

The indexing tasks' responses include a task ID that you can use to check the status.

	    Required API Key ACLs:
	    - addObject

	Request can be constructed by NewApiGetTaskRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param taskID int64 - Unique task identifier.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTaskWithHTTPInfo(ctx context.Context, r ApiGetTaskRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/task/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetTask wraps GetTaskWithContext using context.Background.

Checks the status of a given task.

Indexing tasks are asynchronous.
When you add, update, or delete records or indices,
a task is created on a queue and completed depending on the load on the server.

The indexing tasks' responses include a task ID that you can use to check the status.

Required API Key ACLs:
  - addObject

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param taskID int64 - Unique task identifier.
	@return GetTaskResponse
*/
func (c *APIClient) GetTask(r ApiGetTaskRequest, opts ...Option) (*GetTaskResponse, error) {
	return c.GetTaskWithContext(context.Background(), r, opts...)
}

/*
GetTask casts the HTTP response body to a defined struct.

Checks the status of a given task.

Indexing tasks are asynchronous.
When you add, update, or delete records or indices,
a task is created on a queue and completed depending on the load on the server.

The indexing tasks' responses include a task ID that you can use to check the status.

Required API Key ACLs:
  - addObject

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param taskID int64 - Unique task identifier.
	@return GetTaskResponse
*/
func (c *APIClient) GetTaskWithContext(ctx context.Context, r ApiGetTaskRequest, opts ...Option) (*GetTaskResponse, error) {
	var returnValue *GetTaskResponse

	res, resBody, err := c.GetTaskWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetTopUserIds calls the API and returns the raw response from it.

	Get the IDs of the 10 users with the highest number of records per cluster.

Since it can take a few seconds to get the data from the different clusters,
the response isn't real-time.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiGetTopUserIdsRequest with parameters below.
	@param ctx context.Context - Context of the request
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTopUserIdsWithHTTPInfo(ctx context.Context, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/clusters/mapping/top"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetTopUserIds wraps GetTopUserIdsWithContext using context.Background.

Get the IDs of the 10 users with the highest number of records per cluster.

Since it can take a few seconds to get the data from the different clusters,
the response isn't real-time.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiGetTopUserIdsRequest with parameters below.

	@return GetTopUserIdsResponse
*/
func (c *APIClient) GetTopUserIds(opts ...Option) (*GetTopUserIdsResponse, error) {
	return c.GetTopUserIdsWithContext(context.Background(), opts...)
}

/*
GetTopUserIds casts the HTTP response body to a defined struct.

Get the IDs of the 10 users with the highest number of records per cluster.

Since it can take a few seconds to get the data from the different clusters,
the response isn't real-time.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiGetTopUserIdsRequest with parameters below.

	@return GetTopUserIdsResponse
*/
func (c *APIClient) GetTopUserIdsWithContext(ctx context.Context, opts ...Option) (*GetTopUserIdsResponse, error) {
	var returnValue *GetTopUserIdsResponse

	res, resBody, err := c.GetTopUserIdsWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetUserIdRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["userID"]; ok {
		err = json.Unmarshal(v, &r.userID)
		if err != nil {
			err = json.Unmarshal(b, &r.userID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal userID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetUserIdRequest represents the request with all the parameters for the API call.
type ApiGetUserIdRequest struct {
	userID string
}

// NewApiGetUserIdRequest creates an instance of the ApiGetUserIdRequest to be used for the API call.
func (c *APIClient) NewApiGetUserIdRequest(userID string) ApiGetUserIdRequest {
	return ApiGetUserIdRequest{
		userID: userID,
	}
}

/*
GetUserId calls the API and returns the raw response from it.

	Returns the user ID data stored in the mapping.

Since it can take a few seconds to get the data from the different clusters,
the response isn't real-time.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiGetUserIdRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param userID string - Unique identifier of the user who makes the search request.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetUserIdWithHTTPInfo(ctx context.Context, r ApiGetUserIdRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/clusters/mapping/{userID}"
	requestPath = strings.ReplaceAll(requestPath, "{userID}", url.PathEscape(parameterToString(r.userID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.userID == "" {
		return nil, nil, reportError("Parameter `userID` is required when calling `GetUserId`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetUserId wraps GetUserIdWithContext using context.Background.

Returns the user ID data stored in the mapping.

Since it can take a few seconds to get the data from the different clusters,
the response isn't real-time.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiGetUserIdRequest with parameters below.

	@param userID string - Unique identifier of the user who makes the search request.
	@return UserId
*/
func (c *APIClient) GetUserId(r ApiGetUserIdRequest, opts ...Option) (*UserId, error) {
	return c.GetUserIdWithContext(context.Background(), r, opts...)
}

/*
GetUserId casts the HTTP response body to a defined struct.

Returns the user ID data stored in the mapping.

Since it can take a few seconds to get the data from the different clusters,
the response isn't real-time.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiGetUserIdRequest with parameters below.

	@param userID string - Unique identifier of the user who makes the search request.
	@return UserId
*/
func (c *APIClient) GetUserIdWithContext(ctx context.Context, r ApiGetUserIdRequest, opts ...Option) (*UserId, error) {
	var returnValue *UserId

	res, resBody, err := c.GetUserIdWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiHasPendingMappingsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["getClusters"]; ok {
		err = json.Unmarshal(v, &r.getClusters)
		if err != nil {
			err = json.Unmarshal(b, &r.getClusters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal getClusters: %w", err)
			}
		}
	}

	return nil
}

// ApiHasPendingMappingsRequest represents the request with all the parameters for the API call.
type ApiHasPendingMappingsRequest struct {
	getClusters *bool
}

// NewApiHasPendingMappingsRequest creates an instance of the ApiHasPendingMappingsRequest to be used for the API call.
func (c *APIClient) NewApiHasPendingMappingsRequest() ApiHasPendingMappingsRequest {
	return ApiHasPendingMappingsRequest{}
}

// WithGetClusters adds the getClusters to the ApiHasPendingMappingsRequest and returns the request for chaining.
func (r ApiHasPendingMappingsRequest) WithGetClusters(getClusters bool) ApiHasPendingMappingsRequest {
	r.getClusters = &getClusters
	return r
}

/*
HasPendingMappings calls the API and returns the raw response from it.

	  To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.


	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiHasPendingMappingsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param getClusters bool - Whether to include the cluster's pending mapping state in the response.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) HasPendingMappingsWithHTTPInfo(ctx context.Context, r ApiHasPendingMappingsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/clusters/mapping/pending"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.getClusters) {
		queryParams.Set("getClusters", queryParameterToString(*r.getClusters))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
HasPendingMappings wraps HasPendingMappingsWithContext using context.Background.

To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiHasPendingMappingsRequest with parameters below.

	@param getClusters bool - Whether to include the cluster's pending mapping state in the response.
	@return HasPendingMappingsResponse
*/
func (c *APIClient) HasPendingMappings(r ApiHasPendingMappingsRequest, opts ...Option) (*HasPendingMappingsResponse, error) {
	return c.HasPendingMappingsWithContext(context.Background(), r, opts...)
}

/*
HasPendingMappings casts the HTTP response body to a defined struct.

To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiHasPendingMappingsRequest with parameters below.

	@param getClusters bool - Whether to include the cluster's pending mapping state in the response.
	@return HasPendingMappingsResponse
*/
func (c *APIClient) HasPendingMappingsWithContext(ctx context.Context, r ApiHasPendingMappingsRequest, opts ...Option) (*HasPendingMappingsResponse, error) {
	var returnValue *HasPendingMappingsResponse

	res, resBody, err := c.HasPendingMappingsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
ListApiKeys calls the API and returns the raw response from it.

	  Lists all API keys associated with your Algolia application, including their permissions and restrictions.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiListApiKeysRequest with parameters below.
	@param ctx context.Context - Context of the request
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListApiKeysWithHTTPInfo(ctx context.Context, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/keys"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListApiKeys wraps ListApiKeysWithContext using context.Background.

Lists all API keys associated with your Algolia application, including their permissions and restrictions.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiListApiKeysRequest with parameters below.

	@return ListApiKeysResponse
*/
func (c *APIClient) ListApiKeys(opts ...Option) (*ListApiKeysResponse, error) {
	return c.ListApiKeysWithContext(context.Background(), opts...)
}

/*
ListApiKeys casts the HTTP response body to a defined struct.

Lists all API keys associated with your Algolia application, including their permissions and restrictions.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiListApiKeysRequest with parameters below.

	@return ListApiKeysResponse
*/
func (c *APIClient) ListApiKeysWithContext(ctx context.Context, opts ...Option) (*ListApiKeysResponse, error) {
	var returnValue *ListApiKeysResponse

	res, resBody, err := c.ListApiKeysWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
ListClusters calls the API and returns the raw response from it.

	  Lists the available clusters in a multi-cluster setup.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiListClustersRequest with parameters below.
	@param ctx context.Context - Context of the request
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListClustersWithHTTPInfo(ctx context.Context, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/clusters"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListClusters wraps ListClustersWithContext using context.Background.

Lists the available clusters in a multi-cluster setup.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiListClustersRequest with parameters below.

	@return ListClustersResponse
*/
func (c *APIClient) ListClusters(opts ...Option) (*ListClustersResponse, error) {
	return c.ListClustersWithContext(context.Background(), opts...)
}

/*
ListClusters casts the HTTP response body to a defined struct.

Lists the available clusters in a multi-cluster setup.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiListClustersRequest with parameters below.

	@return ListClustersResponse
*/
func (c *APIClient) ListClustersWithContext(ctx context.Context, opts ...Option) (*ListClustersResponse, error) {
	var returnValue *ListClustersResponse

	res, resBody, err := c.ListClustersWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListIndicesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["hitsPerPage"]; ok {
		err = json.Unmarshal(v, &r.hitsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.hitsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal hitsPerPage: %w", err)
			}
		}
	}

	return nil
}

// ApiListIndicesRequest represents the request with all the parameters for the API call.
type ApiListIndicesRequest struct {
	page        *int32
	hitsPerPage *int32
}

// NewApiListIndicesRequest creates an instance of the ApiListIndicesRequest to be used for the API call.
func (c *APIClient) NewApiListIndicesRequest() ApiListIndicesRequest {
	return ApiListIndicesRequest{}
}

// WithPage adds the page to the ApiListIndicesRequest and returns the request for chaining.
func (r ApiListIndicesRequest) WithPage(page int32) ApiListIndicesRequest {
	r.page = &page
	return r
}

// WithHitsPerPage adds the hitsPerPage to the ApiListIndicesRequest and returns the request for chaining.
func (r ApiListIndicesRequest) WithHitsPerPage(hitsPerPage int32) ApiListIndicesRequest {
	r.hitsPerPage = &hitsPerPage
	return r
}

/*
ListIndices calls the API and returns the raw response from it.

	Lists all indices in the current Algolia application.

The request follows any index restrictions of the API key you use to make the request.

	    Required API Key ACLs:
	    - listIndexes

	Request can be constructed by NewApiListIndicesRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param page int32 - Requested page of the API response. If `null`, the API response is not paginated.
	  @param hitsPerPage int32 - Number of hits per page.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListIndicesWithHTTPInfo(ctx context.Context, r ApiListIndicesRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.hitsPerPage) {
		queryParams.Set("hitsPerPage", queryParameterToString(*r.hitsPerPage))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListIndices wraps ListIndicesWithContext using context.Background.

Lists all indices in the current Algolia application.

The request follows any index restrictions of the API key you use to make the request.

Required API Key ACLs:
  - listIndexes

Request can be constructed by NewApiListIndicesRequest with parameters below.

	@param page int32 - Requested page of the API response. If `null`, the API response is not paginated.
	@param hitsPerPage int32 - Number of hits per page.
	@return ListIndicesResponse
*/
func (c *APIClient) ListIndices(r ApiListIndicesRequest, opts ...Option) (*ListIndicesResponse, error) {
	return c.ListIndicesWithContext(context.Background(), r, opts...)
}

/*
ListIndices casts the HTTP response body to a defined struct.

Lists all indices in the current Algolia application.

The request follows any index restrictions of the API key you use to make the request.

Required API Key ACLs:
  - listIndexes

Request can be constructed by NewApiListIndicesRequest with parameters below.

	@param page int32 - Requested page of the API response. If `null`, the API response is not paginated.
	@param hitsPerPage int32 - Number of hits per page.
	@return ListIndicesResponse
*/
func (c *APIClient) ListIndicesWithContext(ctx context.Context, r ApiListIndicesRequest, opts ...Option) (*ListIndicesResponse, error) {
	var returnValue *ListIndicesResponse

	res, resBody, err := c.ListIndicesWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListUserIdsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["hitsPerPage"]; ok {
		err = json.Unmarshal(v, &r.hitsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.hitsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal hitsPerPage: %w", err)
			}
		}
	}

	return nil
}

// ApiListUserIdsRequest represents the request with all the parameters for the API call.
type ApiListUserIdsRequest struct {
	page        *int32
	hitsPerPage *int32
}

// NewApiListUserIdsRequest creates an instance of the ApiListUserIdsRequest to be used for the API call.
func (c *APIClient) NewApiListUserIdsRequest() ApiListUserIdsRequest {
	return ApiListUserIdsRequest{}
}

// WithPage adds the page to the ApiListUserIdsRequest and returns the request for chaining.
func (r ApiListUserIdsRequest) WithPage(page int32) ApiListUserIdsRequest {
	r.page = &page
	return r
}

// WithHitsPerPage adds the hitsPerPage to the ApiListUserIdsRequest and returns the request for chaining.
func (r ApiListUserIdsRequest) WithHitsPerPage(hitsPerPage int32) ApiListUserIdsRequest {
	r.hitsPerPage = &hitsPerPage
	return r
}

/*
ListUserIds calls the API and returns the raw response from it.

	Lists the userIDs assigned to a multi-cluster application.

Since it can take a few seconds to get the data from the different clusters,
the response isn't real-time.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiListUserIdsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param page int32 - Requested page of the API response. If `null`, the API response is not paginated.
	  @param hitsPerPage int32 - Number of hits per page.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListUserIdsWithHTTPInfo(ctx context.Context, r ApiListUserIdsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/clusters/mapping"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.hitsPerPage) {
		queryParams.Set("hitsPerPage", queryParameterToString(*r.hitsPerPage))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListUserIds wraps ListUserIdsWithContext using context.Background.

Lists the userIDs assigned to a multi-cluster application.

Since it can take a few seconds to get the data from the different clusters,
the response isn't real-time.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiListUserIdsRequest with parameters below.

	@param page int32 - Requested page of the API response. If `null`, the API response is not paginated.
	@param hitsPerPage int32 - Number of hits per page.
	@return ListUserIdsResponse
*/
func (c *APIClient) ListUserIds(r ApiListUserIdsRequest, opts ...Option) (*ListUserIdsResponse, error) {
	return c.ListUserIdsWithContext(context.Background(), r, opts...)
}

/*
ListUserIds casts the HTTP response body to a defined struct.

Lists the userIDs assigned to a multi-cluster application.

Since it can take a few seconds to get the data from the different clusters,
the response isn't real-time.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiListUserIdsRequest with parameters below.

	@param page int32 - Requested page of the API response. If `null`, the API response is not paginated.
	@param hitsPerPage int32 - Number of hits per page.
	@return ListUserIdsResponse
*/
func (c *APIClient) ListUserIdsWithContext(ctx context.Context, r ApiListUserIdsRequest, opts ...Option) (*ListUserIdsResponse, error) {
	var returnValue *ListUserIdsResponse

	res, resBody, err := c.ListUserIdsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiMultipleBatchRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["batchParams"]; ok {
		err = json.Unmarshal(v, &r.batchParams)
		if err != nil {
			err = json.Unmarshal(b, &r.batchParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal batchParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.batchParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter batchParams: %w", err)
		}
	}

	return nil
}

// ApiMultipleBatchRequest represents the request with all the parameters for the API call.
type ApiMultipleBatchRequest struct {
	batchParams *BatchParams
}

// NewApiMultipleBatchRequest creates an instance of the ApiMultipleBatchRequest to be used for the API call.
func (c *APIClient) NewApiMultipleBatchRequest(batchParams *BatchParams) ApiMultipleBatchRequest {
	return ApiMultipleBatchRequest{
		batchParams: batchParams,
	}
}

/*
MultipleBatch calls the API and returns the raw response from it.

	Adds, updates, or deletes records in multiple indices with a single API request.

- Actions are applied in the order they are specified.
- Actions are equivalent to the individual API requests of the same name.

	Request can be constructed by NewApiMultipleBatchRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param batchParams BatchParams
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) MultipleBatchWithHTTPInfo(ctx context.Context, r ApiMultipleBatchRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/*/batch"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.batchParams == nil {
		return nil, nil, reportError("Parameter `batchParams` is required when calling `MultipleBatch`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.batchParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
MultipleBatch wraps MultipleBatchWithContext using context.Background.

Adds, updates, or deletes records in multiple indices with a single API request.

- Actions are applied in the order they are specified.
- Actions are equivalent to the individual API requests of the same name.

Request can be constructed by NewApiMultipleBatchRequest with parameters below.

	@param batchParams BatchParams
	@return MultipleBatchResponse
*/
func (c *APIClient) MultipleBatch(r ApiMultipleBatchRequest, opts ...Option) (*MultipleBatchResponse, error) {
	return c.MultipleBatchWithContext(context.Background(), r, opts...)
}

/*
MultipleBatch casts the HTTP response body to a defined struct.

Adds, updates, or deletes records in multiple indices with a single API request.

- Actions are applied in the order they are specified.
- Actions are equivalent to the individual API requests of the same name.

Request can be constructed by NewApiMultipleBatchRequest with parameters below.

	@param batchParams BatchParams
	@return MultipleBatchResponse
*/
func (c *APIClient) MultipleBatchWithContext(ctx context.Context, r ApiMultipleBatchRequest, opts ...Option) (*MultipleBatchResponse, error) {
	var returnValue *MultipleBatchResponse

	res, resBody, err := c.MultipleBatchWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiOperationIndexRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["operationIndexParams"]; ok {
		err = json.Unmarshal(v, &r.operationIndexParams)
		if err != nil {
			err = json.Unmarshal(b, &r.operationIndexParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal operationIndexParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.operationIndexParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter operationIndexParams: %w", err)
		}
	}

	return nil
}

// ApiOperationIndexRequest represents the request with all the parameters for the API call.
type ApiOperationIndexRequest struct {
	indexName            string
	operationIndexParams *OperationIndexParams
}

// NewApiOperationIndexRequest creates an instance of the ApiOperationIndexRequest to be used for the API call.
func (c *APIClient) NewApiOperationIndexRequest(indexName string, operationIndexParams *OperationIndexParams) ApiOperationIndexRequest {
	return ApiOperationIndexRequest{
		indexName:            indexName,
		operationIndexParams: operationIndexParams,
	}
}

/*
OperationIndex calls the API and returns the raw response from it.

	Copies or moves (renames) an index within the same Algolia application.

- Existing destination indices are overwritten, except for their analytics data.
- If the destination index doesn't exist yet, it'll be created.

**Copy**

- Copying a source index that doesn't exist creates a new index with 0 records and default settings.
- The API keys of the source index are merged with the existing keys in the destination index.
- You can't copy the `enableReRanking`, `mode`, and `replicas` settings.
- You can't copy to a destination index that already has replicas.
- Be aware of the [size limits](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits).
- Related guide: [Copy indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/copy-indices/)

**Move**

  - Moving a source index that doesn't exist is ignored without returning an error.

  - When moving an index, the analytics data keep their original name and a new set of analytics data is started for the new name.
    To access the original analytics in the dashboard, create an index with the original name.

  - If the destination index has replicas, moving will overwrite the existing index and copy the data to the replica indices.

  - Related guide: [Move indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/move-indices/).

    Required API Key ACLs:

  - addObject

    Request can be constructed by NewApiOperationIndexRequest with parameters below.
    @param ctx context.Context - Context of the request
    @param indexName string - Name of the index on which to perform the operation.
    @param operationIndexParams OperationIndexParams
    @param opts ...Option - Optional parameters for the API call
    @return *http.Response - The raw response from the API
    @return []byte - The raw response body from the API
    @return error - An error if the API call fails
*/
func (c *APIClient) OperationIndexWithHTTPInfo(ctx context.Context, r ApiOperationIndexRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/operation"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `OperationIndex`.")
	}

	if r.operationIndexParams == nil {
		return nil, nil, reportError("Parameter `operationIndexParams` is required when calling `OperationIndex`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.operationIndexParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
OperationIndex wraps OperationIndexWithContext using context.Background.

Copies or moves (renames) an index within the same Algolia application.

- Existing destination indices are overwritten, except for their analytics data.
- If the destination index doesn't exist yet, it'll be created.

**Copy**

- Copying a source index that doesn't exist creates a new index with 0 records and default settings.
- The API keys of the source index are merged with the existing keys in the destination index.
- You can't copy the `enableReRanking`, `mode`, and `replicas` settings.
- You can't copy to a destination index that already has replicas.
- Be aware of the [size limits](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits).
- Related guide: [Copy indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/copy-indices/)

**Move**

  - Moving a source index that doesn't exist is ignored without returning an error.
  - When moving an index, the analytics data keep their original name and a new set of analytics data is started for the new name.
    To access the original analytics in the dashboard, create an index with the original name.
  - If the destination index has replicas, moving will overwrite the existing index and copy the data to the replica indices.
  - Related guide: [Move indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/move-indices/).

Required API Key ACLs:
  - addObject

Request can be constructed by NewApiOperationIndexRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param operationIndexParams OperationIndexParams
	@return UpdatedAtResponse
*/
func (c *APIClient) OperationIndex(r ApiOperationIndexRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.OperationIndexWithContext(context.Background(), r, opts...)
}

/*
OperationIndex casts the HTTP response body to a defined struct.

Copies or moves (renames) an index within the same Algolia application.

- Existing destination indices are overwritten, except for their analytics data.
- If the destination index doesn't exist yet, it'll be created.

**Copy**

- Copying a source index that doesn't exist creates a new index with 0 records and default settings.
- The API keys of the source index are merged with the existing keys in the destination index.
- You can't copy the `enableReRanking`, `mode`, and `replicas` settings.
- You can't copy to a destination index that already has replicas.
- Be aware of the [size limits](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits).
- Related guide: [Copy indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/copy-indices/)

**Move**

  - Moving a source index that doesn't exist is ignored without returning an error.
  - When moving an index, the analytics data keep their original name and a new set of analytics data is started for the new name.
    To access the original analytics in the dashboard, create an index with the original name.
  - If the destination index has replicas, moving will overwrite the existing index and copy the data to the replica indices.
  - Related guide: [Move indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/move-indices/).

Required API Key ACLs:
  - addObject

Request can be constructed by NewApiOperationIndexRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param operationIndexParams OperationIndexParams
	@return UpdatedAtResponse
*/
func (c *APIClient) OperationIndexWithContext(ctx context.Context, r ApiOperationIndexRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.OperationIndexWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPartialUpdateObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal objectID: %w", err)
			}
		}
	}
	if v, ok := req["attributesToUpdate"]; ok {
		err = json.Unmarshal(v, &r.attributesToUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.attributesToUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal attributesToUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.attributesToUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter attributesToUpdate: %w", err)
		}
	}
	if v, ok := req["createIfNotExists"]; ok {
		err = json.Unmarshal(v, &r.createIfNotExists)
		if err != nil {
			err = json.Unmarshal(b, &r.createIfNotExists)
			if err != nil {
				return fmt.Errorf("cannot unmarshal createIfNotExists: %w", err)
			}
		}
	}

	return nil
}

// ApiPartialUpdateObjectRequest represents the request with all the parameters for the API call.
type ApiPartialUpdateObjectRequest struct {
	indexName          string
	objectID           string
	attributesToUpdate map[string]AttributeToUpdate
	createIfNotExists  *bool
}

// NewApiPartialUpdateObjectRequest creates an instance of the ApiPartialUpdateObjectRequest to be used for the API call.
func (c *APIClient) NewApiPartialUpdateObjectRequest(indexName string, objectID string, attributesToUpdate map[string]AttributeToUpdate) ApiPartialUpdateObjectRequest {
	return ApiPartialUpdateObjectRequest{
		indexName:          indexName,
		objectID:           objectID,
		attributesToUpdate: attributesToUpdate,
	}
}

// WithCreateIfNotExists adds the createIfNotExists to the ApiPartialUpdateObjectRequest and returns the request for chaining.
func (r ApiPartialUpdateObjectRequest) WithCreateIfNotExists(createIfNotExists bool) ApiPartialUpdateObjectRequest {
	r.createIfNotExists = &createIfNotExists
	return r
}

/*
PartialUpdateObject calls the API and returns the raw response from it.

		Adds new attributes to a record, or update existing ones.

	  - If a record with the specified object ID doesn't exist,
	    a new record is added to the index **if** `createIfNotExists` is true.

	  - If the index doesn't exist yet, this method creates a new index.

	  - You can use any first-level attribute but not nested attributes.
	    If you specify a nested attribute, the engine treats it as a replacement for its first-level ancestor.

	    Required API Key ACLs:

	  - addObject

	    Request can be constructed by NewApiPartialUpdateObjectRequest with parameters below.
	    @param ctx context.Context - Context of the request
	    @param indexName string - Name of the index on which to perform the operation.
	    @param objectID string - Unique record identifier.
	    @param attributesToUpdate map[string]AttributeToUpdate - Attributes with their values.
	    @param createIfNotExists bool - Whether to create a new record if it doesn't exist.
	    @param opts ...Option - Optional parameters for the API call
	    @return *http.Response - The raw response from the API
	    @return []byte - The raw response body from the API
	    @return error - An error if the API call fails
*/
func (c *APIClient) PartialUpdateObjectWithHTTPInfo(ctx context.Context, r ApiPartialUpdateObjectRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/{objectID}/partial"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(parameterToString(r.objectID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `PartialUpdateObject`.")
	}
	if r.objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `PartialUpdateObject`.")
	}

	if len(r.attributesToUpdate) == 0 {
		return nil, nil, reportError("Parameter `attributesToUpdate` is required when calling `PartialUpdateObject`.")
	}
	if len(r.attributesToUpdate) == 0 {
		return nil, nil, reportError("Parameter `attributesToUpdate` is required when calling `PartialUpdateObject`.")
	}

	if !utils.IsNilOrEmpty(r.createIfNotExists) {
		queryParams.Set("createIfNotExists", queryParameterToString(*r.createIfNotExists))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.attributesToUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
PartialUpdateObject wraps PartialUpdateObjectWithContext using context.Background.

Adds new attributes to a record, or update existing ones.

  - If a record with the specified object ID doesn't exist,
    a new record is added to the index **if** `createIfNotExists` is true.
  - If the index doesn't exist yet, this method creates a new index.
  - You can use any first-level attribute but not nested attributes.
    If you specify a nested attribute, the engine treats it as a replacement for its first-level ancestor.

Required API Key ACLs:
  - addObject

Request can be constructed by NewApiPartialUpdateObjectRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique record identifier.
	@param attributesToUpdate map[string]AttributeToUpdate - Attributes with their values.
	@param createIfNotExists bool - Whether to create a new record if it doesn't exist.
	@return UpdatedAtWithObjectIdResponse
*/
func (c *APIClient) PartialUpdateObject(r ApiPartialUpdateObjectRequest, opts ...Option) (*UpdatedAtWithObjectIdResponse, error) {
	return c.PartialUpdateObjectWithContext(context.Background(), r, opts...)
}

/*
PartialUpdateObject casts the HTTP response body to a defined struct.

Adds new attributes to a record, or update existing ones.

  - If a record with the specified object ID doesn't exist,
    a new record is added to the index **if** `createIfNotExists` is true.
  - If the index doesn't exist yet, this method creates a new index.
  - You can use any first-level attribute but not nested attributes.
    If you specify a nested attribute, the engine treats it as a replacement for its first-level ancestor.

Required API Key ACLs:
  - addObject

Request can be constructed by NewApiPartialUpdateObjectRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique record identifier.
	@param attributesToUpdate map[string]AttributeToUpdate - Attributes with their values.
	@param createIfNotExists bool - Whether to create a new record if it doesn't exist.
	@return UpdatedAtWithObjectIdResponse
*/
func (c *APIClient) PartialUpdateObjectWithContext(ctx context.Context, r ApiPartialUpdateObjectRequest, opts ...Option) (*UpdatedAtWithObjectIdResponse, error) {
	var returnValue *UpdatedAtWithObjectIdResponse

	res, resBody, err := c.PartialUpdateObjectWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRemoveUserIdRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["userID"]; ok {
		err = json.Unmarshal(v, &r.userID)
		if err != nil {
			err = json.Unmarshal(b, &r.userID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal userID: %w", err)
			}
		}
	}

	return nil
}

// ApiRemoveUserIdRequest represents the request with all the parameters for the API call.
type ApiRemoveUserIdRequest struct {
	userID string
}

// NewApiRemoveUserIdRequest creates an instance of the ApiRemoveUserIdRequest to be used for the API call.
func (c *APIClient) NewApiRemoveUserIdRequest(userID string) ApiRemoveUserIdRequest {
	return ApiRemoveUserIdRequest{
		userID: userID,
	}
}

/*
RemoveUserId calls the API and returns the raw response from it.

	  Deletes a user ID and its associated data from the clusters.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiRemoveUserIdRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param userID string - Unique identifier of the user who makes the search request.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) RemoveUserIdWithHTTPInfo(ctx context.Context, r ApiRemoveUserIdRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/clusters/mapping/{userID}"
	requestPath = strings.ReplaceAll(requestPath, "{userID}", url.PathEscape(parameterToString(r.userID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.userID == "" {
		return nil, nil, reportError("Parameter `userID` is required when calling `RemoveUserId`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
RemoveUserId wraps RemoveUserIdWithContext using context.Background.

Deletes a user ID and its associated data from the clusters.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiRemoveUserIdRequest with parameters below.

	@param userID string - Unique identifier of the user who makes the search request.
	@return RemoveUserIdResponse
*/
func (c *APIClient) RemoveUserId(r ApiRemoveUserIdRequest, opts ...Option) (*RemoveUserIdResponse, error) {
	return c.RemoveUserIdWithContext(context.Background(), r, opts...)
}

/*
RemoveUserId casts the HTTP response body to a defined struct.

Deletes a user ID and its associated data from the clusters.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiRemoveUserIdRequest with parameters below.

	@param userID string - Unique identifier of the user who makes the search request.
	@return RemoveUserIdResponse
*/
func (c *APIClient) RemoveUserIdWithContext(ctx context.Context, r ApiRemoveUserIdRequest, opts ...Option) (*RemoveUserIdResponse, error) {
	var returnValue *RemoveUserIdResponse

	res, resBody, err := c.RemoveUserIdWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiReplaceSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["source"]; ok {
		err = json.Unmarshal(v, &r.source)
		if err != nil {
			err = json.Unmarshal(b, &r.source)
			if err != nil {
				return fmt.Errorf("cannot unmarshal source: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.source)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter source: %w", err)
		}
	}

	return nil
}

// ApiReplaceSourcesRequest represents the request with all the parameters for the API call.
type ApiReplaceSourcesRequest struct {
	source []Source
}

// NewApiReplaceSourcesRequest creates an instance of the ApiReplaceSourcesRequest to be used for the API call.
func (c *APIClient) NewApiReplaceSourcesRequest(source []Source) ApiReplaceSourcesRequest {
	return ApiReplaceSourcesRequest{
		source: source,
	}
}

/*
ReplaceSources calls the API and returns the raw response from it.

	  Replaces the list of allowed sources.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiReplaceSourcesRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param source []Source - Allowed sources.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ReplaceSourcesWithHTTPInfo(ctx context.Context, r ApiReplaceSourcesRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/security/sources"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if len(r.source) == 0 {
		return nil, nil, reportError("Parameter `source` is required when calling `ReplaceSources`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.source
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ReplaceSources wraps ReplaceSourcesWithContext using context.Background.

Replaces the list of allowed sources.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiReplaceSourcesRequest with parameters below.

	@param source []Source - Allowed sources.
	@return ReplaceSourceResponse
*/
func (c *APIClient) ReplaceSources(r ApiReplaceSourcesRequest, opts ...Option) (*ReplaceSourceResponse, error) {
	return c.ReplaceSourcesWithContext(context.Background(), r, opts...)
}

/*
ReplaceSources casts the HTTP response body to a defined struct.

Replaces the list of allowed sources.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiReplaceSourcesRequest with parameters below.

	@param source []Source - Allowed sources.
	@return ReplaceSourceResponse
*/
func (c *APIClient) ReplaceSourcesWithContext(ctx context.Context, r ApiReplaceSourcesRequest, opts ...Option) (*ReplaceSourceResponse, error) {
	var returnValue *ReplaceSourceResponse

	res, resBody, err := c.ReplaceSourcesWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRestoreApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["key"]; ok {
		err = json.Unmarshal(v, &r.key)
		if err != nil {
			err = json.Unmarshal(b, &r.key)
			if err != nil {
				return fmt.Errorf("cannot unmarshal key: %w", err)
			}
		}
	}

	return nil
}

// ApiRestoreApiKeyRequest represents the request with all the parameters for the API call.
type ApiRestoreApiKeyRequest struct {
	key string
}

// NewApiRestoreApiKeyRequest creates an instance of the ApiRestoreApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiRestoreApiKeyRequest(key string) ApiRestoreApiKeyRequest {
	return ApiRestoreApiKeyRequest{
		key: key,
	}
}

/*
RestoreApiKey calls the API and returns the raw response from it.

	Restores a deleted API key.

Restoring resets the `validity` attribute to `0`.

Algolia stores up to 1,000 API keys per application.
If you create more, the oldest API keys are deleted and can't be restored.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiRestoreApiKeyRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param key string - API key.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) RestoreApiKeyWithHTTPInfo(ctx context.Context, r ApiRestoreApiKeyRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/keys/{key}/restore"
	requestPath = strings.ReplaceAll(requestPath, "{key}", url.PathEscape(parameterToString(r.key)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.key == "" {
		return nil, nil, reportError("Parameter `key` is required when calling `RestoreApiKey`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
RestoreApiKey wraps RestoreApiKeyWithContext using context.Background.

Restores a deleted API key.

Restoring resets the `validity` attribute to `0`.

Algolia stores up to 1,000 API keys per application.
If you create more, the oldest API keys are deleted and can't be restored.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiRestoreApiKeyRequest with parameters below.

	@param key string - API key.
	@return AddApiKeyResponse
*/
func (c *APIClient) RestoreApiKey(r ApiRestoreApiKeyRequest, opts ...Option) (*AddApiKeyResponse, error) {
	return c.RestoreApiKeyWithContext(context.Background(), r, opts...)
}

/*
RestoreApiKey casts the HTTP response body to a defined struct.

Restores a deleted API key.

Restoring resets the `validity` attribute to `0`.

Algolia stores up to 1,000 API keys per application.
If you create more, the oldest API keys are deleted and can't be restored.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiRestoreApiKeyRequest with parameters below.

	@param key string - API key.
	@return AddApiKeyResponse
*/
func (c *APIClient) RestoreApiKeyWithContext(ctx context.Context, r ApiRestoreApiKeyRequest, opts ...Option) (*AddApiKeyResponse, error) {
	var returnValue *AddApiKeyResponse

	res, resBody, err := c.RestoreApiKeyWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveObjectRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.body)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter body: %w", err)
		}
	}

	return nil
}

// ApiSaveObjectRequest represents the request with all the parameters for the API call.
type ApiSaveObjectRequest struct {
	indexName string
	body      map[string]any
}

// NewApiSaveObjectRequest creates an instance of the ApiSaveObjectRequest to be used for the API call.
func (c *APIClient) NewApiSaveObjectRequest(indexName string, body map[string]any) ApiSaveObjectRequest {
	return ApiSaveObjectRequest{
		indexName: indexName,
		body:      body,
	}
}

/*
SaveObject calls the API and returns the raw response from it.

	Adds a record to an index or replace it.

- If the record doesn't have an object ID, a new record with an auto-generated object ID is added to your index.
- If a record with the specified object ID exists, the existing record is replaced.
- If a record with the specified object ID doesn't exist, a new record is added to your index.
- If you add a record to an index that doesn't exist yet, a new index is created.

To update _some_ attributes of a record, use the [`partial` operation](#tag/Records/operation/partial).
To add, update, or replace multiple records, use the [`batch` operation](#tag/Records/operation/batch).

	    Required API Key ACLs:
	    - addObject

	Request can be constructed by NewApiSaveObjectRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param body map[string]any - The record, a schemaless object with attributes that are useful in the context of search and discovery.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SaveObjectWithHTTPInfo(ctx context.Context, r ApiSaveObjectRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SaveObject`.")
	}

	if len(r.body) == 0 {
		return nil, nil, reportError("Parameter `body` is required when calling `SaveObject`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.body
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SaveObject wraps SaveObjectWithContext using context.Background.

Adds a record to an index or replace it.

- If the record doesn't have an object ID, a new record with an auto-generated object ID is added to your index.
- If a record with the specified object ID exists, the existing record is replaced.
- If a record with the specified object ID doesn't exist, a new record is added to your index.
- If you add a record to an index that doesn't exist yet, a new index is created.

To update _some_ attributes of a record, use the [`partial` operation](#tag/Records/operation/partial).
To add, update, or replace multiple records, use the [`batch` operation](#tag/Records/operation/batch).

Required API Key ACLs:
  - addObject

Request can be constructed by NewApiSaveObjectRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param body map[string]any - The record, a schemaless object with attributes that are useful in the context of search and discovery.
	@return SaveObjectResponse
*/
func (c *APIClient) SaveObject(r ApiSaveObjectRequest, opts ...Option) (*SaveObjectResponse, error) {
	return c.SaveObjectWithContext(context.Background(), r, opts...)
}

/*
SaveObject casts the HTTP response body to a defined struct.

Adds a record to an index or replace it.

- If the record doesn't have an object ID, a new record with an auto-generated object ID is added to your index.
- If a record with the specified object ID exists, the existing record is replaced.
- If a record with the specified object ID doesn't exist, a new record is added to your index.
- If you add a record to an index that doesn't exist yet, a new index is created.

To update _some_ attributes of a record, use the [`partial` operation](#tag/Records/operation/partial).
To add, update, or replace multiple records, use the [`batch` operation](#tag/Records/operation/batch).

Required API Key ACLs:
  - addObject

Request can be constructed by NewApiSaveObjectRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param body map[string]any - The record, a schemaless object with attributes that are useful in the context of search and discovery.
	@return SaveObjectResponse
*/
func (c *APIClient) SaveObjectWithContext(ctx context.Context, r ApiSaveObjectRequest, opts ...Option) (*SaveObjectResponse, error) {
	var returnValue *SaveObjectResponse

	res, resBody, err := c.SaveObjectWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal objectID: %w", err)
			}
		}
	}
	if v, ok := req["rule"]; ok {
		err = json.Unmarshal(v, &r.rule)
		if err != nil {
			err = json.Unmarshal(b, &r.rule)
			if err != nil {
				return fmt.Errorf("cannot unmarshal rule: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.rule)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter rule: %w", err)
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return fmt.Errorf("cannot unmarshal forwardToReplicas: %w", err)
			}
		}
	}

	return nil
}

// ApiSaveRuleRequest represents the request with all the parameters for the API call.
type ApiSaveRuleRequest struct {
	indexName         string
	objectID          string
	rule              *Rule
	forwardToReplicas *bool
}

// NewApiSaveRuleRequest creates an instance of the ApiSaveRuleRequest to be used for the API call.
func (c *APIClient) NewApiSaveRuleRequest(indexName string, objectID string, rule *Rule) ApiSaveRuleRequest {
	return ApiSaveRuleRequest{
		indexName: indexName,
		objectID:  objectID,
		rule:      rule,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSaveRuleRequest and returns the request for chaining.
func (r ApiSaveRuleRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSaveRuleRequest {
	r.forwardToReplicas = &forwardToReplicas
	return r
}

/*
SaveRule calls the API and returns the raw response from it.

	If a rule with the specified object ID doesn't exist, it's created.

Otherwise, the existing rule is replaced.

To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiSaveRuleRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param objectID string - Unique identifier of a rule object.
	  @param rule Rule
	  @param forwardToReplicas bool - Whether changes are applied to replica indices.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SaveRuleWithHTTPInfo(ctx context.Context, r ApiSaveRuleRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(parameterToString(r.objectID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SaveRule`.")
	}
	if r.objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `SaveRule`.")
	}

	if r.rule == nil {
		return nil, nil, reportError("Parameter `rule` is required when calling `SaveRule`.")
	}

	if !utils.IsNilOrEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", queryParameterToString(*r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.rule
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SaveRule wraps SaveRuleWithContext using context.Background.

If a rule with the specified object ID doesn't exist, it's created.
Otherwise, the existing rule is replaced.

To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiSaveRuleRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique identifier of a rule object.
	@param rule Rule
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return UpdatedRuleResponse
*/
func (c *APIClient) SaveRule(r ApiSaveRuleRequest, opts ...Option) (*UpdatedRuleResponse, error) {
	return c.SaveRuleWithContext(context.Background(), r, opts...)
}

/*
SaveRule casts the HTTP response body to a defined struct.

If a rule with the specified object ID doesn't exist, it's created.
Otherwise, the existing rule is replaced.

To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiSaveRuleRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique identifier of a rule object.
	@param rule Rule
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return UpdatedRuleResponse
*/
func (c *APIClient) SaveRuleWithContext(ctx context.Context, r ApiSaveRuleRequest, opts ...Option) (*UpdatedRuleResponse, error) {
	var returnValue *UpdatedRuleResponse

	res, resBody, err := c.SaveRuleWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveRulesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["rules"]; ok {
		err = json.Unmarshal(v, &r.rules)
		if err != nil {
			err = json.Unmarshal(b, &r.rules)
			if err != nil {
				return fmt.Errorf("cannot unmarshal rules: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.rules)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter rules: %w", err)
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return fmt.Errorf("cannot unmarshal forwardToReplicas: %w", err)
			}
		}
	}
	if v, ok := req["clearExistingRules"]; ok {
		err = json.Unmarshal(v, &r.clearExistingRules)
		if err != nil {
			err = json.Unmarshal(b, &r.clearExistingRules)
			if err != nil {
				return fmt.Errorf("cannot unmarshal clearExistingRules: %w", err)
			}
		}
	}

	return nil
}

// ApiSaveRulesRequest represents the request with all the parameters for the API call.
type ApiSaveRulesRequest struct {
	indexName          string
	rules              []Rule
	forwardToReplicas  *bool
	clearExistingRules *bool
}

// NewApiSaveRulesRequest creates an instance of the ApiSaveRulesRequest to be used for the API call.
func (c *APIClient) NewApiSaveRulesRequest(indexName string, rules []Rule) ApiSaveRulesRequest {
	return ApiSaveRulesRequest{
		indexName: indexName,
		rules:     rules,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSaveRulesRequest and returns the request for chaining.
func (r ApiSaveRulesRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSaveRulesRequest {
	r.forwardToReplicas = &forwardToReplicas
	return r
}

// WithClearExistingRules adds the clearExistingRules to the ApiSaveRulesRequest and returns the request for chaining.
func (r ApiSaveRulesRequest) WithClearExistingRules(clearExistingRules bool) ApiSaveRulesRequest {
	r.clearExistingRules = &clearExistingRules
	return r
}

/*
SaveRules calls the API and returns the raw response from it.

	Create or update multiple rules.

If a rule with the specified object ID doesn't exist, Algolia creates a new one.
Otherwise, existing rules are replaced.

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiSaveRulesRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param rules []Rule
	  @param forwardToReplicas bool - Whether changes are applied to replica indices.
	  @param clearExistingRules bool - Whether existing rules should be deleted before adding this batch.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SaveRulesWithHTTPInfo(ctx context.Context, r ApiSaveRulesRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/rules/batch"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SaveRules`.")
	}

	if len(r.rules) == 0 {
		return nil, nil, reportError("Parameter `rules` is required when calling `SaveRules`.")
	}

	if !utils.IsNilOrEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", queryParameterToString(*r.forwardToReplicas))
	}
	if !utils.IsNilOrEmpty(r.clearExistingRules) {
		queryParams.Set("clearExistingRules", queryParameterToString(*r.clearExistingRules))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.rules
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SaveRules wraps SaveRulesWithContext using context.Background.

Create or update multiple rules.

If a rule with the specified object ID doesn't exist, Algolia creates a new one.
Otherwise, existing rules are replaced.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiSaveRulesRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param rules []Rule
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@param clearExistingRules bool - Whether existing rules should be deleted before adding this batch.
	@return UpdatedAtResponse
*/
func (c *APIClient) SaveRules(r ApiSaveRulesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SaveRulesWithContext(context.Background(), r, opts...)
}

/*
SaveRules casts the HTTP response body to a defined struct.

Create or update multiple rules.

If a rule with the specified object ID doesn't exist, Algolia creates a new one.
Otherwise, existing rules are replaced.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiSaveRulesRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param rules []Rule
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@param clearExistingRules bool - Whether existing rules should be deleted before adding this batch.
	@return UpdatedAtResponse
*/
func (c *APIClient) SaveRulesWithContext(ctx context.Context, r ApiSaveRulesRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.SaveRulesWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveSynonymRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal objectID: %w", err)
			}
		}
	}
	if v, ok := req["synonymHit"]; ok {
		err = json.Unmarshal(v, &r.synonymHit)
		if err != nil {
			err = json.Unmarshal(b, &r.synonymHit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal synonymHit: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.synonymHit)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter synonymHit: %w", err)
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return fmt.Errorf("cannot unmarshal forwardToReplicas: %w", err)
			}
		}
	}

	return nil
}

// ApiSaveSynonymRequest represents the request with all the parameters for the API call.
type ApiSaveSynonymRequest struct {
	indexName         string
	objectID          string
	synonymHit        *SynonymHit
	forwardToReplicas *bool
}

// NewApiSaveSynonymRequest creates an instance of the ApiSaveSynonymRequest to be used for the API call.
func (c *APIClient) NewApiSaveSynonymRequest(indexName string, objectID string, synonymHit *SynonymHit) ApiSaveSynonymRequest {
	return ApiSaveSynonymRequest{
		indexName:  indexName,
		objectID:   objectID,
		synonymHit: synonymHit,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSaveSynonymRequest and returns the request for chaining.
func (r ApiSaveSynonymRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSaveSynonymRequest {
	r.forwardToReplicas = &forwardToReplicas
	return r
}

/*
SaveSynonym calls the API and returns the raw response from it.

	If a synonym with the specified object ID doesn't exist, Algolia adds a new one.

Otherwise, the existing synonym is replaced.
To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiSaveSynonymRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param objectID string - Unique identifier of a synonym object.
	  @param synonymHit SynonymHit
	  @param forwardToReplicas bool - Whether changes are applied to replica indices.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SaveSynonymWithHTTPInfo(ctx context.Context, r ApiSaveSynonymRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/synonyms/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(parameterToString(r.objectID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SaveSynonym`.")
	}
	if r.objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `SaveSynonym`.")
	}

	if r.synonymHit == nil {
		return nil, nil, reportError("Parameter `synonymHit` is required when calling `SaveSynonym`.")
	}

	if !utils.IsNilOrEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", queryParameterToString(*r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.synonymHit
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SaveSynonym wraps SaveSynonymWithContext using context.Background.

If a synonym with the specified object ID doesn't exist, Algolia adds a new one.
Otherwise, the existing synonym is replaced.
To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiSaveSynonymRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique identifier of a synonym object.
	@param synonymHit SynonymHit
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return SaveSynonymResponse
*/
func (c *APIClient) SaveSynonym(r ApiSaveSynonymRequest, opts ...Option) (*SaveSynonymResponse, error) {
	return c.SaveSynonymWithContext(context.Background(), r, opts...)
}

/*
SaveSynonym casts the HTTP response body to a defined struct.

If a synonym with the specified object ID doesn't exist, Algolia adds a new one.
Otherwise, the existing synonym is replaced.
To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiSaveSynonymRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param objectID string - Unique identifier of a synonym object.
	@param synonymHit SynonymHit
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return SaveSynonymResponse
*/
func (c *APIClient) SaveSynonymWithContext(ctx context.Context, r ApiSaveSynonymRequest, opts ...Option) (*SaveSynonymResponse, error) {
	var returnValue *SaveSynonymResponse

	res, resBody, err := c.SaveSynonymWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSaveSynonymsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["synonymHit"]; ok {
		err = json.Unmarshal(v, &r.synonymHit)
		if err != nil {
			err = json.Unmarshal(b, &r.synonymHit)
			if err != nil {
				return fmt.Errorf("cannot unmarshal synonymHit: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.synonymHit)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter synonymHit: %w", err)
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return fmt.Errorf("cannot unmarshal forwardToReplicas: %w", err)
			}
		}
	}
	if v, ok := req["replaceExistingSynonyms"]; ok {
		err = json.Unmarshal(v, &r.replaceExistingSynonyms)
		if err != nil {
			err = json.Unmarshal(b, &r.replaceExistingSynonyms)
			if err != nil {
				return fmt.Errorf("cannot unmarshal replaceExistingSynonyms: %w", err)
			}
		}
	}

	return nil
}

// ApiSaveSynonymsRequest represents the request with all the parameters for the API call.
type ApiSaveSynonymsRequest struct {
	indexName               string
	synonymHit              []SynonymHit
	forwardToReplicas       *bool
	replaceExistingSynonyms *bool
}

// NewApiSaveSynonymsRequest creates an instance of the ApiSaveSynonymsRequest to be used for the API call.
func (c *APIClient) NewApiSaveSynonymsRequest(indexName string, synonymHit []SynonymHit) ApiSaveSynonymsRequest {
	return ApiSaveSynonymsRequest{
		indexName:  indexName,
		synonymHit: synonymHit,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSaveSynonymsRequest and returns the request for chaining.
func (r ApiSaveSynonymsRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSaveSynonymsRequest {
	r.forwardToReplicas = &forwardToReplicas
	return r
}

// WithReplaceExistingSynonyms adds the replaceExistingSynonyms to the ApiSaveSynonymsRequest and returns the request for chaining.
func (r ApiSaveSynonymsRequest) WithReplaceExistingSynonyms(replaceExistingSynonyms bool) ApiSaveSynonymsRequest {
	r.replaceExistingSynonyms = &replaceExistingSynonyms
	return r
}

/*
SaveSynonyms calls the API and returns the raw response from it.

	If a synonym with the `objectID` doesn't exist, Algolia adds a new one.

Otherwise, existing synonyms are replaced.

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiSaveSynonymsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param synonymHit []SynonymHit
	  @param forwardToReplicas bool - Whether changes are applied to replica indices.
	  @param replaceExistingSynonyms bool - Whether to replace all synonyms in the index with the ones sent with this request.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SaveSynonymsWithHTTPInfo(ctx context.Context, r ApiSaveSynonymsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/synonyms/batch"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SaveSynonyms`.")
	}

	if len(r.synonymHit) == 0 {
		return nil, nil, reportError("Parameter `synonymHit` is required when calling `SaveSynonyms`.")
	}

	if !utils.IsNilOrEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", queryParameterToString(*r.forwardToReplicas))
	}
	if !utils.IsNilOrEmpty(r.replaceExistingSynonyms) {
		queryParams.Set("replaceExistingSynonyms", queryParameterToString(*r.replaceExistingSynonyms))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.synonymHit
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SaveSynonyms wraps SaveSynonymsWithContext using context.Background.

If a synonym with the `objectID` doesn't exist, Algolia adds a new one.
Otherwise, existing synonyms are replaced.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiSaveSynonymsRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param synonymHit []SynonymHit
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@param replaceExistingSynonyms bool - Whether to replace all synonyms in the index with the ones sent with this request.
	@return UpdatedAtResponse
*/
func (c *APIClient) SaveSynonyms(r ApiSaveSynonymsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SaveSynonymsWithContext(context.Background(), r, opts...)
}

/*
SaveSynonyms casts the HTTP response body to a defined struct.

If a synonym with the `objectID` doesn't exist, Algolia adds a new one.
Otherwise, existing synonyms are replaced.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiSaveSynonymsRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param synonymHit []SynonymHit
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@param replaceExistingSynonyms bool - Whether to replace all synonyms in the index with the ones sent with this request.
	@return UpdatedAtResponse
*/
func (c *APIClient) SaveSynonymsWithContext(ctx context.Context, r ApiSaveSynonymsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.SaveSynonymsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["searchMethodParams"]; ok {
		err = json.Unmarshal(v, &r.searchMethodParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchMethodParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal searchMethodParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.searchMethodParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter searchMethodParams: %w", err)
		}
	}

	return nil
}

// ApiSearchRequest represents the request with all the parameters for the API call.
type ApiSearchRequest struct {
	searchMethodParams *SearchMethodParams
}

// NewApiSearchRequest creates an instance of the ApiSearchRequest to be used for the API call.
func (c *APIClient) NewApiSearchRequest(searchMethodParams *SearchMethodParams) ApiSearchRequest {
	return ApiSearchRequest{
		searchMethodParams: searchMethodParams,
	}
}

/*
Search calls the API and returns the raw response from it.

	Sends multiple search request to one or more indices.

This can be useful in these cases:

- Different indices for different purposes, such as, one index for products, another one for marketing content.
- Multiple searches to the same indexfor example, with different filters.

	    Required API Key ACLs:
	    - search

	Request can be constructed by NewApiSearchRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param searchMethodParams SearchMethodParams - Muli-search request body. Results are returned in the same order as the requests.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchWithHTTPInfo(ctx context.Context, r ApiSearchRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/*/queries"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.searchMethodParams == nil {
		return nil, nil, reportError("Parameter `searchMethodParams` is required when calling `Search`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.searchMethodParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true)
}

/*
Search wraps SearchWithContext using context.Background.

Sends multiple search request to one or more indices.

This can be useful in these cases:

- Different indices for different purposes, such as, one index for products, another one for marketing content.
- Multiple searches to the same indexfor example, with different filters.

Required API Key ACLs:
  - search

Request can be constructed by NewApiSearchRequest with parameters below.

	@param searchMethodParams SearchMethodParams - Muli-search request body. Results are returned in the same order as the requests.
	@return SearchResponses
*/
func (c *APIClient) Search(r ApiSearchRequest, opts ...Option) (*SearchResponses, error) {
	return c.SearchWithContext(context.Background(), r, opts...)
}

/*
Search casts the HTTP response body to a defined struct.

Sends multiple search request to one or more indices.

This can be useful in these cases:

- Different indices for different purposes, such as, one index for products, another one for marketing content.
- Multiple searches to the same indexfor example, with different filters.

Required API Key ACLs:
  - search

Request can be constructed by NewApiSearchRequest with parameters below.

	@param searchMethodParams SearchMethodParams - Muli-search request body. Results are returned in the same order as the requests.
	@return SearchResponses
*/
func (c *APIClient) SearchWithContext(ctx context.Context, r ApiSearchRequest, opts ...Option) (*SearchResponses, error) {
	var returnValue *SearchResponses

	res, resBody, err := c.SearchWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchDictionaryEntriesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["dictionaryName"]; ok {
		err = json.Unmarshal(v, &r.dictionaryName)
		if err != nil {
			err = json.Unmarshal(b, &r.dictionaryName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal dictionaryName: %w", err)
			}
		}
	}
	if v, ok := req["searchDictionaryEntriesParams"]; ok {
		err = json.Unmarshal(v, &r.searchDictionaryEntriesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchDictionaryEntriesParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal searchDictionaryEntriesParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.searchDictionaryEntriesParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter searchDictionaryEntriesParams: %w", err)
		}
	}

	return nil
}

// ApiSearchDictionaryEntriesRequest represents the request with all the parameters for the API call.
type ApiSearchDictionaryEntriesRequest struct {
	dictionaryName                DictionaryType
	searchDictionaryEntriesParams *SearchDictionaryEntriesParams
}

// NewApiSearchDictionaryEntriesRequest creates an instance of the ApiSearchDictionaryEntriesRequest to be used for the API call.
func (c *APIClient) NewApiSearchDictionaryEntriesRequest(dictionaryName DictionaryType, searchDictionaryEntriesParams *SearchDictionaryEntriesParams) ApiSearchDictionaryEntriesRequest {
	return ApiSearchDictionaryEntriesRequest{
		dictionaryName:                dictionaryName,
		searchDictionaryEntriesParams: searchDictionaryEntriesParams,
	}
}

/*
SearchDictionaryEntries calls the API and returns the raw response from it.

	  Searches for standard and custom dictionary entries.

	    Required API Key ACLs:
	    - settings

	Request can be constructed by NewApiSearchDictionaryEntriesRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param dictionaryName DictionaryType - Dictionary type in which to search.
	  @param searchDictionaryEntriesParams SearchDictionaryEntriesParams
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchDictionaryEntriesWithHTTPInfo(ctx context.Context, r ApiSearchDictionaryEntriesRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/dictionaries/{dictionaryName}/search"
	requestPath = strings.ReplaceAll(requestPath, "{dictionaryName}", url.PathEscape(parameterToString(r.dictionaryName)))

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.searchDictionaryEntriesParams == nil {
		return nil, nil, reportError("Parameter `searchDictionaryEntriesParams` is required when calling `SearchDictionaryEntries`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.searchDictionaryEntriesParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true)
}

/*
SearchDictionaryEntries wraps SearchDictionaryEntriesWithContext using context.Background.

Searches for standard and custom dictionary entries.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiSearchDictionaryEntriesRequest with parameters below.

	@param dictionaryName DictionaryType - Dictionary type in which to search.
	@param searchDictionaryEntriesParams SearchDictionaryEntriesParams
	@return SearchDictionaryEntriesResponse
*/
func (c *APIClient) SearchDictionaryEntries(r ApiSearchDictionaryEntriesRequest, opts ...Option) (*SearchDictionaryEntriesResponse, error) {
	return c.SearchDictionaryEntriesWithContext(context.Background(), r, opts...)
}

/*
SearchDictionaryEntries casts the HTTP response body to a defined struct.

Searches for standard and custom dictionary entries.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiSearchDictionaryEntriesRequest with parameters below.

	@param dictionaryName DictionaryType - Dictionary type in which to search.
	@param searchDictionaryEntriesParams SearchDictionaryEntriesParams
	@return SearchDictionaryEntriesResponse
*/
func (c *APIClient) SearchDictionaryEntriesWithContext(ctx context.Context, r ApiSearchDictionaryEntriesRequest, opts ...Option) (*SearchDictionaryEntriesResponse, error) {
	var returnValue *SearchDictionaryEntriesResponse

	res, resBody, err := c.SearchDictionaryEntriesWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchForFacetValuesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["facetName"]; ok {
		err = json.Unmarshal(v, &r.facetName)
		if err != nil {
			err = json.Unmarshal(b, &r.facetName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal facetName: %w", err)
			}
		}
	}
	if v, ok := req["searchForFacetValuesRequest"]; ok {
		err = json.Unmarshal(v, &r.searchForFacetValuesRequest)
		if err != nil {
			err = json.Unmarshal(b, &r.searchForFacetValuesRequest)
			if err != nil {
				return fmt.Errorf("cannot unmarshal searchForFacetValuesRequest: %w", err)
			}
		}
	}

	return nil
}

// ApiSearchForFacetValuesRequest represents the request with all the parameters for the API call.
type ApiSearchForFacetValuesRequest struct {
	indexName                   string
	facetName                   string
	searchForFacetValuesRequest *SearchForFacetValuesRequest
}

// NewApiSearchForFacetValuesRequest creates an instance of the ApiSearchForFacetValuesRequest to be used for the API call.
func (c *APIClient) NewApiSearchForFacetValuesRequest(indexName string, facetName string) ApiSearchForFacetValuesRequest {
	return ApiSearchForFacetValuesRequest{
		indexName: indexName,
		facetName: facetName,
	}
}

// WithSearchForFacetValuesRequest adds the searchForFacetValuesRequest to the ApiSearchForFacetValuesRequest and returns the request for chaining.
func (r ApiSearchForFacetValuesRequest) WithSearchForFacetValuesRequest(searchForFacetValuesRequest *SearchForFacetValuesRequest) ApiSearchForFacetValuesRequest {
	r.searchForFacetValuesRequest = searchForFacetValuesRequest
	return r
}

/*
SearchForFacetValues calls the API and returns the raw response from it.

		Searches for values of a specified facet attribute.

	  - By default, facet values are sorted by decreasing count.
	    You can adjust this with the `sortFacetValueBy` parameter.

	  - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.

	    Required API Key ACLs:

	  - search

	    Request can be constructed by NewApiSearchForFacetValuesRequest with parameters below.
	    @param ctx context.Context - Context of the request
	    @param indexName string - Name of the index on which to perform the operation.
	    @param facetName string - Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.
	    @param searchForFacetValuesRequest SearchForFacetValuesRequest
	    @param opts ...Option - Optional parameters for the API call
	    @return *http.Response - The raw response from the API
	    @return []byte - The raw response body from the API
	    @return error - An error if the API call fails
*/
func (c *APIClient) SearchForFacetValuesWithHTTPInfo(ctx context.Context, r ApiSearchForFacetValuesRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/facets/{facetName}/query"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{facetName}", url.PathEscape(parameterToString(r.facetName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SearchForFacetValues`.")
	}
	if r.facetName == "" {
		return nil, nil, reportError("Parameter `facetName` is required when calling `SearchForFacetValues`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.searchForFacetValuesRequest) {
		postBody = "{}"
	} else {
		postBody = r.searchForFacetValuesRequest
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true)
}

/*
SearchForFacetValues wraps SearchForFacetValuesWithContext using context.Background.

Searches for values of a specified facet attribute.

  - By default, facet values are sorted by decreasing count.
    You can adjust this with the `sortFacetValueBy` parameter.
  - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.

Required API Key ACLs:
  - search

Request can be constructed by NewApiSearchForFacetValuesRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param facetName string - Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.
	@param searchForFacetValuesRequest SearchForFacetValuesRequest
	@return SearchForFacetValuesResponse
*/
func (c *APIClient) SearchForFacetValues(r ApiSearchForFacetValuesRequest, opts ...Option) (*SearchForFacetValuesResponse, error) {
	return c.SearchForFacetValuesWithContext(context.Background(), r, opts...)
}

/*
SearchForFacetValues casts the HTTP response body to a defined struct.

Searches for values of a specified facet attribute.

  - By default, facet values are sorted by decreasing count.
    You can adjust this with the `sortFacetValueBy` parameter.
  - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.

Required API Key ACLs:
  - search

Request can be constructed by NewApiSearchForFacetValuesRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param facetName string - Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.
	@param searchForFacetValuesRequest SearchForFacetValuesRequest
	@return SearchForFacetValuesResponse
*/
func (c *APIClient) SearchForFacetValuesWithContext(ctx context.Context, r ApiSearchForFacetValuesRequest, opts ...Option) (*SearchForFacetValuesResponse, error) {
	var returnValue *SearchForFacetValuesResponse

	res, resBody, err := c.SearchForFacetValuesWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchRulesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["searchRulesParams"]; ok {
		err = json.Unmarshal(v, &r.searchRulesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchRulesParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal searchRulesParams: %w", err)
			}
		}
	}

	return nil
}

// ApiSearchRulesRequest represents the request with all the parameters for the API call.
type ApiSearchRulesRequest struct {
	indexName         string
	searchRulesParams *SearchRulesParams
}

// NewApiSearchRulesRequest creates an instance of the ApiSearchRulesRequest to be used for the API call.
func (c *APIClient) NewApiSearchRulesRequest(indexName string) ApiSearchRulesRequest {
	return ApiSearchRulesRequest{
		indexName: indexName,
	}
}

// WithSearchRulesParams adds the searchRulesParams to the ApiSearchRulesRequest and returns the request for chaining.
func (r ApiSearchRulesRequest) WithSearchRulesParams(searchRulesParams *SearchRulesParams) ApiSearchRulesRequest {
	r.searchRulesParams = searchRulesParams
	return r
}

/*
SearchRules calls the API and returns the raw response from it.

	  Searches for rules in your index.

	    Required API Key ACLs:
	    - settings

	Request can be constructed by NewApiSearchRulesRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param searchRulesParams SearchRulesParams
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchRulesWithHTTPInfo(ctx context.Context, r ApiSearchRulesRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/rules/search"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SearchRules`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.searchRulesParams) {
		postBody = "{}"
	} else {
		postBody = r.searchRulesParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true)
}

/*
SearchRules wraps SearchRulesWithContext using context.Background.

Searches for rules in your index.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiSearchRulesRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param searchRulesParams SearchRulesParams
	@return SearchRulesResponse
*/
func (c *APIClient) SearchRules(r ApiSearchRulesRequest, opts ...Option) (*SearchRulesResponse, error) {
	return c.SearchRulesWithContext(context.Background(), r, opts...)
}

/*
SearchRules casts the HTTP response body to a defined struct.

Searches for rules in your index.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiSearchRulesRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param searchRulesParams SearchRulesParams
	@return SearchRulesResponse
*/
func (c *APIClient) SearchRulesWithContext(ctx context.Context, r ApiSearchRulesRequest, opts ...Option) (*SearchRulesResponse, error) {
	var returnValue *SearchRulesResponse

	res, resBody, err := c.SearchRulesWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchSingleIndexRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["searchParams"]; ok {
		err = json.Unmarshal(v, &r.searchParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal searchParams: %w", err)
			}
		}
	}

	return nil
}

// ApiSearchSingleIndexRequest represents the request with all the parameters for the API call.
type ApiSearchSingleIndexRequest struct {
	indexName    string
	searchParams *SearchParams
}

// NewApiSearchSingleIndexRequest creates an instance of the ApiSearchSingleIndexRequest to be used for the API call.
func (c *APIClient) NewApiSearchSingleIndexRequest(indexName string) ApiSearchSingleIndexRequest {
	return ApiSearchSingleIndexRequest{
		indexName: indexName,
	}
}

// WithSearchParams adds the searchParams to the ApiSearchSingleIndexRequest and returns the request for chaining.
func (r ApiSearchSingleIndexRequest) WithSearchParams(searchParams *SearchParams) ApiSearchSingleIndexRequest {
	r.searchParams = searchParams
	return r
}

/*
SearchSingleIndex calls the API and returns the raw response from it.

	Searches a single index and return matching search results (_hits_).

This method lets you retrieve up to 1,000 hits.
If you need more, use the [`browse` operation](#tag/Search/operation/browse) or increase the `paginatedLimitedTo` index setting.

	    Required API Key ACLs:
	    - search

	Request can be constructed by NewApiSearchSingleIndexRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param searchParams SearchParams
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchSingleIndexWithHTTPInfo(ctx context.Context, r ApiSearchSingleIndexRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/query"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SearchSingleIndex`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.searchParams) {
		postBody = "{}"
	} else {
		postBody = r.searchParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true)
}

/*
SearchSingleIndex wraps SearchSingleIndexWithContext using context.Background.

Searches a single index and return matching search results (_hits_).

This method lets you retrieve up to 1,000 hits.
If you need more, use the [`browse` operation](#tag/Search/operation/browse) or increase the `paginatedLimitedTo` index setting.

Required API Key ACLs:
  - search

Request can be constructed by NewApiSearchSingleIndexRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param searchParams SearchParams
	@return SearchResponse
*/
func (c *APIClient) SearchSingleIndex(r ApiSearchSingleIndexRequest, opts ...Option) (*SearchResponse, error) {
	return c.SearchSingleIndexWithContext(context.Background(), r, opts...)
}

/*
SearchSingleIndex casts the HTTP response body to a defined struct.

Searches a single index and return matching search results (_hits_).

This method lets you retrieve up to 1,000 hits.
If you need more, use the [`browse` operation](#tag/Search/operation/browse) or increase the `paginatedLimitedTo` index setting.

Required API Key ACLs:
  - search

Request can be constructed by NewApiSearchSingleIndexRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param searchParams SearchParams
	@return SearchResponse
*/
func (c *APIClient) SearchSingleIndexWithContext(ctx context.Context, r ApiSearchSingleIndexRequest, opts ...Option) (*SearchResponse, error) {
	var returnValue *SearchResponse

	res, resBody, err := c.SearchSingleIndexWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchSynonymsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["searchSynonymsParams"]; ok {
		err = json.Unmarshal(v, &r.searchSynonymsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchSynonymsParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal searchSynonymsParams: %w", err)
			}
		}
	}

	return nil
}

// ApiSearchSynonymsRequest represents the request with all the parameters for the API call.
type ApiSearchSynonymsRequest struct {
	indexName            string
	searchSynonymsParams *SearchSynonymsParams
}

// NewApiSearchSynonymsRequest creates an instance of the ApiSearchSynonymsRequest to be used for the API call.
func (c *APIClient) NewApiSearchSynonymsRequest(indexName string) ApiSearchSynonymsRequest {
	return ApiSearchSynonymsRequest{
		indexName: indexName,
	}
}

// WithSearchSynonymsParams adds the searchSynonymsParams to the ApiSearchSynonymsRequest and returns the request for chaining.
func (r ApiSearchSynonymsRequest) WithSearchSynonymsParams(searchSynonymsParams *SearchSynonymsParams) ApiSearchSynonymsRequest {
	r.searchSynonymsParams = searchSynonymsParams
	return r
}

/*
SearchSynonyms calls the API and returns the raw response from it.

	  Searches for synonyms in your index.

	    Required API Key ACLs:
	    - settings

	Request can be constructed by NewApiSearchSynonymsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param searchSynonymsParams SearchSynonymsParams - Body of the `searchSynonyms` operation.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchSynonymsWithHTTPInfo(ctx context.Context, r ApiSearchSynonymsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/synonyms/search"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SearchSynonyms`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.searchSynonymsParams) {
		postBody = "{}"
	} else {
		postBody = r.searchSynonymsParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true)
}

/*
SearchSynonyms wraps SearchSynonymsWithContext using context.Background.

Searches for synonyms in your index.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiSearchSynonymsRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param searchSynonymsParams SearchSynonymsParams - Body of the `searchSynonyms` operation.
	@return SearchSynonymsResponse
*/
func (c *APIClient) SearchSynonyms(r ApiSearchSynonymsRequest, opts ...Option) (*SearchSynonymsResponse, error) {
	return c.SearchSynonymsWithContext(context.Background(), r, opts...)
}

/*
SearchSynonyms casts the HTTP response body to a defined struct.

Searches for synonyms in your index.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiSearchSynonymsRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param searchSynonymsParams SearchSynonymsParams - Body of the `searchSynonyms` operation.
	@return SearchSynonymsResponse
*/
func (c *APIClient) SearchSynonymsWithContext(ctx context.Context, r ApiSearchSynonymsRequest, opts ...Option) (*SearchSynonymsResponse, error) {
	var returnValue *SearchSynonymsResponse

	res, resBody, err := c.SearchSynonymsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchUserIdsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["searchUserIdsParams"]; ok {
		err = json.Unmarshal(v, &r.searchUserIdsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchUserIdsParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal searchUserIdsParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.searchUserIdsParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter searchUserIdsParams: %w", err)
		}
	}

	return nil
}

// ApiSearchUserIdsRequest represents the request with all the parameters for the API call.
type ApiSearchUserIdsRequest struct {
	searchUserIdsParams *SearchUserIdsParams
}

// NewApiSearchUserIdsRequest creates an instance of the ApiSearchUserIdsRequest to be used for the API call.
func (c *APIClient) NewApiSearchUserIdsRequest(searchUserIdsParams *SearchUserIdsParams) ApiSearchUserIdsRequest {
	return ApiSearchUserIdsRequest{
		searchUserIdsParams: searchUserIdsParams,
	}
}

/*
SearchUserIds calls the API and returns the raw response from it.

	Since it can take a few seconds to get the data from the different clusters,

the response isn't real-time.

To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiSearchUserIdsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param searchUserIdsParams SearchUserIdsParams
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchUserIdsWithHTTPInfo(ctx context.Context, r ApiSearchUserIdsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/clusters/mapping/search"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.searchUserIdsParams == nil {
		return nil, nil, reportError("Parameter `searchUserIdsParams` is required when calling `SearchUserIds`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.searchUserIdsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true)
}

/*
SearchUserIds wraps SearchUserIdsWithContext using context.Background.

Since it can take a few seconds to get the data from the different clusters,
the response isn't real-time.

To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).

Required API Key ACLs:
  - admin

Request can be constructed by NewApiSearchUserIdsRequest with parameters below.

	@param searchUserIdsParams SearchUserIdsParams
	@return SearchUserIdsResponse
*/
func (c *APIClient) SearchUserIds(r ApiSearchUserIdsRequest, opts ...Option) (*SearchUserIdsResponse, error) {
	return c.SearchUserIdsWithContext(context.Background(), r, opts...)
}

/*
SearchUserIds casts the HTTP response body to a defined struct.

Since it can take a few seconds to get the data from the different clusters,
the response isn't real-time.

To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).

Required API Key ACLs:
  - admin

Request can be constructed by NewApiSearchUserIdsRequest with parameters below.

	@param searchUserIdsParams SearchUserIdsParams
	@return SearchUserIdsResponse
*/
func (c *APIClient) SearchUserIdsWithContext(ctx context.Context, r ApiSearchUserIdsRequest, opts ...Option) (*SearchUserIdsResponse, error) {
	var returnValue *SearchUserIdsResponse

	res, resBody, err := c.SearchUserIdsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSetDictionarySettingsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["dictionarySettingsParams"]; ok {
		err = json.Unmarshal(v, &r.dictionarySettingsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.dictionarySettingsParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal dictionarySettingsParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.dictionarySettingsParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter dictionarySettingsParams: %w", err)
		}
	}

	return nil
}

// ApiSetDictionarySettingsRequest represents the request with all the parameters for the API call.
type ApiSetDictionarySettingsRequest struct {
	dictionarySettingsParams *DictionarySettingsParams
}

// NewApiSetDictionarySettingsRequest creates an instance of the ApiSetDictionarySettingsRequest to be used for the API call.
func (c *APIClient) NewApiSetDictionarySettingsRequest(dictionarySettingsParams *DictionarySettingsParams) ApiSetDictionarySettingsRequest {
	return ApiSetDictionarySettingsRequest{
		dictionarySettingsParams: dictionarySettingsParams,
	}
}

/*
SetDictionarySettings calls the API and returns the raw response from it.

	  Turns standard stop word dictionary entries on or off for a given language.

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiSetDictionarySettingsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param dictionarySettingsParams DictionarySettingsParams
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SetDictionarySettingsWithHTTPInfo(ctx context.Context, r ApiSetDictionarySettingsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/dictionaries/*/settings"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.dictionarySettingsParams == nil {
		return nil, nil, reportError("Parameter `dictionarySettingsParams` is required when calling `SetDictionarySettings`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.dictionarySettingsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SetDictionarySettings wraps SetDictionarySettingsWithContext using context.Background.

Turns standard stop word dictionary entries on or off for a given language.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiSetDictionarySettingsRequest with parameters below.

	@param dictionarySettingsParams DictionarySettingsParams
	@return UpdatedAtResponse
*/
func (c *APIClient) SetDictionarySettings(r ApiSetDictionarySettingsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SetDictionarySettingsWithContext(context.Background(), r, opts...)
}

/*
SetDictionarySettings casts the HTTP response body to a defined struct.

Turns standard stop word dictionary entries on or off for a given language.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiSetDictionarySettingsRequest with parameters below.

	@param dictionarySettingsParams DictionarySettingsParams
	@return UpdatedAtResponse
*/
func (c *APIClient) SetDictionarySettingsWithContext(ctx context.Context, r ApiSetDictionarySettingsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.SetDictionarySettingsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSetSettingsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["indexSettings"]; ok {
		err = json.Unmarshal(v, &r.indexSettings)
		if err != nil {
			err = json.Unmarshal(b, &r.indexSettings)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexSettings: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.indexSettings)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter indexSettings: %w", err)
		}
	}
	if v, ok := req["forwardToReplicas"]; ok {
		err = json.Unmarshal(v, &r.forwardToReplicas)
		if err != nil {
			err = json.Unmarshal(b, &r.forwardToReplicas)
			if err != nil {
				return fmt.Errorf("cannot unmarshal forwardToReplicas: %w", err)
			}
		}
	}

	return nil
}

// ApiSetSettingsRequest represents the request with all the parameters for the API call.
type ApiSetSettingsRequest struct {
	indexName         string
	indexSettings     *IndexSettings
	forwardToReplicas *bool
}

// NewApiSetSettingsRequest creates an instance of the ApiSetSettingsRequest to be used for the API call.
func (c *APIClient) NewApiSetSettingsRequest(indexName string, indexSettings *IndexSettings) ApiSetSettingsRequest {
	return ApiSetSettingsRequest{
		indexName:     indexName,
		indexSettings: indexSettings,
	}
}

// WithForwardToReplicas adds the forwardToReplicas to the ApiSetSettingsRequest and returns the request for chaining.
func (r ApiSetSettingsRequest) WithForwardToReplicas(forwardToReplicas bool) ApiSetSettingsRequest {
	r.forwardToReplicas = &forwardToReplicas
	return r
}

/*
SetSettings calls the API and returns the raw response from it.

	Update the specified index settings.

Index settings that you don't specify are left unchanged.
Specify `null` to reset a setting to its default value.

For best performance, update the index settings before you add new records to your index.

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiSetSettingsRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param indexName string - Name of the index on which to perform the operation.
	  @param indexSettings IndexSettings
	  @param forwardToReplicas bool - Whether changes are applied to replica indices.
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SetSettingsWithHTTPInfo(ctx context.Context, r ApiSetSettingsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/indexes/{indexName}/settings"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SetSettings`.")
	}

	if r.indexSettings == nil {
		return nil, nil, reportError("Parameter `indexSettings` is required when calling `SetSettings`.")
	}

	if !utils.IsNilOrEmpty(r.forwardToReplicas) {
		queryParams.Set("forwardToReplicas", queryParameterToString(*r.forwardToReplicas))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.indexSettings
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SetSettings wraps SetSettingsWithContext using context.Background.

Update the specified index settings.

Index settings that you don't specify are left unchanged.
Specify `null` to reset a setting to its default value.

For best performance, update the index settings before you add new records to your index.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiSetSettingsRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param indexSettings IndexSettings
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) SetSettings(r ApiSetSettingsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	return c.SetSettingsWithContext(context.Background(), r, opts...)
}

/*
SetSettings casts the HTTP response body to a defined struct.

Update the specified index settings.

Index settings that you don't specify are left unchanged.
Specify `null` to reset a setting to its default value.

For best performance, update the index settings before you add new records to your index.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiSetSettingsRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param indexSettings IndexSettings
	@param forwardToReplicas bool - Whether changes are applied to replica indices.
	@return UpdatedAtResponse
*/
func (c *APIClient) SetSettingsWithContext(ctx context.Context, r ApiSetSettingsRequest, opts ...Option) (*UpdatedAtResponse, error) {
	var returnValue *UpdatedAtResponse

	res, resBody, err := c.SetSettingsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateApiKeyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["key"]; ok {
		err = json.Unmarshal(v, &r.key)
		if err != nil {
			err = json.Unmarshal(b, &r.key)
			if err != nil {
				return fmt.Errorf("cannot unmarshal key: %w", err)
			}
		}
	}
	if v, ok := req["apiKey"]; ok {
		err = json.Unmarshal(v, &r.apiKey)
		if err != nil {
			err = json.Unmarshal(b, &r.apiKey)
			if err != nil {
				return fmt.Errorf("cannot unmarshal apiKey: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.apiKey)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter apiKey: %w", err)
		}
	}

	return nil
}

// ApiUpdateApiKeyRequest represents the request with all the parameters for the API call.
type ApiUpdateApiKeyRequest struct {
	key    string
	apiKey *ApiKey
}

// NewApiUpdateApiKeyRequest creates an instance of the ApiUpdateApiKeyRequest to be used for the API call.
func (c *APIClient) NewApiUpdateApiKeyRequest(key string, apiKey *ApiKey) ApiUpdateApiKeyRequest {
	return ApiUpdateApiKeyRequest{
		key:    key,
		apiKey: apiKey,
	}
}

/*
UpdateApiKey calls the API and returns the raw response from it.

	Replaces the permissions of an existing API key.

Any unspecified attribute resets that attribute to its default value.

	    Required API Key ACLs:
	    - admin

	Request can be constructed by NewApiUpdateApiKeyRequest with parameters below.
	@param ctx context.Context - Context of the request
	  @param key string - API key.
	  @param apiKey ApiKey
	@param opts ...Option - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) UpdateApiKeyWithHTTPInfo(ctx context.Context, r ApiUpdateApiKeyRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/keys/{key}"
	requestPath = strings.ReplaceAll(requestPath, "{key}", url.PathEscape(parameterToString(r.key)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.key == "" {
		return nil, nil, reportError("Parameter `key` is required when calling `UpdateApiKey`.")
	}

	if r.apiKey == nil {
		return nil, nil, reportError("Parameter `apiKey` is required when calling `UpdateApiKey`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.apiKey
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateApiKey wraps UpdateApiKeyWithContext using context.Background.

Replaces the permissions of an existing API key.

Any unspecified attribute resets that attribute to its default value.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiUpdateApiKeyRequest with parameters below.

	@param key string - API key.
	@param apiKey ApiKey
	@return UpdateApiKeyResponse
*/
func (c *APIClient) UpdateApiKey(r ApiUpdateApiKeyRequest, opts ...Option) (*UpdateApiKeyResponse, error) {
	return c.UpdateApiKeyWithContext(context.Background(), r, opts...)
}

/*
UpdateApiKey casts the HTTP response body to a defined struct.

Replaces the permissions of an existing API key.

Any unspecified attribute resets that attribute to its default value.

Required API Key ACLs:
  - admin

Request can be constructed by NewApiUpdateApiKeyRequest with parameters below.

	@param key string - API key.
	@param apiKey ApiKey
	@return UpdateApiKeyResponse
*/
func (c *APIClient) UpdateApiKeyWithContext(ctx context.Context, r ApiUpdateApiKeyRequest, opts ...Option) (*UpdateApiKeyResponse, error) {
	var returnValue *UpdateApiKeyResponse

	res, resBody, err := c.UpdateApiKeyWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
SearchForHits calls the `search` method but with certainty that we will only request Algolia records (hits) and not facets.
Disclaimer: We don't assert that the parameters you pass to this method only contains `hits` requests to prevent impacting search performances, this helper is purely for typing purposes.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param r ApiSearchRequest - Body of the `search` operation.
	@param opts ...Option - Optional parameters for the request.
	@return []SearchResponse - List of hits.
	@return error - Error if any.
*/
func (c *APIClient) SearchForHits(ctx context.Context, r ApiSearchRequest, opts ...Option) ([]SearchResponse, error) {
	res, err := c.SearchWithContext(ctx, r, opts...)
	if err != nil {
		return nil, err
	}

	hits := make([]SearchResponse, 0, len(res.GetResults()))

	for _, hit := range res.GetResults() {
		if hit.SearchResponse != nil {
			hits = append(hits, *hit.SearchResponse)
		}
	}

	return slices.Clip(hits), nil
}

/*
SearchForFacets calls the `search` method but with certainty that we will only request Algolia facets and not records (hits).
Disclaimer: We don't assert that the parameters you pass to this method only contains `facets` requests to prevent impacting search performances, this helper is purely for typing purposes.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param r ApiSearchRequest - Body of the `search` operation.
	@param opts ...Option - Optional parameters for the request.
	@return []SearchForFacetValuesResponse - List of facet hits.
	@return error - Error if any.
*/
func (c *APIClient) SearchForFacets(ctx context.Context, r ApiSearchRequest, opts ...Option) ([]SearchForFacetValuesResponse, error) {
	res, err := c.SearchWithContext(ctx, r, opts...)
	if err != nil {
		return nil, err
	}

	facetHits := make([]SearchForFacetValuesResponse, 0, len(res.GetResults()))

	for _, hit := range res.GetResults() {
		if hit.SearchForFacetValuesResponse != nil {
			facetHits = append(facetHits, *hit.SearchForFacetValuesResponse)
		}
	}

	return slices.Clip(facetHits), nil
}

/*
WaitForTask waits for a task to be published.
Wraps WaitForTaskWithContext with context.Background().
It returns the task response if the operation was successful.
It returns an error if the operation failed.

		@param indexName string - Index name.
		@param taskID int64 - Task ID.
		@param maxRetries *float64 - Maximum number of retries.
	  @param timeout func(float64) time.Duration - Timeout function.
		@param opts ...Option - Optional parameters for the request.
		@return *GetTaskResponse - Task response.
		@return error - Error if any.
*/
func (c *APIClient) WaitForTask(
	indexName string,
	taskID int64,
	maxRetries *float64,
	timeout func(float64) time.Duration,
	opts ...Option,
) (*GetTaskResponse, error) {
	return c.WaitForTaskWithContext(
		context.Background(),
		indexName,
		taskID,
		maxRetries,
		timeout,
		opts...,
	)
}

/*
WaitForTaskWithContext waits for a task to be published.
It returns the task response if the operation was successful.
It returns an error if the operation failed.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param indexName string - Index name.
	@param taskID int64 - Task ID.
	@param maxRetries *float64 - Maximum number of retries.
	@param timeout func(float64) time.Duration - Timeout function.
	@param opts ...Option - Optional parameters for the request.
	@return *GetTaskResponse - Task response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForTaskWithContext(
	ctx context.Context,
	indexName string,
	taskID int64,
	maxRetries *float64,
	timeout func(float64) time.Duration,
	opts ...Option,
) (*GetTaskResponse, error) {
	retryCount := float64(0)

	if maxRetries == nil {
		maxRetries = new(float64)
		*maxRetries = 50
	}

	if timeout == nil {
		timeout = func(count float64) time.Duration {
			return time.Duration(min(count*0.2, 5)) * time.Second
		}
	}

	return utils.CreateIterable( //nolint:wrapcheck
		func(*GetTaskResponse, error) (*GetTaskResponse, error) {
			return c.GetTaskWithContext(ctx, c.NewApiGetTaskRequest(indexName, taskID), opts...)
		},
		func(response *GetTaskResponse, err error) bool {
			if err != nil || response == nil {
				return false
			}

			return response.Status == TASK_STATUS_PUBLISHED
		},
		func(*GetTaskResponse, error) {
			retryCount++
		},
		func() time.Duration {
			return timeout(retryCount)
		},
		&utils.IterableError[GetTaskResponse]{
			Validate: func(*GetTaskResponse, error) bool {
				return retryCount >= *maxRetries
			},
			Message: func(*GetTaskResponse, error) string {
				return fmt.Sprintf("The maximum number of retries exceeded. (%f/%f)", retryCount, *maxRetries)
			},
		},
	)
}

/*
WaitForAppTask waits for an application-level task to be published.
Wraps WaitForAppTask with context.Background().
It returns the task response if the operation was successful.
It returns an error if the operation failed.

	@param taskID int64 - Task ID.
	@param maxRetries *float64 - Maximum number of retries.
	@param timeout func(float64) time.Duration - Timeout function.
	@param opts ...Option - Optional parameters for the request.
	@return *GetTaskResponse - Task response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForAppTask(
	taskID int64,
	maxRetries *float64,
	timeout func(float64) time.Duration,
	opts ...Option,
) (*GetTaskResponse, error) {
	return c.WaitForAppTaskWithContext(
		context.Background(),
		taskID,
		maxRetries,
		timeout,
		opts...,
	)
}

/*
WaitForAppTaskWithContext waits for an application-level task to be published.
It returns the task response if the operation was successful.
It returns an error if the operation failed.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param taskID int64 - Task ID.
	@param maxRetries *float64 - Maximum number of retries.
	@param timeout func(float64) time.Duration - Timeout function.
	@param opts ...Option - Optional parameters for the request.
	@return *GetTaskResponse - Task response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForAppTaskWithContext(
	ctx context.Context,
	taskID int64,
	maxRetries *float64,
	timeout func(float64) time.Duration,
	opts ...Option,
) (*GetTaskResponse, error) {
	retryCount := float64(0)

	if maxRetries == nil {
		maxRetries = new(float64)
		*maxRetries = 50
	}

	if timeout == nil {
		timeout = func(count float64) time.Duration {
			return time.Duration(min(count*0.2, 5)) * time.Second
		}
	}

	return utils.CreateIterable( //nolint:wrapcheck
		func(*GetTaskResponse, error) (*GetTaskResponse, error) {
			return c.GetAppTaskWithContext(ctx, c.NewApiGetAppTaskRequest(taskID), opts...)
		},
		func(response *GetTaskResponse, err error) bool {
			if err != nil || response == nil {
				return false
			}

			return response.Status == TASK_STATUS_PUBLISHED
		},
		func(*GetTaskResponse, error) {
			retryCount++
		},
		func() time.Duration {
			return timeout(retryCount)
		},
		&utils.IterableError[GetTaskResponse]{
			Validate: func(*GetTaskResponse, error) bool {
				return retryCount >= *maxRetries
			},
			Message: func(*GetTaskResponse, error) string {
				return fmt.Sprintf("The maximum number of retries exceeded. (%f/%f)", retryCount, *maxRetries)
			},
		},
	)
}

/*
WaitForApiKey waits for an API key to be created, deleted or updated.
It returns the API key response if the operation was successful.
It returns an error if the operation failed.

The operation can be one of the following:
  - "add": wait for the API key to be created
  - "delete": wait for the API key to be deleted
  - "update": wait for the API key to be updated

If the operation is "update", the apiKey parameter must be set.
If the operation is "delete" or "add", the apiKey parameter is not used.

	@param operation ApiKeyOperation - Operation type - add, delete or update.
	@param key string - API key.
	@param apiKey *ApiKey - API key structure - required for update operation.
	@param opts ...Option - Optional parameters for the request.
	@return *GetApiKeyResponse - API key response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForApiKey(
	operation ApiKeyOperation,
	key string,
	apiKey *ApiKey,
	opts ...Option,
) (*GetApiKeyResponse, error) {
	return c.WaitForApiKeyWithContext(
		context.Background(),
		operation,
		key,
		apiKey,
		nil,
		nil,
		opts...,
	)
}

/*
WaitForApiKey waits for an API key to be created, deleted or updated.
Wraps WaitForApiKeyWithContext with context.Background().
It returns the API key response if the operation was successful.
It returns an error if the operation failed.

The operation can be one of the following:
  - "add": wait for the API key to be created
  - "delete": wait for the API key to be deleted
  - "update": wait for the API key to be updated

If the operation is "update", the apiKey parameter must be set.
If the operation is "delete" or "add", the apiKey parameter is not used.

	@param operation ApiKeyOperation - Operation type - add, delete or update.
	@param key string - API key.
	@param apiKey *ApiKey - API key structure - required for update operation.
	@param maxRetries *float64 - Maximum number of retries.
	@param timeout func(float64) time.Duration - Timeout function.
	@param opts ...Option - Optional parameters for the request.
	@return *GetApiKeyResponse - API key response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForApiKeyWithOptions(
	operation ApiKeyOperation,
	key string,
	apiKey *ApiKey,
	maxRetries *float64,
	timeout func(float64) time.Duration,
	opts ...Option,
) (*GetApiKeyResponse, error) {
	return c.WaitForApiKeyWithContext(
		context.Background(),
		operation,
		key,
		apiKey,
		maxRetries,
		timeout,
		opts...,
	)
}

/*
WaitForApiKeyWithContext waits for an API key to be created, deleted or updated.
It returns the API key response if the operation was successful.
It returns an error if the operation failed.

The operation can be one of the following:
  - "add": wait for the API key to be created
  - "delete": wait for the API key to be deleted
  - "update": wait for the API key to be updated

If the operation is "update", the apiKey parameter must be set.
If the operation is "delete" or "add", the apiKey parameter is not used.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param operation ApiKeyOperation - Operation type - add, delete or update.
	@param key string - API key.
	@param apiKey *ApiKey - API key structure - required for update operation.
	@param maxRetries *float64 - Maximum number of retries.
	@param timeout func(float64) time.Duration - Timeout function.
	@param opts ...Option - Optional parameters for the request.
	@return *GetApiKeyResponse - API key response.
	@return error - Error if any.
*/
func (c *APIClient) WaitForApiKeyWithContext(
	ctx context.Context,
	operation ApiKeyOperation,
	key string,
	apiKey *ApiKey,
	maxRetries *float64,
	timeout func(float64) time.Duration,
	opts ...Option,
) (*GetApiKeyResponse, error) {
	if operation != API_KEY_OPERATION_ADD && operation != API_KEY_OPERATION_DELETE && operation != API_KEY_OPERATION_UPDATE {
		return nil, &errs.WaitKeyOperationError{}
	}

	retryCount := float64(0)

	if maxRetries == nil {
		maxRetries = new(float64)
		*maxRetries = 50
	}

	if timeout == nil {
		timeout = func(count float64) time.Duration {
			return time.Duration(min(count*0.2, 5)) * time.Second
		}
	}

	var validateFunc func(*GetApiKeyResponse, error) bool

	if operation == API_KEY_OPERATION_UPDATE {
		if apiKey == nil {
			return nil, &errs.WaitKeyUpdateError{}
		}

		validateFunc = func(response *GetApiKeyResponse, err error) bool {
			if err != nil || response == nil {
				return false
			}

			if apiKey.GetDescription() != response.GetDescription() {
				return false
			}

			if apiKey.GetQueryParameters() != response.GetQueryParameters() {
				return false
			}

			if apiKey.GetMaxHitsPerQuery() != response.GetMaxHitsPerQuery() {
				return false
			}

			if apiKey.GetMaxQueriesPerIPPerHour() != response.GetMaxQueriesPerIPPerHour() {
				return false
			}

			if apiKey.GetValidity() != response.GetValidity() {
				return false
			}

			slices.Sort(apiKey.Acl)
			slices.Sort(response.Acl)

			if !slices.Equal(apiKey.Acl, response.Acl) {
				return false
			}

			slices.Sort(apiKey.Indexes)
			slices.Sort(response.Indexes)

			if !slices.Equal(apiKey.Indexes, response.Indexes) {
				return false
			}

			slices.Sort(apiKey.Referers)
			slices.Sort(response.Referers)

			return slices.Equal(apiKey.Referers, response.Referers)
		}
	} else {
		validateFunc = func(response *GetApiKeyResponse, err error) bool {
			switch operation {
			case API_KEY_OPERATION_ADD:
				if _, ok := err.(*APIError); ok {
					apiErr := err.(*APIError)

					return apiErr.Status != 404
				}

				return true
			case API_KEY_OPERATION_DELETE:
				if _, ok := err.(*APIError); ok {
					apiErr := err.(*APIError)

					return apiErr.Status == 404
				}

				return false
			}
			return false
		}
	}

	return utils.CreateIterable( //nolint:wrapcheck
		func(*GetApiKeyResponse, error) (*GetApiKeyResponse, error) {
			return c.GetApiKeyWithContext(ctx, c.NewApiGetApiKeyRequest(key), opts...)
		},
		validateFunc,
		func(*GetApiKeyResponse, error) {
			retryCount += 1
		},
		func() time.Duration {
			return timeout(retryCount)
		},
		&utils.IterableError[GetApiKeyResponse]{
			Validate: func(*GetApiKeyResponse, error) bool {
				return retryCount >= *maxRetries
			},
			Message: func(*GetApiKeyResponse, error) string {
				return fmt.Sprintf("The maximum number of retries exceeded. (%f/%f)", retryCount, *maxRetries)
			},
		},
	)
}

/*
BrowseObjects allows to aggregate all the hits returned by the API calls.
Wraps BrowseObjectsWithContext using context.Background.

		@param indexName string - Index name.
	  @param browseParams BrowseParamsObject - Browse parameters.
	  @param validate func(*BrowseResponse, error) bool - Validator function.
	  @param aggregator func(*BrowseResponse) - Aggregator function.
		@param opts ...Option - Optional parameters for the request.
		@return *BrowseResponse - Browse response.
		@return error - Error if any.
*/
func (c *APIClient) BrowseObjects(
	indexName string,
	browseParams BrowseParamsObject,
	validate func(*BrowseResponse, error) bool,
	aggregator func(*BrowseResponse, error),
	opts ...Option,
) (*BrowseResponse, error) {
	return c.BrowseObjectsWithContext(context.Background(), indexName, browseParams, validate, aggregator, opts...)
}

/*
BrowseObjectsWithContext allows to aggregate all the hits returned by the API calls.

		@param ctx context.Context - The context that will be drilled down to the actual request.
	  @param indexName string - Index name.
	  @param browseParams BrowseParamsObject - Browse parameters.
	  @param validate func(*BrowseResponse, error) bool - Validator function.
	  @param aggregator func(*BrowseResponse) - Aggregator function.
		@param opts ...Option - Optional parameters for the request.
		@return *BrowseResponse - Browse response.
		@return error - Error if any.
*/
func (c *APIClient) BrowseObjectsWithContext(
	ctx context.Context,
	indexName string,
	browseParams BrowseParamsObject,
	validate func(*BrowseResponse, error) bool,
	aggregator func(*BrowseResponse, error),
	opts ...Option,
) (*BrowseResponse, error) {
	if validate == nil {
		validate = func(response *BrowseResponse, responseErr error) bool {
			return responseErr != nil || response != nil && response.Cursor == nil
		}
	}

	return utils.CreateIterable( //nolint:wrapcheck
		func(previousResponse *BrowseResponse, previousErr error) (*BrowseResponse, error) {
			if previousResponse != nil {
				browseParams.Cursor = previousResponse.Cursor
			}

			return c.BrowseWithContext(
				ctx,
				c.NewApiBrowseRequest(indexName).WithBrowseParams(BrowseParamsObjectAsBrowseParams(&browseParams)),
				opts...,
			)
		},
		validate,
		aggregator,
		nil,
		nil,
	)
}

/*
BrowseRules allows to aggregate all the rules returned by the API calls.
Wraps BrowseRulesWithContext using context.Background.

	@param indexName string - Index name.
	@param searchRulesParams SearchRulesParams - Search rules parameters.
	@param validate func(*SearchRulesResponse, error) bool - Validator function.
	@param aggregator func(*SearchRulesResponse) - Aggregator function.
	@param opts ...Option - Optional parameters for the request.
	@return *SearchRulesResponse - Search rules response.
	@return error - Error if any.
*/
func (c *APIClient) BrowseRules(
	indexName string,
	searchRulesParams SearchRulesParams,
	validate func(*SearchRulesResponse, error) bool,
	aggregator func(*SearchRulesResponse, error),
	opts ...Option,
) (*SearchRulesResponse, error) {
	return c.BrowseRulesWithContext(context.Background(), indexName, searchRulesParams, validate, aggregator, opts...)
}

/*
BrowseRulesWithContext allows to aggregate all the rules returned by the API calls.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param indexName string - Index name.
	@param searchRulesParams SearchRulesParams - Search rules parameters.
	@param validate func(*SearchRulesResponse, error) bool - Validator function.
	@param aggregator func(*SearchRulesResponse) - Aggregator function.
	@param opts ...Option - Optional parameters for the request.
	@return *SearchRulesResponse - Search rules response.
	@return error - Error if any.
*/
func (c *APIClient) BrowseRulesWithContext(
	ctx context.Context,
	indexName string,
	searchRulesParams SearchRulesParams,
	validate func(*SearchRulesResponse, error) bool,
	aggregator func(*SearchRulesResponse, error),
	opts ...Option,
) (*SearchRulesResponse, error) {
	hitsPerPage := int32(1000)
	if searchRulesParams.HitsPerPage != nil {
		hitsPerPage = *searchRulesParams.HitsPerPage
	}

	if validate == nil {
		validate = func(response *SearchRulesResponse, responseErr error) bool {
			return responseErr != nil || (response != nil && response.NbHits < hitsPerPage)
		}
	}

	return utils.CreateIterable( //nolint:wrapcheck
		func(previousResponse *SearchRulesResponse, previousErr error) (*SearchRulesResponse, error) {
			searchRulesParams.HitsPerPage = &hitsPerPage

			if previousResponse != nil {
				searchRulesParams.Page = utils.ToPtr(previousResponse.Page + 1)
			}

			if searchRulesParams.Page == nil {
				searchRulesParams.Page = utils.ToPtr(int32(0))
			}

			return c.SearchRulesWithContext(
				ctx,
				c.NewApiSearchRulesRequest(indexName).WithSearchRulesParams(&searchRulesParams),
				opts...,
			)
		},
		validate,
		aggregator,
		nil,
		nil,
	)
}

/*
BrowseSynonyms allows to aggregate all the synonyms returned by the API calls.
Wraps BrowseSynonymsWithContext using context.Background.

	@param indexName string - Index name.
	@param searchSynonymsParams SearchSynonymsParams - Search synonyms parameters.
	@param validate func(*SearchSynonymsResponse, error) bool - Validator function.
	@param aggregator func(*SearchSynonymsResponse) - Aggregator function.
	@param opts ...Option - Optional parameters for the request.
	@return *SearchSynonymsResponse - Search synonyms response.
	@return error - Error if any.
*/
func (c *APIClient) BrowseSynonyms(
	indexName string,
	searchSynonymsParams SearchSynonymsParams,
	validate func(*SearchSynonymsResponse, error) bool,
	aggregator func(*SearchSynonymsResponse, error),
	opts ...Option,
) (*SearchSynonymsResponse, error) {
	return c.BrowseSynonymsWithContext(context.Background(), indexName, searchSynonymsParams, validate, aggregator, opts...)
}

/*
BrowseSynonymsWithContext allows to aggregate all the synonyms returned by the API calls.

	@param ctx context.Context - The context that will be drilled down to the actual request.
	@param indexName string - Index name.
	@param searchSynonymsParams SearchSynonymsParams - Search synonyms parameters.
	@param validate func(*SearchSynonymsResponse, error) bool - Validator function.
	@param aggregator func(*SearchSynonymsResponse) - Aggregator function.
	@param opts ...Option - Optional parameters for the request.
	@return *SearchSynonymsResponse - Search synonyms response.
	@return error - Error if any.
*/
func (c *APIClient) BrowseSynonymsWithContext(
	ctx context.Context,
	indexName string,
	searchSynonymsParams SearchSynonymsParams,
	validate func(*SearchSynonymsResponse, error) bool,
	aggregator func(*SearchSynonymsResponse, error),
	opts ...Option,
) (*SearchSynonymsResponse, error) {
	hitsPerPage := int32(1000)
	if searchSynonymsParams.HitsPerPage != nil {
		hitsPerPage = *searchSynonymsParams.HitsPerPage
	}

	if searchSynonymsParams.Page == nil {
		searchSynonymsParams.Page = utils.ToPtr(int32(0))
	}

	if validate == nil {
		validate = func(response *SearchSynonymsResponse, responseErr error) bool {
			return responseErr != nil || (response != nil && response.NbHits < hitsPerPage)
		}
	}

	return utils.CreateIterable( //nolint:wrapcheck
		func(previousResponse *SearchSynonymsResponse, previousErr error) (*SearchSynonymsResponse, error) {
			searchSynonymsParams.HitsPerPage = &hitsPerPage

			defer func() {
				searchSynonymsParams.Page = utils.ToPtr(*searchSynonymsParams.Page + 1)
			}()

			return c.SearchSynonymsWithContext(
				ctx,
				c.NewApiSearchSynonymsRequest(indexName).WithSearchSynonymsParams(&searchSynonymsParams),
				opts...,
			)
		},
		validate,
		aggregator,
		nil,
		nil,
	)
}

func encodeRestrictions(restrictions *SecuredApiKeyRestrictions) (string, error) {
	if restrictions == nil {
		return "", nil
	}

	toSerialize := map[string]any{}
	if restrictions.Filters != nil {
		toSerialize["filters"] = *restrictions.Filters
	}
	if restrictions.ValidUntil != nil {
		toSerialize["validUntil"] = *restrictions.ValidUntil
	}
	if restrictions.RestrictIndices != nil {
		toSerialize["restrictIndices"] = restrictions.RestrictIndices
	}
	if restrictions.RestrictSources != nil {
		toSerialize["restrictSources"] = *restrictions.RestrictSources
	}
	if restrictions.UserToken != nil {
		toSerialize["userToken"] = *restrictions.UserToken
	}
	if restrictions.SearchParams != nil {
		// merge with searchParams
		serializedParams, err := restrictions.SearchParams.MarshalJSON()
		if err != nil {
			return "", fmt.Errorf("failed to marshal SearchParams: %w", err)
		}
		err = json.Unmarshal(serializedParams, &toSerialize)
		if err != nil {
			return "", fmt.Errorf("failed to unmarshal SearchParams: %w", err)
		}
	}

	// sort the keys to ensure consistent encoding
	keys := make([]string, 0, len(toSerialize))
	for k := range toSerialize {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	queryString := make([]string, 0, len(toSerialize))
	for _, k := range keys {
		queryString = append(queryString, k+"="+queryParameterToString(toSerialize[k]))
	}

	return strings.Join(queryString, "&"), nil
}

// GenerateSecuredApiKey generates a public API key intended to restrict access
// to certain records. This new key is built upon the existing key named
// `parentApiKey` and the following options.
func (c *APIClient) GenerateSecuredApiKey(parentApiKey string, restrictions *SecuredApiKeyRestrictions) (string, error) {
	h := hmac.New(sha256.New, []byte(parentApiKey))

	message, err := encodeRestrictions(restrictions)
	if err != nil {
		return "", err
	}
	_, err = h.Write([]byte(message))
	if err != nil {
		return "", fmt.Errorf("failed to compute HMAC: %w", err)
	}

	checksum := hex.EncodeToString(h.Sum(nil))
	key := base64.StdEncoding.EncodeToString([]byte(checksum + message))

	return key, nil
}

// GetSecuredApiKeyRemainingValidity retrieves the remaining validity of the previously generated `securedApiKey`, the `ValidUntil` parameter must have been provided.
func (c *APIClient) GetSecuredApiKeyRemainingValidity(securedApiKey string) (time.Duration, error) {
	if len(securedApiKey) == 0 {
		return 0, fmt.Errorf("given secured API key is empty: %s", securedApiKey)
	}

	decoded, err := base64.StdEncoding.DecodeString(securedApiKey)
	if err != nil {
		return 0, fmt.Errorf("unable to decode given secured API key: %s", err)
	}

	submatch := regexp.MustCompile(`validUntil=(\d{1,10})`).FindSubmatch(decoded)

	if len(submatch) != 2 {
		return 0, fmt.Errorf("unable to find `validUntil` parameter in the given secured API key: %s", string(decoded))
	}

	ts, err := strconv.Atoi(string(submatch[1]))
	if err != nil {
		return 0, fmt.Errorf("invalid format for the received `validUntil` value: %s", string(submatch[1]))
	}

	return time.Until(time.Unix(int64(ts), 0)), nil
}

// ChunkedBatch chunks the given `objects` list in subset of 1000 elements max in order to make it fit in `batch` requests.
func (c *APIClient) ChunkedBatch(indexName string, objects []map[string]any, action *Action, waitForTasks *bool, batchSize *int) ([]BatchResponse, error) {
	var (
		defaultBatchSize   = 1000
		defaultAction      = ACTION_ADD_OBJECT
		defaultWaitForTask = false
	)

	if batchSize == nil {
		batchSize = &defaultBatchSize
	}

	if action == nil {
		action = &defaultAction
	}

	if waitForTasks == nil {
		waitForTasks = &defaultWaitForTask
	}

	requests := make([]BatchRequest, 0, len(objects)%1000)
	responses := make([]BatchResponse, 0, len(objects)%1000)

	for i, obj := range objects {
		requests = append(requests, *NewBatchRequest(*action, obj))

		if len(requests) == *batchSize || i == len(objects)-1 {
			resp, err := c.Batch(c.NewApiBatchRequest(indexName, NewBatchWriteParams(requests)))
			if err != nil {
				return nil, err
			}

			responses = append(responses, *resp)
			requests = make([]BatchRequest, 0, len(objects)%1000)
		}
	}

	if *waitForTasks {
		for _, resp := range responses {
			_, err := c.WaitForTask(indexName, resp.TaskID, nil, nil)
			if err != nil {
				return nil, err
			}
		}
	}

	return responses, nil
}

// ReplaceAllObjects replaces all objects (records) in the given `indexName` with the given `objects`. A temporary index is created during this process in order to backup your data.
// See https://api-clients-automation.netlify.app/docs/contributing/add-new-api-client#5-helpers for implementation details.
func (c *APIClient) ReplaceAllObjects(indexName string, objects []map[string]any, batchSize *int) (*ReplaceAllObjectsResponse, error) {
	tmpIndexName := fmt.Sprintf("%s_tmp_%d", indexName, time.Now().UnixNano())

	copyResp, err := c.OperationIndex(c.NewApiOperationIndexRequest(indexName, NewOperationIndexParams(OPERATION_TYPE_COPY, tmpIndexName, WithOperationIndexParamsScope([]ScopeType{SCOPE_TYPE_RULES, SCOPE_TYPE_SETTINGS, SCOPE_TYPE_SYNONYMS}))))
	if err != nil {
		return nil, err
	}

	waitForTask := true

	batchResp, err := c.ChunkedBatch(tmpIndexName, objects, nil, &waitForTask, batchSize)
	if err != nil {
		return nil, err
	}

	_, err = c.WaitForTask(tmpIndexName, copyResp.TaskID, nil, nil)
	if err != nil {
		return nil, err
	}

	copyResp, err = c.OperationIndex(c.NewApiOperationIndexRequest(indexName, NewOperationIndexParams(OPERATION_TYPE_COPY, tmpIndexName, WithOperationIndexParamsScope([]ScopeType{SCOPE_TYPE_RULES, SCOPE_TYPE_SETTINGS, SCOPE_TYPE_SYNONYMS}))))
	if err != nil {
		return nil, err
	}

	_, err = c.WaitForTask(tmpIndexName, copyResp.TaskID, nil, nil)
	if err != nil {
		return nil, err
	}

	moveResp, err := c.OperationIndex(c.NewApiOperationIndexRequest(tmpIndexName, NewOperationIndexParams(OPERATION_TYPE_MOVE, indexName)))
	if err != nil {
		return nil, err
	}

	_, err = c.WaitForTask(tmpIndexName, moveResp.TaskID, nil, nil)
	if err != nil {
		return nil, err
	}

	return &ReplaceAllObjectsResponse{
		CopyOperationResponse: *copyResp,
		BatchResponses:        batchResp,
		MoveOperationResponse: *moveResp,
	}, nil
}
