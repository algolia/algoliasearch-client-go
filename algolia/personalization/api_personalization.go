// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package personalization

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type Option struct {
	Type  string
	Name  string
	Value string
}

func WithPage(page int32) Option {
	return Option{
		Type:  "query",
		Name:  "page",
		Value: parameterToString(page),
	}
}

func WithItemsPerPage(itemsPerPage int32) Option {
	return Option{
		Type:  "query",
		Name:  "itemsPerPage",
		Value: parameterToString(itemsPerPage),
	}
}

func WithBody(body any) Option {
	return Option{
		Type:  "body",
		Name:  "body",
		Value: parameterToString(body),
	}
}

// @return map[string]interface{}
func (c *APIClient) Del(path string, opts ...Option) (map[string]interface{}, error) {
	var (
		localVarPostBody any

		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params
	for _, opt := range opts {
		switch opt.Type {
		case "query":
			queryParams.Add(opt.Name, opt.Value)
		case "header":
			headers[opt.Name] = opt.Value
		}
	}
	req, err := c.prepareRequest(context.Background(), requestPath, http.MethodDelete, localVarPostBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// @return DeleteUserProfileResponse
func (c *APIClient) DeleteUserProfile(userToken string) (*DeleteUserProfileResponse, error) {
	var (
		localVarPostBody any

		returnValue *DeleteUserProfileResponse
	)

	requestPath := "/1/profiles/{userToken}"
	requestPath = strings.Replace(requestPath, "{"+"userToken"+"}", url.PathEscape(parameterToString(userToken)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), requestPath, http.MethodDelete, localVarPostBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// @return map[string]interface{}
func (c *APIClient) Get(path string, opts ...Option) (map[string]interface{}, error) {
	var (
		localVarPostBody any

		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params
	for _, opt := range opts {
		switch opt.Type {
		case "query":
			queryParams.Add(opt.Name, opt.Value)
		case "header":
			headers[opt.Name] = opt.Value
		}
	}
	req, err := c.prepareRequest(context.Background(), requestPath, http.MethodGet, localVarPostBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// @return PersonalizationStrategyParams
func (c *APIClient) GetPersonalizationStrategy() (*PersonalizationStrategyParams, error) {
	var (
		localVarPostBody any

		returnValue *PersonalizationStrategyParams
	)

	requestPath := "/1/strategies/personalization"

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), requestPath, http.MethodGet, localVarPostBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// @return GetUserTokenResponse
func (c *APIClient) GetUserTokenProfile(userToken string) (*GetUserTokenResponse, error) {
	var (
		localVarPostBody any

		returnValue *GetUserTokenResponse
	)

	requestPath := "/1/profiles/personalization/{userToken}"
	requestPath = strings.Replace(requestPath, "{"+"userToken"+"}", url.PathEscape(parameterToString(userToken)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	req, err := c.prepareRequest(context.Background(), requestPath, http.MethodGet, localVarPostBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// @return map[string]interface{}
func (c *APIClient) Post(path string, opts ...Option) (map[string]interface{}, error) {
	var (
		localVarPostBody any
		body             any
		returnValue      map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params
	for _, opt := range opts {
		switch opt.Type {
		case "query":
			queryParams.Add(opt.Name, opt.Value)
		case "header":
			headers[opt.Name] = opt.Value
		case "body":
			body = opt.Value
		}
	}
	// body params
	if body != nil {
		localVarPostBody = body
	} else {
		localVarPostBody = body
	}
	req, err := c.prepareRequest(context.Background(), requestPath, http.MethodPost, localVarPostBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// @return map[string]interface{}
func (c *APIClient) Put(path string, opts ...Option) (map[string]interface{}, error) {
	var (
		localVarPostBody any
		body             any
		returnValue      map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params
	for _, opt := range opts {
		switch opt.Type {
		case "query":
			queryParams.Add(opt.Name, opt.Value)
		case "header":
			headers[opt.Name] = opt.Value
		case "body":
			body = opt.Value
		}
	}
	// body params
	if body != nil {
		localVarPostBody = body
	} else {
		localVarPostBody = body
	}
	req, err := c.prepareRequest(context.Background(), requestPath, http.MethodPut, localVarPostBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// @return SetPersonalizationStrategyResponse
func (c *APIClient) SetPersonalizationStrategy(personalizationStrategyParams *PersonalizationStrategyParams) (*SetPersonalizationStrategyResponse, error) {
	var (
		localVarPostBody any
		body             any
		returnValue      *SetPersonalizationStrategyResponse
	)

	requestPath := "/1/strategies/personalization"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if personalizationStrategyParams == nil {
		return returnValue, reportError("personalizationStrategyParams is required and must be specified")
	}

	// body params
	if personalizationStrategyParams != nil {
		localVarPostBody = personalizationStrategyParams
	} else {
		localVarPostBody = body
	}
	req, err := c.prepareRequest(context.Background(), requestPath, http.MethodPost, localVarPostBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
