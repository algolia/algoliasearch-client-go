// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package predict

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/call"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       name,
		value:      parameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

func (r *ApiActivateModelInstanceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["activateModelParams"]; ok {
		err = json.Unmarshal(v, &r.activateModelParams)
		if err != nil {
			err = json.Unmarshal(b, &r.activateModelParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.activateModelParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiActivateModelInstanceRequest represents the request with all the parameters for the API call.
type ApiActivateModelInstanceRequest struct {
	activateModelParams *ActivateModelParams
}

// NewApiActivateModelInstanceRequest creates an instance of the ApiActivateModelInstanceRequest to be used for the API call.
func (c *APIClient) NewApiActivateModelInstanceRequest(activateModelParams *ActivateModelParams) ApiActivateModelInstanceRequest {
	return ApiActivateModelInstanceRequest{
		activateModelParams: activateModelParams,
	}
}

/*
ActivateModelInstance Activate a model instance. Wraps ActivateModelInstanceWithContext using context.Background.

Activate an existing model template. This action triggers the training and inference pipelines for the selected model.  The model is added with `modelStatus=pending`. If a model with the exact same source & index already exists, the API endpoint returns an error.

Request can be constructed by NewApiActivateModelInstanceRequest with parameters below.

	@param activateModelParams ActivateModelParams
	@return ActivateModelInstanceResponse
*/
func (c *APIClient) ActivateModelInstance(r ApiActivateModelInstanceRequest, opts ...Option) (*ActivateModelInstanceResponse, error) {
	return c.ActivateModelInstanceWithContext(context.Background(), r, opts...)
}

/*
ActivateModelInstance Activate a model instance.

Activate an existing model template. This action triggers the training and inference pipelines for the selected model.  The model is added with `modelStatus=pending`. If a model with the exact same source & index already exists, the API endpoint returns an error.

Request can be constructed by NewApiActivateModelInstanceRequest with parameters below.

	@param activateModelParams ActivateModelParams
	@return ActivateModelInstanceResponse
*/
func (c *APIClient) ActivateModelInstanceWithContext(ctx context.Context, r ApiActivateModelInstanceRequest, opts ...Option) (*ActivateModelInstanceResponse, error) {
	var (
		postBody    any
		returnValue *ActivateModelInstanceResponse
	)

	requestPath := "/1/predict/models"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.activateModelParams == nil {
		return returnValue, reportError("activateModelParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.activateModelParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateSegmentRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["createSegmentParams"]; ok {
		err = json.Unmarshal(v, &r.createSegmentParams)
		if err != nil {
			err = json.Unmarshal(b, &r.createSegmentParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.createSegmentParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiCreateSegmentRequest represents the request with all the parameters for the API call.
type ApiCreateSegmentRequest struct {
	createSegmentParams *CreateSegmentParams
}

// NewApiCreateSegmentRequest creates an instance of the ApiCreateSegmentRequest to be used for the API call.
func (c *APIClient) NewApiCreateSegmentRequest(createSegmentParams *CreateSegmentParams) ApiCreateSegmentRequest {
	return ApiCreateSegmentRequest{
		createSegmentParams: createSegmentParams,
	}
}

/*
CreateSegment Create a segment. Wraps CreateSegmentWithContext using context.Background.

Create a new segment. All segments added by this endpoint will have a computed type. The endpoint receives a filters parameter, with a syntax similar to filters for Rules.

Request can be constructed by NewApiCreateSegmentRequest with parameters below.

	@param createSegmentParams CreateSegmentParams
	@return CreateSegmentResponse
*/
func (c *APIClient) CreateSegment(r ApiCreateSegmentRequest, opts ...Option) (*CreateSegmentResponse, error) {
	return c.CreateSegmentWithContext(context.Background(), r, opts...)
}

/*
CreateSegment Create a segment.

Create a new segment. All segments added by this endpoint will have a computed type. The endpoint receives a filters parameter, with a syntax similar to filters for Rules.

Request can be constructed by NewApiCreateSegmentRequest with parameters below.

	@param createSegmentParams CreateSegmentParams
	@return CreateSegmentResponse
*/
func (c *APIClient) CreateSegmentWithContext(ctx context.Context, r ApiCreateSegmentRequest, opts ...Option) (*CreateSegmentResponse, error) {
	var (
		postBody    any
		returnValue *CreateSegmentResponse
	)

	requestPath := "/1/segments"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.createSegmentParams == nil {
		return returnValue, reportError("createSegmentParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.createSegmentParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDelRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDelRequest represents the request with all the parameters for the API call.
type ApiDelRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiDelRequest creates an instance of the ApiDelRequest to be used for the API call.
func (c *APIClient) NewApiDelRequest(path string) ApiDelRequest {
	return ApiDelRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiDelRequest and returns the request for chaining.
func (r ApiDelRequest) WithParameters(parameters map[string]interface{}) ApiDelRequest {
	r.parameters = parameters
	return r
}

/*
Del Send requests to the Algolia REST API. Wraps DelWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiDelRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) Del(r ApiDelRequest, opts ...Option) (map[string]interface{}, error) {
	return c.DelWithContext(context.Background(), r, opts...)
}

/*
Del Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiDelRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) DelWithContext(ctx context.Context, r ApiDelRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteModelInstanceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["modelID"]; ok {
		err = json.Unmarshal(v, &r.modelID)
		if err != nil {
			err = json.Unmarshal(b, &r.modelID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteModelInstanceRequest represents the request with all the parameters for the API call.
type ApiDeleteModelInstanceRequest struct {
	modelID string
}

// NewApiDeleteModelInstanceRequest creates an instance of the ApiDeleteModelInstanceRequest to be used for the API call.
func (c *APIClient) NewApiDeleteModelInstanceRequest(modelID string) ApiDeleteModelInstanceRequest {
	return ApiDeleteModelInstanceRequest{
		modelID: modelID,
	}
}

/*
DeleteModelInstance Delete a model instance. Wraps DeleteModelInstanceWithContext using context.Background.

Delete the model’s configuration, pipelines and generated predictions.

Request can be constructed by NewApiDeleteModelInstanceRequest with parameters below.

	@param modelID string - The ID of the model to retrieve.
	@return DeleteModelInstanceResponse
*/
func (c *APIClient) DeleteModelInstance(r ApiDeleteModelInstanceRequest, opts ...Option) (*DeleteModelInstanceResponse, error) {
	return c.DeleteModelInstanceWithContext(context.Background(), r, opts...)
}

/*
DeleteModelInstance Delete a model instance.

Delete the model’s configuration, pipelines and generated predictions.

Request can be constructed by NewApiDeleteModelInstanceRequest with parameters below.

	@param modelID string - The ID of the model to retrieve.
	@return DeleteModelInstanceResponse
*/
func (c *APIClient) DeleteModelInstanceWithContext(ctx context.Context, r ApiDeleteModelInstanceRequest, opts ...Option) (*DeleteModelInstanceResponse, error) {
	var (
		postBody    any
		returnValue *DeleteModelInstanceResponse
	)

	requestPath := "/1/predict/models/{modelID}"
	requestPath = strings.Replace(requestPath, "{"+"modelID"+"}", url.PathEscape(parameterToString(r.modelID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteSegmentRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["segmentID"]; ok {
		err = json.Unmarshal(v, &r.segmentID)
		if err != nil {
			err = json.Unmarshal(b, &r.segmentID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteSegmentRequest represents the request with all the parameters for the API call.
type ApiDeleteSegmentRequest struct {
	segmentID string
}

// NewApiDeleteSegmentRequest creates an instance of the ApiDeleteSegmentRequest to be used for the API call.
func (c *APIClient) NewApiDeleteSegmentRequest(segmentID string) ApiDeleteSegmentRequest {
	return ApiDeleteSegmentRequest{
		segmentID: segmentID,
	}
}

/*
DeleteSegment Delete a segment's configuration. Wraps DeleteSegmentWithContext using context.Background.

Delete the segment’s configuration. User intents (predictions) from the segment are not deleted. All segment types (computed or custom) can be deleted.

When the query is successful, the HTTP response is 200 OK and returns the date until which you can safely consider the data as being deleted.

Request can be constructed by NewApiDeleteSegmentRequest with parameters below.

	@param segmentID string - The ID of the Segment to fetch.
	@return DeleteSegmentResponse
*/
func (c *APIClient) DeleteSegment(r ApiDeleteSegmentRequest, opts ...Option) (*DeleteSegmentResponse, error) {
	return c.DeleteSegmentWithContext(context.Background(), r, opts...)
}

/*
DeleteSegment Delete a segment's configuration.

Delete the segment’s configuration. User intents (predictions) from the segment are not deleted. All segment types (computed or custom) can be deleted.

When the query is successful, the HTTP response is 200 OK and returns the date until which you can safely consider the data as being deleted.

Request can be constructed by NewApiDeleteSegmentRequest with parameters below.

	@param segmentID string - The ID of the Segment to fetch.
	@return DeleteSegmentResponse
*/
func (c *APIClient) DeleteSegmentWithContext(ctx context.Context, r ApiDeleteSegmentRequest, opts ...Option) (*DeleteSegmentResponse, error) {
	var (
		postBody    any
		returnValue *DeleteSegmentResponse
	)

	requestPath := "/1/segments/{segmentID}"
	requestPath = strings.Replace(requestPath, "{"+"segmentID"+"}", url.PathEscape(parameterToString(r.segmentID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteUserProfileRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["userID"]; ok {
		err = json.Unmarshal(v, &r.userID)
		if err != nil {
			err = json.Unmarshal(b, &r.userID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteUserProfileRequest represents the request with all the parameters for the API call.
type ApiDeleteUserProfileRequest struct {
	userID string
}

// NewApiDeleteUserProfileRequest creates an instance of the ApiDeleteUserProfileRequest to be used for the API call.
func (c *APIClient) NewApiDeleteUserProfileRequest(userID string) ApiDeleteUserProfileRequest {
	return ApiDeleteUserProfileRequest{
		userID: userID,
	}
}

/*
DeleteUserProfile Delete user profile. Wraps DeleteUserProfileWithContext using context.Background.

Delete all data and predictions associated with an authenticated user (userID) or an anonymous user (cookieID, sessionID).

Request can be constructed by NewApiDeleteUserProfileRequest with parameters below.

	@param userID string - User ID for authenticated users or cookie ID for non-authenticated repeated users (visitors).
	@return DeleteUserProfileResponse
*/
func (c *APIClient) DeleteUserProfile(r ApiDeleteUserProfileRequest, opts ...Option) (*DeleteUserProfileResponse, error) {
	return c.DeleteUserProfileWithContext(context.Background(), r, opts...)
}

/*
DeleteUserProfile Delete user profile.

Delete all data and predictions associated with an authenticated user (userID) or an anonymous user (cookieID, sessionID).

Request can be constructed by NewApiDeleteUserProfileRequest with parameters below.

	@param userID string - User ID for authenticated users or cookie ID for non-authenticated repeated users (visitors).
	@return DeleteUserProfileResponse
*/
func (c *APIClient) DeleteUserProfileWithContext(ctx context.Context, r ApiDeleteUserProfileRequest, opts ...Option) (*DeleteUserProfileResponse, error) {
	var (
		postBody    any
		returnValue *DeleteUserProfileResponse
	)

	requestPath := "/1/users/{userID}"
	requestPath = strings.Replace(requestPath, "{"+"userID"+"}", url.PathEscape(parameterToString(r.userID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiFetchAllSegmentsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiFetchAllSegmentsRequest represents the request with all the parameters for the API call.
type ApiFetchAllSegmentsRequest struct {
	type_ *SegmentType
}

// NewApiFetchAllSegmentsRequest creates an instance of the ApiFetchAllSegmentsRequest to be used for the API call.
func (c *APIClient) NewApiFetchAllSegmentsRequest() ApiFetchAllSegmentsRequest {
	return ApiFetchAllSegmentsRequest{}
}

// WithType_ adds the type_ to the ApiFetchAllSegmentsRequest and returns the request for chaining.
func (r ApiFetchAllSegmentsRequest) WithType_(type_ *SegmentType) ApiFetchAllSegmentsRequest {
	r.type_ = type_
	return r
}

/*
FetchAllSegments Get all segments. Wraps FetchAllSegmentsWithContext using context.Background.

Get the list of segments with their configuration.

Request can be constructed by NewApiFetchAllSegmentsRequest with parameters below.

	@param type_ SegmentType - The type of segments to fetch.
	@return []Segment
*/
func (c *APIClient) FetchAllSegments(r ApiFetchAllSegmentsRequest, opts ...Option) ([]Segment, error) {
	return c.FetchAllSegmentsWithContext(context.Background(), r, opts...)
}

/*
FetchAllSegments Get all segments.

Get the list of segments with their configuration.

Request can be constructed by NewApiFetchAllSegmentsRequest with parameters below.

	@param type_ SegmentType - The type of segments to fetch.
	@return []Segment
*/
func (c *APIClient) FetchAllSegmentsWithContext(ctx context.Context, r ApiFetchAllSegmentsRequest, opts ...Option) ([]Segment, error) {
	var (
		postBody    any
		returnValue []Segment
	)

	requestPath := "/1/segments"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.type_) {
		queryParams.Set("type", parameterToString(*r.type_))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiFetchAllUserProfilesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["fetchAllUserProfilesParams"]; ok {
		err = json.Unmarshal(v, &r.fetchAllUserProfilesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.fetchAllUserProfilesParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.fetchAllUserProfilesParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiFetchAllUserProfilesRequest represents the request with all the parameters for the API call.
type ApiFetchAllUserProfilesRequest struct {
	fetchAllUserProfilesParams *FetchAllUserProfilesParams
}

// NewApiFetchAllUserProfilesRequest creates an instance of the ApiFetchAllUserProfilesRequest to be used for the API call.
func (c *APIClient) NewApiFetchAllUserProfilesRequest(fetchAllUserProfilesParams *FetchAllUserProfilesParams) ApiFetchAllUserProfilesRequest {
	return ApiFetchAllUserProfilesRequest{
		fetchAllUserProfilesParams: fetchAllUserProfilesParams,
	}
}

/*
FetchAllUserProfiles Get all user profiles. Wraps FetchAllUserProfilesWithContext using context.Background.

Get all users with predictions in the provided application.

Request can be constructed by NewApiFetchAllUserProfilesRequest with parameters below.

	@param fetchAllUserProfilesParams FetchAllUserProfilesParams
	@return FetchAllUserProfilesResponse
*/
func (c *APIClient) FetchAllUserProfiles(r ApiFetchAllUserProfilesRequest, opts ...Option) (*FetchAllUserProfilesResponse, error) {
	return c.FetchAllUserProfilesWithContext(context.Background(), r, opts...)
}

/*
FetchAllUserProfiles Get all user profiles.

Get all users with predictions in the provided application.

Request can be constructed by NewApiFetchAllUserProfilesRequest with parameters below.

	@param fetchAllUserProfilesParams FetchAllUserProfilesParams
	@return FetchAllUserProfilesResponse
*/
func (c *APIClient) FetchAllUserProfilesWithContext(ctx context.Context, r ApiFetchAllUserProfilesRequest, opts ...Option) (*FetchAllUserProfilesResponse, error) {
	var (
		postBody    any
		returnValue *FetchAllUserProfilesResponse
	)

	requestPath := "/1/users"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.fetchAllUserProfilesParams == nil {
		return returnValue, reportError("fetchAllUserProfilesParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.fetchAllUserProfilesParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiFetchSegmentRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["segmentID"]; ok {
		err = json.Unmarshal(v, &r.segmentID)
		if err != nil {
			err = json.Unmarshal(b, &r.segmentID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiFetchSegmentRequest represents the request with all the parameters for the API call.
type ApiFetchSegmentRequest struct {
	segmentID string
}

// NewApiFetchSegmentRequest creates an instance of the ApiFetchSegmentRequest to be used for the API call.
func (c *APIClient) NewApiFetchSegmentRequest(segmentID string) ApiFetchSegmentRequest {
	return ApiFetchSegmentRequest{
		segmentID: segmentID,
	}
}

/*
FetchSegment Get the segment configuration. Wraps FetchSegmentWithContext using context.Background.

Get the segment configuration.

Request can be constructed by NewApiFetchSegmentRequest with parameters below.

	@param segmentID string - The ID of the Segment to fetch.
	@return Segment
*/
func (c *APIClient) FetchSegment(r ApiFetchSegmentRequest, opts ...Option) (*Segment, error) {
	return c.FetchSegmentWithContext(context.Background(), r, opts...)
}

/*
FetchSegment Get the segment configuration.

Get the segment configuration.

Request can be constructed by NewApiFetchSegmentRequest with parameters below.

	@param segmentID string - The ID of the Segment to fetch.
	@return Segment
*/
func (c *APIClient) FetchSegmentWithContext(ctx context.Context, r ApiFetchSegmentRequest, opts ...Option) (*Segment, error) {
	var (
		postBody    any
		returnValue *Segment
	)

	requestPath := "/1/segments/{segmentID}"
	requestPath = strings.Replace(requestPath, "{"+"segmentID"+"}", url.PathEscape(parameterToString(r.segmentID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiFetchUserProfileRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["userID"]; ok {
		err = json.Unmarshal(v, &r.userID)
		if err != nil {
			err = json.Unmarshal(b, &r.userID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["params"]; ok {
		err = json.Unmarshal(v, &r.params)
		if err != nil {
			err = json.Unmarshal(b, &r.params)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.params)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiFetchUserProfileRequest represents the request with all the parameters for the API call.
type ApiFetchUserProfileRequest struct {
	userID string
	params *Params
}

// NewApiFetchUserProfileRequest creates an instance of the ApiFetchUserProfileRequest to be used for the API call.
func (c *APIClient) NewApiFetchUserProfileRequest(userID string, params *Params) ApiFetchUserProfileRequest {
	return ApiFetchUserProfileRequest{
		userID: userID,
		params: params,
	}
}

/*
FetchUserProfile Get user profile. Wraps FetchUserProfileWithContext using context.Background.

Get predictions, properties (raw, computed or custom) and segments (computed or custom) for a user profile.

Request can be constructed by NewApiFetchUserProfileRequest with parameters below.

	@param userID string - User ID for authenticated users or cookie ID for non-authenticated repeated users (visitors).
	@param params Params
	@return UserProfile
*/
func (c *APIClient) FetchUserProfile(r ApiFetchUserProfileRequest, opts ...Option) (*UserProfile, error) {
	return c.FetchUserProfileWithContext(context.Background(), r, opts...)
}

/*
FetchUserProfile Get user profile.

Get predictions, properties (raw, computed or custom) and segments (computed or custom) for a user profile.

Request can be constructed by NewApiFetchUserProfileRequest with parameters below.

	@param userID string - User ID for authenticated users or cookie ID for non-authenticated repeated users (visitors).
	@param params Params
	@return UserProfile
*/
func (c *APIClient) FetchUserProfileWithContext(ctx context.Context, r ApiFetchUserProfileRequest, opts ...Option) (*UserProfile, error) {
	var (
		postBody    any
		returnValue *UserProfile
	)

	requestPath := "/1/users/{userID}/fetch"
	requestPath = strings.Replace(requestPath, "{"+"userID"+"}", url.PathEscape(parameterToString(r.userID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.params == nil {
		return returnValue, reportError("params is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.params
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 405 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetRequest represents the request with all the parameters for the API call.
type ApiGetRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiGetRequest creates an instance of the ApiGetRequest to be used for the API call.
func (c *APIClient) NewApiGetRequest(path string) ApiGetRequest {
	return ApiGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiGetRequest and returns the request for chaining.
func (r ApiGetRequest) WithParameters(parameters map[string]interface{}) ApiGetRequest {
	r.parameters = parameters
	return r
}

/*
Get Send requests to the Algolia REST API. Wraps GetWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiGetRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) Get(r ApiGetRequest, opts ...Option) (map[string]interface{}, error) {
	return c.GetWithContext(context.Background(), r, opts...)
}

/*
Get Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiGetRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) GetWithContext(ctx context.Context, r ApiGetRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetAvailableModelTypes Get a list of available model types. Wraps GetAvailableModelTypesWithContext using context.Background.

Get a list of all available model types. Each model type can be activated more than once, by selecting a different data source.

Request can be constructed by NewApiGetAvailableModelTypesRequest with parameters below.

	@return []GetAvailableModelTypesResponseInner
*/
func (c *APIClient) GetAvailableModelTypes(opts ...Option) ([]GetAvailableModelTypesResponseInner, error) {
	return c.GetAvailableModelTypesWithContext(context.Background(), opts...)
}

/*
GetAvailableModelTypes Get a list of available model types.

Get a list of all available model types. Each model type can be activated more than once, by selecting a different data source.

Request can be constructed by NewApiGetAvailableModelTypesRequest with parameters below.

	@return []GetAvailableModelTypesResponseInner
*/
func (c *APIClient) GetAvailableModelTypesWithContext(ctx context.Context, opts ...Option) ([]GetAvailableModelTypesResponseInner, error) {
	var (
		postBody    any
		returnValue []GetAvailableModelTypesResponseInner
	)

	requestPath := "/1/predict/modeltypes"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetModelInstanceConfigRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["modelID"]; ok {
		err = json.Unmarshal(v, &r.modelID)
		if err != nil {
			err = json.Unmarshal(b, &r.modelID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetModelInstanceConfigRequest represents the request with all the parameters for the API call.
type ApiGetModelInstanceConfigRequest struct {
	modelID string
}

// NewApiGetModelInstanceConfigRequest creates an instance of the ApiGetModelInstanceConfigRequest to be used for the API call.
func (c *APIClient) NewApiGetModelInstanceConfigRequest(modelID string) ApiGetModelInstanceConfigRequest {
	return ApiGetModelInstanceConfigRequest{
		modelID: modelID,
	}
}

/*
GetModelInstanceConfig Get a model’s instance configuration. Wraps GetModelInstanceConfigWithContext using context.Background.

Get the configuration for a model that was activated.

Request can be constructed by NewApiGetModelInstanceConfigRequest with parameters below.

	@param modelID string - The ID of the model to retrieve.
	@return ModelInstance
*/
func (c *APIClient) GetModelInstanceConfig(r ApiGetModelInstanceConfigRequest, opts ...Option) (*ModelInstance, error) {
	return c.GetModelInstanceConfigWithContext(context.Background(), r, opts...)
}

/*
GetModelInstanceConfig Get a model’s instance configuration.

Get the configuration for a model that was activated.

Request can be constructed by NewApiGetModelInstanceConfigRequest with parameters below.

	@param modelID string - The ID of the model to retrieve.
	@return ModelInstance
*/
func (c *APIClient) GetModelInstanceConfigWithContext(ctx context.Context, r ApiGetModelInstanceConfigRequest, opts ...Option) (*ModelInstance, error) {
	var (
		postBody    any
		returnValue *ModelInstance
	)

	requestPath := "/1/predict/models/{modelID}"
	requestPath = strings.Replace(requestPath, "{"+"modelID"+"}", url.PathEscape(parameterToString(r.modelID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetModelInstances Get model instances. Wraps GetModelInstancesWithContext using context.Background.

Get a list of all model instances.

Request can be constructed by NewApiGetModelInstancesRequest with parameters below.

	@return []ModelInstance
*/
func (c *APIClient) GetModelInstances(opts ...Option) ([]ModelInstance, error) {
	return c.GetModelInstancesWithContext(context.Background(), opts...)
}

/*
GetModelInstances Get model instances.

Get a list of all model instances.

Request can be constructed by NewApiGetModelInstancesRequest with parameters below.

	@return []ModelInstance
*/
func (c *APIClient) GetModelInstancesWithContext(ctx context.Context, opts ...Option) ([]ModelInstance, error) {
	var (
		postBody    any
		returnValue []ModelInstance
	)

	requestPath := "/1/predict/models"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetModelMetricsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["modelID"]; ok {
		err = json.Unmarshal(v, &r.modelID)
		if err != nil {
			err = json.Unmarshal(b, &r.modelID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetModelMetricsRequest represents the request with all the parameters for the API call.
type ApiGetModelMetricsRequest struct {
	modelID string
}

// NewApiGetModelMetricsRequest creates an instance of the ApiGetModelMetricsRequest to be used for the API call.
func (c *APIClient) NewApiGetModelMetricsRequest(modelID string) ApiGetModelMetricsRequest {
	return ApiGetModelMetricsRequest{
		modelID: modelID,
	}
}

/*
GetModelMetrics Get a model’s instance metrics. Wraps GetModelMetricsWithContext using context.Background.

Get the model instance’ training metrics.

Request can be constructed by NewApiGetModelMetricsRequest with parameters below.

	@param modelID string - The ID of the model to retrieve.
	@return GetModelMetricsResponse
*/
func (c *APIClient) GetModelMetrics(r ApiGetModelMetricsRequest, opts ...Option) (*GetModelMetricsResponse, error) {
	return c.GetModelMetricsWithContext(context.Background(), r, opts...)
}

/*
GetModelMetrics Get a model’s instance metrics.

Get the model instance’ training metrics.

Request can be constructed by NewApiGetModelMetricsRequest with parameters below.

	@param modelID string - The ID of the model to retrieve.
	@return GetModelMetricsResponse
*/
func (c *APIClient) GetModelMetricsWithContext(ctx context.Context, r ApiGetModelMetricsRequest, opts ...Option) (*GetModelMetricsResponse, error) {
	var (
		postBody    any
		returnValue *GetModelMetricsResponse
	)

	requestPath := "/1/predict/models/{modelID}/metrics"
	requestPath = strings.Replace(requestPath, "{"+"modelID"+"}", url.PathEscape(parameterToString(r.modelID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSegmentUsersRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["segmentID"]; ok {
		err = json.Unmarshal(v, &r.segmentID)
		if err != nil {
			err = json.Unmarshal(b, &r.segmentID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["fetchAllUserProfilesParams"]; ok {
		err = json.Unmarshal(v, &r.fetchAllUserProfilesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.fetchAllUserProfilesParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.fetchAllUserProfilesParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiGetSegmentUsersRequest represents the request with all the parameters for the API call.
type ApiGetSegmentUsersRequest struct {
	segmentID                  string
	fetchAllUserProfilesParams *FetchAllUserProfilesParams
}

// NewApiGetSegmentUsersRequest creates an instance of the ApiGetSegmentUsersRequest to be used for the API call.
func (c *APIClient) NewApiGetSegmentUsersRequest(segmentID string, fetchAllUserProfilesParams *FetchAllUserProfilesParams) ApiGetSegmentUsersRequest {
	return ApiGetSegmentUsersRequest{
		segmentID:                  segmentID,
		fetchAllUserProfilesParams: fetchAllUserProfilesParams,
	}
}

/*
GetSegmentUsers Get segment users. Wraps GetSegmentUsersWithContext using context.Background.

Get the profiles of users that belong to a segment.

Request can be constructed by NewApiGetSegmentUsersRequest with parameters below.

	@param segmentID string - The ID of the Segment to fetch.
	@param fetchAllUserProfilesParams FetchAllUserProfilesParams
	@return GetSegmentUsersResponse
*/
func (c *APIClient) GetSegmentUsers(r ApiGetSegmentUsersRequest, opts ...Option) (*GetSegmentUsersResponse, error) {
	return c.GetSegmentUsersWithContext(context.Background(), r, opts...)
}

/*
GetSegmentUsers Get segment users.

Get the profiles of users that belong to a segment.

Request can be constructed by NewApiGetSegmentUsersRequest with parameters below.

	@param segmentID string - The ID of the Segment to fetch.
	@param fetchAllUserProfilesParams FetchAllUserProfilesParams
	@return GetSegmentUsersResponse
*/
func (c *APIClient) GetSegmentUsersWithContext(ctx context.Context, r ApiGetSegmentUsersRequest, opts ...Option) (*GetSegmentUsersResponse, error) {
	var (
		postBody    any
		returnValue *GetSegmentUsersResponse
	)

	requestPath := "/1/segments/{segmentID}/users"
	requestPath = strings.Replace(requestPath, "{"+"segmentID"+"}", url.PathEscape(parameterToString(r.segmentID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.fetchAllUserProfilesParams == nil {
		return returnValue, reportError("fetchAllUserProfilesParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.fetchAllUserProfilesParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiPostRequest represents the request with all the parameters for the API call.
type ApiPostRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiPostRequest creates an instance of the ApiPostRequest to be used for the API call.
func (c *APIClient) NewApiPostRequest(path string) ApiPostRequest {
	return ApiPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiPostRequest and returns the request for chaining.
func (r ApiPostRequest) WithParameters(parameters map[string]interface{}) ApiPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiPostRequest and returns the request for chaining.
func (r ApiPostRequest) WithBody(body map[string]interface{}) ApiPostRequest {
	r.body = body
	return r
}

/*
Post Send requests to the Algolia REST API. Wraps PostWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPostRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@param body map[string]interface{} - The parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) Post(r ApiPostRequest, opts ...Option) (map[string]interface{}, error) {
	return c.PostWithContext(context.Background(), r, opts...)
}

/*
Post Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPostRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@param body map[string]interface{} - The parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) PostWithContext(ctx context.Context, r ApiPostRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiPutRequest represents the request with all the parameters for the API call.
type ApiPutRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiPutRequest creates an instance of the ApiPutRequest to be used for the API call.
func (c *APIClient) NewApiPutRequest(path string) ApiPutRequest {
	return ApiPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiPutRequest and returns the request for chaining.
func (r ApiPutRequest) WithParameters(parameters map[string]interface{}) ApiPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiPutRequest and returns the request for chaining.
func (r ApiPutRequest) WithBody(body map[string]interface{}) ApiPutRequest {
	r.body = body
	return r
}

/*
Put Send requests to the Algolia REST API. Wraps PutWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPutRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@param body map[string]interface{} - The parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) Put(r ApiPutRequest, opts ...Option) (map[string]interface{}, error) {
	return c.PutWithContext(context.Background(), r, opts...)
}

/*
Put Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPutRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@param body map[string]interface{} - The parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) PutWithContext(ctx context.Context, r ApiPutRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateModelInstanceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["modelID"]; ok {
		err = json.Unmarshal(v, &r.modelID)
		if err != nil {
			err = json.Unmarshal(b, &r.modelID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["updateModelParams"]; ok {
		err = json.Unmarshal(v, &r.updateModelParams)
		if err != nil {
			err = json.Unmarshal(b, &r.updateModelParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.updateModelParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiUpdateModelInstanceRequest represents the request with all the parameters for the API call.
type ApiUpdateModelInstanceRequest struct {
	modelID           string
	updateModelParams *UpdateModelParams
}

// NewApiUpdateModelInstanceRequest creates an instance of the ApiUpdateModelInstanceRequest to be used for the API call.
func (c *APIClient) NewApiUpdateModelInstanceRequest(modelID string, updateModelParams *UpdateModelParams) ApiUpdateModelInstanceRequest {
	return ApiUpdateModelInstanceRequest{
		modelID:           modelID,
		updateModelParams: updateModelParams,
	}
}

/*
UpdateModelInstance Update a model instance. Wraps UpdateModelInstanceWithContext using context.Background.

Update a model’s configuration.

Request can be constructed by NewApiUpdateModelInstanceRequest with parameters below.

	@param modelID string - The ID of the model to retrieve.
	@param updateModelParams UpdateModelParams
	@return UpdateModelInstanceResponse
*/
func (c *APIClient) UpdateModelInstance(r ApiUpdateModelInstanceRequest, opts ...Option) (*UpdateModelInstanceResponse, error) {
	return c.UpdateModelInstanceWithContext(context.Background(), r, opts...)
}

/*
UpdateModelInstance Update a model instance.

Update a model’s configuration.

Request can be constructed by NewApiUpdateModelInstanceRequest with parameters below.

	@param modelID string - The ID of the model to retrieve.
	@param updateModelParams UpdateModelParams
	@return UpdateModelInstanceResponse
*/
func (c *APIClient) UpdateModelInstanceWithContext(ctx context.Context, r ApiUpdateModelInstanceRequest, opts ...Option) (*UpdateModelInstanceResponse, error) {
	var (
		postBody    any
		returnValue *UpdateModelInstanceResponse
	)

	requestPath := "/1/predict/models/{modelID}"
	requestPath = strings.Replace(requestPath, "{"+"modelID"+"}", url.PathEscape(parameterToString(r.modelID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.updateModelParams == nil {
		return returnValue, reportError("updateModelParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.updateModelParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateSegmentRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["segmentID"]; ok {
		err = json.Unmarshal(v, &r.segmentID)
		if err != nil {
			err = json.Unmarshal(b, &r.segmentID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["updateSegmentParams"]; ok {
		err = json.Unmarshal(v, &r.updateSegmentParams)
		if err != nil {
			err = json.Unmarshal(b, &r.updateSegmentParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.updateSegmentParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiUpdateSegmentRequest represents the request with all the parameters for the API call.
type ApiUpdateSegmentRequest struct {
	segmentID           string
	updateSegmentParams *UpdateSegmentParams
}

// NewApiUpdateSegmentRequest creates an instance of the ApiUpdateSegmentRequest to be used for the API call.
func (c *APIClient) NewApiUpdateSegmentRequest(segmentID string, updateSegmentParams *UpdateSegmentParams) ApiUpdateSegmentRequest {
	return ApiUpdateSegmentRequest{
		segmentID:           segmentID,
		updateSegmentParams: updateSegmentParams,
	}
}

/*
UpdateSegment Update segment. Wraps UpdateSegmentWithContext using context.Background.

Update a segment’s configuration.

Request can be constructed by NewApiUpdateSegmentRequest with parameters below.

	@param segmentID string - The ID of the Segment to fetch.
	@param updateSegmentParams UpdateSegmentParams
	@return UpdateSegmentResponse
*/
func (c *APIClient) UpdateSegment(r ApiUpdateSegmentRequest, opts ...Option) (*UpdateSegmentResponse, error) {
	return c.UpdateSegmentWithContext(context.Background(), r, opts...)
}

/*
UpdateSegment Update segment.

Update a segment’s configuration.

Request can be constructed by NewApiUpdateSegmentRequest with parameters below.

	@param segmentID string - The ID of the Segment to fetch.
	@param updateSegmentParams UpdateSegmentParams
	@return UpdateSegmentResponse
*/
func (c *APIClient) UpdateSegmentWithContext(ctx context.Context, r ApiUpdateSegmentRequest, opts ...Option) (*UpdateSegmentResponse, error) {
	var (
		postBody    any
		returnValue *UpdateSegmentResponse
	)

	requestPath := "/1/segments/{segmentID}"
	requestPath = strings.Replace(requestPath, "{"+"segmentID"+"}", url.PathEscape(parameterToString(r.segmentID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.updateSegmentParams == nil {
		return returnValue, reportError("updateSegmentParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.updateSegmentParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
