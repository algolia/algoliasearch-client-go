// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package predict

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/call"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       name,
		value:      parameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

type ApiActivateModelInstanceRequest struct {
	activateModelParams *ActivateModelParams
}

func (r *ApiActivateModelInstanceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["activateModelParams"]; ok { //activateModelParams
		err = json.Unmarshal(v, &r.activateModelParams)
		if err != nil {
			err = json.Unmarshal(b, &r.activateModelParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.activateModelParams)
		if err != nil {
			return err
		}
	}

	return nil
}

func (r ApiActivateModelInstanceRequest) WithActivateModelParams(activateModelParams *ActivateModelParams) ApiActivateModelInstanceRequest {
	r.activateModelParams = activateModelParams
	return r
}

// @return ApiActivateModelInstanceRequest
func (c *APIClient) NewApiActivateModelInstanceRequest() ApiActivateModelInstanceRequest {
	return ApiActivateModelInstanceRequest{}
}

// ActivateModelInstance wraps ActivateModelInstanceWithContext using context.Background.
func (c *APIClient) ActivateModelInstance(r ApiActivateModelInstanceRequest, opts ...Option) (*ActivateModelInstanceResponse, error) {
	return c.ActivateModelInstanceWithContext(context.Background(), r, opts...)
}

// @return ActivateModelInstanceResponse
func (c *APIClient) ActivateModelInstanceWithContext(ctx context.Context, r ApiActivateModelInstanceRequest, opts ...Option) (*ActivateModelInstanceResponse, error) {
	var (
		postBody    any
		returnValue *ActivateModelInstanceResponse
	)

	requestPath := "/1/predict/models"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.activateModelParams == nil {
		return returnValue, reportError("activateModelParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.activateModelParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiCreateSegmentRequest struct {
	createSegmentParams *CreateSegmentParams
}

func (r *ApiCreateSegmentRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["createSegmentParams"]; ok { //createSegmentParams
		err = json.Unmarshal(v, &r.createSegmentParams)
		if err != nil {
			err = json.Unmarshal(b, &r.createSegmentParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.createSegmentParams)
		if err != nil {
			return err
		}
	}

	return nil
}

func (r ApiCreateSegmentRequest) WithCreateSegmentParams(createSegmentParams *CreateSegmentParams) ApiCreateSegmentRequest {
	r.createSegmentParams = createSegmentParams
	return r
}

// @return ApiCreateSegmentRequest
func (c *APIClient) NewApiCreateSegmentRequest() ApiCreateSegmentRequest {
	return ApiCreateSegmentRequest{}
}

// CreateSegment wraps CreateSegmentWithContext using context.Background.
func (c *APIClient) CreateSegment(r ApiCreateSegmentRequest, opts ...Option) (*CreateSegmentResponse, error) {
	return c.CreateSegmentWithContext(context.Background(), r, opts...)
}

// @return CreateSegmentResponse
func (c *APIClient) CreateSegmentWithContext(ctx context.Context, r ApiCreateSegmentRequest, opts ...Option) (*CreateSegmentResponse, error) {
	var (
		postBody    any
		returnValue *CreateSegmentResponse
	)

	requestPath := "/1/segments"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.createSegmentParams == nil {
		return returnValue, reportError("createSegmentParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.createSegmentParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiDelRequest struct {
	path       string
	parameters map[string]interface{}
}

func (r *ApiDelRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok { //path
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok { //parameters
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// Query parameters to be applied to the current query.
func (r ApiDelRequest) WithParameters(parameters map[string]interface{}) ApiDelRequest {
	r.parameters = parameters
	return r
}

// @return ApiDelRequest
func (c *APIClient) NewApiDelRequest(path string) ApiDelRequest {
	return ApiDelRequest{
		path: path,
	}
}

// Del wraps DelWithContext using context.Background.
func (c *APIClient) Del(r ApiDelRequest, opts ...Option) (map[string]interface{}, error) {
	return c.DelWithContext(context.Background(), r, opts...)
}

// @return map[string]interface{}
func (c *APIClient) DelWithContext(ctx context.Context, r ApiDelRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiDeleteModelInstanceRequest struct {
	modelID string
}

func (r *ApiDeleteModelInstanceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["modelID"]; ok { //modelID
		err = json.Unmarshal(v, &r.modelID)
		if err != nil {
			err = json.Unmarshal(b, &r.modelID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// @return ApiDeleteModelInstanceRequest
func (c *APIClient) NewApiDeleteModelInstanceRequest(modelID string) ApiDeleteModelInstanceRequest {
	return ApiDeleteModelInstanceRequest{
		modelID: modelID,
	}
}

// DeleteModelInstance wraps DeleteModelInstanceWithContext using context.Background.
func (c *APIClient) DeleteModelInstance(r ApiDeleteModelInstanceRequest, opts ...Option) (*DeleteModelInstanceResponse, error) {
	return c.DeleteModelInstanceWithContext(context.Background(), r, opts...)
}

// @return DeleteModelInstanceResponse
func (c *APIClient) DeleteModelInstanceWithContext(ctx context.Context, r ApiDeleteModelInstanceRequest, opts ...Option) (*DeleteModelInstanceResponse, error) {
	var (
		postBody    any
		returnValue *DeleteModelInstanceResponse
	)

	requestPath := "/1/predict/models/{modelID}"
	requestPath = strings.Replace(requestPath, "{"+"modelID"+"}", url.PathEscape(parameterToString(r.modelID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiDeleteSegmentRequest struct {
	segmentID string
}

func (r *ApiDeleteSegmentRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["segmentID"]; ok { //segmentID
		err = json.Unmarshal(v, &r.segmentID)
		if err != nil {
			err = json.Unmarshal(b, &r.segmentID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// @return ApiDeleteSegmentRequest
func (c *APIClient) NewApiDeleteSegmentRequest(segmentID string) ApiDeleteSegmentRequest {
	return ApiDeleteSegmentRequest{
		segmentID: segmentID,
	}
}

// DeleteSegment wraps DeleteSegmentWithContext using context.Background.
func (c *APIClient) DeleteSegment(r ApiDeleteSegmentRequest, opts ...Option) (*DeleteSegmentResponse, error) {
	return c.DeleteSegmentWithContext(context.Background(), r, opts...)
}

// @return DeleteSegmentResponse
func (c *APIClient) DeleteSegmentWithContext(ctx context.Context, r ApiDeleteSegmentRequest, opts ...Option) (*DeleteSegmentResponse, error) {
	var (
		postBody    any
		returnValue *DeleteSegmentResponse
	)

	requestPath := "/1/segments/{segmentID}"
	requestPath = strings.Replace(requestPath, "{"+"segmentID"+"}", url.PathEscape(parameterToString(r.segmentID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiDeleteUserProfileRequest struct {
	userID string
}

func (r *ApiDeleteUserProfileRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["userID"]; ok { //userID
		err = json.Unmarshal(v, &r.userID)
		if err != nil {
			err = json.Unmarshal(b, &r.userID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// @return ApiDeleteUserProfileRequest
func (c *APIClient) NewApiDeleteUserProfileRequest(userID string) ApiDeleteUserProfileRequest {
	return ApiDeleteUserProfileRequest{
		userID: userID,
	}
}

// DeleteUserProfile wraps DeleteUserProfileWithContext using context.Background.
func (c *APIClient) DeleteUserProfile(r ApiDeleteUserProfileRequest, opts ...Option) (*DeleteUserProfileResponse, error) {
	return c.DeleteUserProfileWithContext(context.Background(), r, opts...)
}

// @return DeleteUserProfileResponse
func (c *APIClient) DeleteUserProfileWithContext(ctx context.Context, r ApiDeleteUserProfileRequest, opts ...Option) (*DeleteUserProfileResponse, error) {
	var (
		postBody    any
		returnValue *DeleteUserProfileResponse
	)

	requestPath := "/1/users/{userID}"
	requestPath = strings.Replace(requestPath, "{"+"userID"+"}", url.PathEscape(parameterToString(r.userID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiFetchAllSegmentsRequest struct {
	type_ *SegmentType
}

func (r *ApiFetchAllSegmentsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["type"]; ok { //type_
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// The type of segments to fetch.
func (r ApiFetchAllSegmentsRequest) WithType_(type_ *SegmentType) ApiFetchAllSegmentsRequest {
	r.type_ = type_
	return r
}

// @return ApiFetchAllSegmentsRequest
func (c *APIClient) NewApiFetchAllSegmentsRequest() ApiFetchAllSegmentsRequest {
	return ApiFetchAllSegmentsRequest{}
}

// FetchAllSegments wraps FetchAllSegmentsWithContext using context.Background.
func (c *APIClient) FetchAllSegments(r ApiFetchAllSegmentsRequest, opts ...Option) ([]Segment, error) {
	return c.FetchAllSegmentsWithContext(context.Background(), r, opts...)
}

// @return []Segment
func (c *APIClient) FetchAllSegmentsWithContext(ctx context.Context, r ApiFetchAllSegmentsRequest, opts ...Option) ([]Segment, error) {
	var (
		postBody    any
		returnValue []Segment
	)

	requestPath := "/1/segments"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.type_) {
		queryParams.Set("type", parameterToString(*r.type_))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiFetchAllUserProfilesRequest struct {
	fetchAllUserProfilesParams *FetchAllUserProfilesParams
}

func (r *ApiFetchAllUserProfilesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["fetchAllUserProfilesParams"]; ok { //fetchAllUserProfilesParams
		err = json.Unmarshal(v, &r.fetchAllUserProfilesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.fetchAllUserProfilesParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.fetchAllUserProfilesParams)
		if err != nil {
			return err
		}
	}

	return nil
}

func (r ApiFetchAllUserProfilesRequest) WithFetchAllUserProfilesParams(fetchAllUserProfilesParams *FetchAllUserProfilesParams) ApiFetchAllUserProfilesRequest {
	r.fetchAllUserProfilesParams = fetchAllUserProfilesParams
	return r
}

// @return ApiFetchAllUserProfilesRequest
func (c *APIClient) NewApiFetchAllUserProfilesRequest() ApiFetchAllUserProfilesRequest {
	return ApiFetchAllUserProfilesRequest{}
}

// FetchAllUserProfiles wraps FetchAllUserProfilesWithContext using context.Background.
func (c *APIClient) FetchAllUserProfiles(r ApiFetchAllUserProfilesRequest, opts ...Option) (*FetchAllUserProfilesResponse, error) {
	return c.FetchAllUserProfilesWithContext(context.Background(), r, opts...)
}

// @return FetchAllUserProfilesResponse
func (c *APIClient) FetchAllUserProfilesWithContext(ctx context.Context, r ApiFetchAllUserProfilesRequest, opts ...Option) (*FetchAllUserProfilesResponse, error) {
	var (
		postBody    any
		returnValue *FetchAllUserProfilesResponse
	)

	requestPath := "/1/users"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.fetchAllUserProfilesParams == nil {
		return returnValue, reportError("fetchAllUserProfilesParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.fetchAllUserProfilesParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiFetchSegmentRequest struct {
	segmentID string
}

func (r *ApiFetchSegmentRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["segmentID"]; ok { //segmentID
		err = json.Unmarshal(v, &r.segmentID)
		if err != nil {
			err = json.Unmarshal(b, &r.segmentID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// @return ApiFetchSegmentRequest
func (c *APIClient) NewApiFetchSegmentRequest(segmentID string) ApiFetchSegmentRequest {
	return ApiFetchSegmentRequest{
		segmentID: segmentID,
	}
}

// FetchSegment wraps FetchSegmentWithContext using context.Background.
func (c *APIClient) FetchSegment(r ApiFetchSegmentRequest, opts ...Option) (*Segment, error) {
	return c.FetchSegmentWithContext(context.Background(), r, opts...)
}

// @return Segment
func (c *APIClient) FetchSegmentWithContext(ctx context.Context, r ApiFetchSegmentRequest, opts ...Option) (*Segment, error) {
	var (
		postBody    any
		returnValue *Segment
	)

	requestPath := "/1/segments/{segmentID}"
	requestPath = strings.Replace(requestPath, "{"+"segmentID"+"}", url.PathEscape(parameterToString(r.segmentID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiFetchUserProfileRequest struct {
	userID string
	params *Params
}

func (r *ApiFetchUserProfileRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["userID"]; ok { //userID
		err = json.Unmarshal(v, &r.userID)
		if err != nil {
			err = json.Unmarshal(b, &r.userID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["params"]; ok { //params
		err = json.Unmarshal(v, &r.params)
		if err != nil {
			err = json.Unmarshal(b, &r.params)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.params)
		if err != nil {
			return err
		}
	}

	return nil
}

func (r ApiFetchUserProfileRequest) WithParams(params *Params) ApiFetchUserProfileRequest {
	r.params = params
	return r
}

// @return ApiFetchUserProfileRequest
func (c *APIClient) NewApiFetchUserProfileRequest(userID string) ApiFetchUserProfileRequest {
	return ApiFetchUserProfileRequest{
		userID: userID,
	}
}

// FetchUserProfile wraps FetchUserProfileWithContext using context.Background.
func (c *APIClient) FetchUserProfile(r ApiFetchUserProfileRequest, opts ...Option) (*UserProfile, error) {
	return c.FetchUserProfileWithContext(context.Background(), r, opts...)
}

// @return UserProfile
func (c *APIClient) FetchUserProfileWithContext(ctx context.Context, r ApiFetchUserProfileRequest, opts ...Option) (*UserProfile, error) {
	var (
		postBody    any
		returnValue *UserProfile
	)

	requestPath := "/1/users/{userID}/fetch"
	requestPath = strings.Replace(requestPath, "{"+"userID"+"}", url.PathEscape(parameterToString(r.userID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.params == nil {
		return returnValue, reportError("params is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.params
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 405 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetRequest struct {
	path       string
	parameters map[string]interface{}
}

func (r *ApiGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok { //path
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok { //parameters
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// Query parameters to be applied to the current query.
func (r ApiGetRequest) WithParameters(parameters map[string]interface{}) ApiGetRequest {
	r.parameters = parameters
	return r
}

// @return ApiGetRequest
func (c *APIClient) NewApiGetRequest(path string) ApiGetRequest {
	return ApiGetRequest{
		path: path,
	}
}

// Get wraps GetWithContext using context.Background.
func (c *APIClient) Get(r ApiGetRequest, opts ...Option) (map[string]interface{}, error) {
	return c.GetWithContext(context.Background(), r, opts...)
}

// @return map[string]interface{}
func (c *APIClient) GetWithContext(ctx context.Context, r ApiGetRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetAvailableModelTypesRequest struct {
}

func (r *ApiGetAvailableModelTypesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}

	return nil
}

// @return ApiGetAvailableModelTypesRequest
func (c *APIClient) NewApiGetAvailableModelTypesRequest() ApiGetAvailableModelTypesRequest {
	return ApiGetAvailableModelTypesRequest{}
}

// GetAvailableModelTypes wraps GetAvailableModelTypesWithContext using context.Background.
func (c *APIClient) GetAvailableModelTypes(r ApiGetAvailableModelTypesRequest, opts ...Option) ([]GetAvailableModelTypesResponseInner, error) {
	return c.GetAvailableModelTypesWithContext(context.Background(), r, opts...)
}

// @return []GetAvailableModelTypesResponseInner
func (c *APIClient) GetAvailableModelTypesWithContext(ctx context.Context, r ApiGetAvailableModelTypesRequest, opts ...Option) ([]GetAvailableModelTypesResponseInner, error) {
	var (
		postBody    any
		returnValue []GetAvailableModelTypesResponseInner
	)

	requestPath := "/1/predict/modeltypes"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetModelInstanceConfigRequest struct {
	modelID string
}

func (r *ApiGetModelInstanceConfigRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["modelID"]; ok { //modelID
		err = json.Unmarshal(v, &r.modelID)
		if err != nil {
			err = json.Unmarshal(b, &r.modelID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// @return ApiGetModelInstanceConfigRequest
func (c *APIClient) NewApiGetModelInstanceConfigRequest(modelID string) ApiGetModelInstanceConfigRequest {
	return ApiGetModelInstanceConfigRequest{
		modelID: modelID,
	}
}

// GetModelInstanceConfig wraps GetModelInstanceConfigWithContext using context.Background.
func (c *APIClient) GetModelInstanceConfig(r ApiGetModelInstanceConfigRequest, opts ...Option) (*ModelInstance, error) {
	return c.GetModelInstanceConfigWithContext(context.Background(), r, opts...)
}

// @return ModelInstance
func (c *APIClient) GetModelInstanceConfigWithContext(ctx context.Context, r ApiGetModelInstanceConfigRequest, opts ...Option) (*ModelInstance, error) {
	var (
		postBody    any
		returnValue *ModelInstance
	)

	requestPath := "/1/predict/models/{modelID}"
	requestPath = strings.Replace(requestPath, "{"+"modelID"+"}", url.PathEscape(parameterToString(r.modelID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetModelInstancesRequest struct {
}

func (r *ApiGetModelInstancesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}

	return nil
}

// @return ApiGetModelInstancesRequest
func (c *APIClient) NewApiGetModelInstancesRequest() ApiGetModelInstancesRequest {
	return ApiGetModelInstancesRequest{}
}

// GetModelInstances wraps GetModelInstancesWithContext using context.Background.
func (c *APIClient) GetModelInstances(r ApiGetModelInstancesRequest, opts ...Option) ([]ModelInstance, error) {
	return c.GetModelInstancesWithContext(context.Background(), r, opts...)
}

// @return []ModelInstance
func (c *APIClient) GetModelInstancesWithContext(ctx context.Context, r ApiGetModelInstancesRequest, opts ...Option) ([]ModelInstance, error) {
	var (
		postBody    any
		returnValue []ModelInstance
	)

	requestPath := "/1/predict/models"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetModelMetricsRequest struct {
	modelID string
}

func (r *ApiGetModelMetricsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["modelID"]; ok { //modelID
		err = json.Unmarshal(v, &r.modelID)
		if err != nil {
			err = json.Unmarshal(b, &r.modelID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// @return ApiGetModelMetricsRequest
func (c *APIClient) NewApiGetModelMetricsRequest(modelID string) ApiGetModelMetricsRequest {
	return ApiGetModelMetricsRequest{
		modelID: modelID,
	}
}

// GetModelMetrics wraps GetModelMetricsWithContext using context.Background.
func (c *APIClient) GetModelMetrics(r ApiGetModelMetricsRequest, opts ...Option) (*GetModelMetricsResponse, error) {
	return c.GetModelMetricsWithContext(context.Background(), r, opts...)
}

// @return GetModelMetricsResponse
func (c *APIClient) GetModelMetricsWithContext(ctx context.Context, r ApiGetModelMetricsRequest, opts ...Option) (*GetModelMetricsResponse, error) {
	var (
		postBody    any
		returnValue *GetModelMetricsResponse
	)

	requestPath := "/1/predict/models/{modelID}/metrics"
	requestPath = strings.Replace(requestPath, "{"+"modelID"+"}", url.PathEscape(parameterToString(r.modelID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiGetSegmentUsersRequest struct {
	segmentID                  string
	fetchAllUserProfilesParams *FetchAllUserProfilesParams
}

func (r *ApiGetSegmentUsersRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["segmentID"]; ok { //segmentID
		err = json.Unmarshal(v, &r.segmentID)
		if err != nil {
			err = json.Unmarshal(b, &r.segmentID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["fetchAllUserProfilesParams"]; ok { //fetchAllUserProfilesParams
		err = json.Unmarshal(v, &r.fetchAllUserProfilesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.fetchAllUserProfilesParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.fetchAllUserProfilesParams)
		if err != nil {
			return err
		}
	}

	return nil
}

func (r ApiGetSegmentUsersRequest) WithFetchAllUserProfilesParams(fetchAllUserProfilesParams *FetchAllUserProfilesParams) ApiGetSegmentUsersRequest {
	r.fetchAllUserProfilesParams = fetchAllUserProfilesParams
	return r
}

// @return ApiGetSegmentUsersRequest
func (c *APIClient) NewApiGetSegmentUsersRequest(segmentID string) ApiGetSegmentUsersRequest {
	return ApiGetSegmentUsersRequest{
		segmentID: segmentID,
	}
}

// GetSegmentUsers wraps GetSegmentUsersWithContext using context.Background.
func (c *APIClient) GetSegmentUsers(r ApiGetSegmentUsersRequest, opts ...Option) (*GetSegmentUsersResponse, error) {
	return c.GetSegmentUsersWithContext(context.Background(), r, opts...)
}

// @return GetSegmentUsersResponse
func (c *APIClient) GetSegmentUsersWithContext(ctx context.Context, r ApiGetSegmentUsersRequest, opts ...Option) (*GetSegmentUsersResponse, error) {
	var (
		postBody    any
		returnValue *GetSegmentUsersResponse
	)

	requestPath := "/1/segments/{segmentID}/users"
	requestPath = strings.Replace(requestPath, "{"+"segmentID"+"}", url.PathEscape(parameterToString(r.segmentID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.fetchAllUserProfilesParams == nil {
		return returnValue, reportError("fetchAllUserProfilesParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.fetchAllUserProfilesParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiPostRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

func (r *ApiPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok { //path
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok { //parameters
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok { //body
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// Query parameters to be applied to the current query.
func (r ApiPostRequest) WithParameters(parameters map[string]interface{}) ApiPostRequest {
	r.parameters = parameters
	return r
}

// The parameters to send with the custom request.
func (r ApiPostRequest) WithBody(body map[string]interface{}) ApiPostRequest {
	r.body = body
	return r
}

// @return ApiPostRequest
func (c *APIClient) NewApiPostRequest(path string) ApiPostRequest {
	return ApiPostRequest{
		path: path,
	}
}

// Post wraps PostWithContext using context.Background.
func (c *APIClient) Post(r ApiPostRequest, opts ...Option) (map[string]interface{}, error) {
	return c.PostWithContext(context.Background(), r, opts...)
}

// @return map[string]interface{}
func (c *APIClient) PostWithContext(ctx context.Context, r ApiPostRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiPutRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

func (r *ApiPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok { //path
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok { //parameters
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok { //body
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// Query parameters to be applied to the current query.
func (r ApiPutRequest) WithParameters(parameters map[string]interface{}) ApiPutRequest {
	r.parameters = parameters
	return r
}

// The parameters to send with the custom request.
func (r ApiPutRequest) WithBody(body map[string]interface{}) ApiPutRequest {
	r.body = body
	return r
}

// @return ApiPutRequest
func (c *APIClient) NewApiPutRequest(path string) ApiPutRequest {
	return ApiPutRequest{
		path: path,
	}
}

// Put wraps PutWithContext using context.Background.
func (c *APIClient) Put(r ApiPutRequest, opts ...Option) (map[string]interface{}, error) {
	return c.PutWithContext(context.Background(), r, opts...)
}

// @return map[string]interface{}
func (c *APIClient) PutWithContext(ctx context.Context, r ApiPutRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiUpdateModelInstanceRequest struct {
	modelID           string
	updateModelParams *UpdateModelParams
}

func (r *ApiUpdateModelInstanceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["modelID"]; ok { //modelID
		err = json.Unmarshal(v, &r.modelID)
		if err != nil {
			err = json.Unmarshal(b, &r.modelID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["updateModelParams"]; ok { //updateModelParams
		err = json.Unmarshal(v, &r.updateModelParams)
		if err != nil {
			err = json.Unmarshal(b, &r.updateModelParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.updateModelParams)
		if err != nil {
			return err
		}
	}

	return nil
}

func (r ApiUpdateModelInstanceRequest) WithUpdateModelParams(updateModelParams *UpdateModelParams) ApiUpdateModelInstanceRequest {
	r.updateModelParams = updateModelParams
	return r
}

// @return ApiUpdateModelInstanceRequest
func (c *APIClient) NewApiUpdateModelInstanceRequest(modelID string) ApiUpdateModelInstanceRequest {
	return ApiUpdateModelInstanceRequest{
		modelID: modelID,
	}
}

// UpdateModelInstance wraps UpdateModelInstanceWithContext using context.Background.
func (c *APIClient) UpdateModelInstance(r ApiUpdateModelInstanceRequest, opts ...Option) (*UpdateModelInstanceResponse, error) {
	return c.UpdateModelInstanceWithContext(context.Background(), r, opts...)
}

// @return UpdateModelInstanceResponse
func (c *APIClient) UpdateModelInstanceWithContext(ctx context.Context, r ApiUpdateModelInstanceRequest, opts ...Option) (*UpdateModelInstanceResponse, error) {
	var (
		postBody    any
		returnValue *UpdateModelInstanceResponse
	)

	requestPath := "/1/predict/models/{modelID}"
	requestPath = strings.Replace(requestPath, "{"+"modelID"+"}", url.PathEscape(parameterToString(r.modelID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.updateModelParams == nil {
		return returnValue, reportError("updateModelParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.updateModelParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

type ApiUpdateSegmentRequest struct {
	segmentID           string
	updateSegmentParams *UpdateSegmentParams
}

func (r *ApiUpdateSegmentRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["segmentID"]; ok { //segmentID
		err = json.Unmarshal(v, &r.segmentID)
		if err != nil {
			err = json.Unmarshal(b, &r.segmentID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["updateSegmentParams"]; ok { //updateSegmentParams
		err = json.Unmarshal(v, &r.updateSegmentParams)
		if err != nil {
			err = json.Unmarshal(b, &r.updateSegmentParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.updateSegmentParams)
		if err != nil {
			return err
		}
	}

	return nil
}

func (r ApiUpdateSegmentRequest) WithUpdateSegmentParams(updateSegmentParams *UpdateSegmentParams) ApiUpdateSegmentRequest {
	r.updateSegmentParams = updateSegmentParams
	return r
}

// @return ApiUpdateSegmentRequest
func (c *APIClient) NewApiUpdateSegmentRequest(segmentID string) ApiUpdateSegmentRequest {
	return ApiUpdateSegmentRequest{
		segmentID: segmentID,
	}
}

// UpdateSegment wraps UpdateSegmentWithContext using context.Background.
func (c *APIClient) UpdateSegment(r ApiUpdateSegmentRequest, opts ...Option) (*UpdateSegmentResponse, error) {
	return c.UpdateSegmentWithContext(context.Background(), r, opts...)
}

// @return UpdateSegmentResponse
func (c *APIClient) UpdateSegmentWithContext(ctx context.Context, r ApiUpdateSegmentRequest, opts ...Option) (*UpdateSegmentResponse, error) {
	var (
		postBody    any
		returnValue *UpdateSegmentResponse
	)

	requestPath := "/1/segments/{segmentID}"
	requestPath = strings.Replace(requestPath, "{"+"segmentID"+"}", url.PathEscape(parameterToString(r.segmentID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.updateSegmentParams == nil {
		return returnValue, reportError("updateSegmentParams is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.updateSegmentParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 401 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 422 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 500 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
