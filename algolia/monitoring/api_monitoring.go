// File generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation.
package monitoring

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       name,
		value:      parameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

func (r *ApiCustomDeleteRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiCustomDeleteRequest represents the request with all the parameters for the API call.
type ApiCustomDeleteRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiCustomDeleteRequest creates an instance of the ApiCustomDeleteRequest to be used for the API call.
func (c *APIClient) NewApiCustomDeleteRequest(path string) ApiCustomDeleteRequest {
	return ApiCustomDeleteRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomDeleteRequest and returns the request for chaining.
func (r ApiCustomDeleteRequest) WithParameters(parameters map[string]interface{}) ApiCustomDeleteRequest {
	r.parameters = parameters
	return r
}

/*
CustomDelete Send requests to the Algolia REST API. Wraps CustomDeleteWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomDelete(r ApiCustomDeleteRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomDeleteWithContext(context.Background(), r, opts...)
}

/*
CustomDelete Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomDeleteWithContext(ctx context.Context, r ApiCustomDeleteRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", url.PathEscape(parameterToString(r.path)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiCustomGetRequest represents the request with all the parameters for the API call.
type ApiCustomGetRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiCustomGetRequest creates an instance of the ApiCustomGetRequest to be used for the API call.
func (c *APIClient) NewApiCustomGetRequest(path string) ApiCustomGetRequest {
	return ApiCustomGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomGetRequest and returns the request for chaining.
func (r ApiCustomGetRequest) WithParameters(parameters map[string]interface{}) ApiCustomGetRequest {
	r.parameters = parameters
	return r
}

/*
CustomGet Send requests to the Algolia REST API. Wraps CustomGetWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomGet(r ApiCustomGetRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomGetWithContext(context.Background(), r, opts...)
}

/*
CustomGet Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomGetWithContext(ctx context.Context, r ApiCustomGetRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", url.PathEscape(parameterToString(r.path)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiCustomPostRequest represents the request with all the parameters for the API call.
type ApiCustomPostRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiCustomPostRequest creates an instance of the ApiCustomPostRequest to be used for the API call.
func (c *APIClient) NewApiCustomPostRequest(path string) ApiCustomPostRequest {
	return ApiCustomPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithParameters(parameters map[string]interface{}) ApiCustomPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithBody(body map[string]interface{}) ApiCustomPostRequest {
	r.body = body
	return r
}

/*
CustomPost Send requests to the Algolia REST API. Wraps CustomPostWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPost(r ApiCustomPostRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomPostWithContext(context.Background(), r, opts...)
}

/*
CustomPost Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPostWithContext(ctx context.Context, r ApiCustomPostRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", url.PathEscape(parameterToString(r.path)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiCustomPutRequest represents the request with all the parameters for the API call.
type ApiCustomPutRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiCustomPutRequest creates an instance of the ApiCustomPutRequest to be used for the API call.
func (c *APIClient) NewApiCustomPutRequest(path string) ApiCustomPutRequest {
	return ApiCustomPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithParameters(parameters map[string]interface{}) ApiCustomPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithBody(body map[string]interface{}) ApiCustomPutRequest {
	r.body = body
	return r
}

/*
CustomPut Send requests to the Algolia REST API. Wraps CustomPutWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPut(r ApiCustomPutRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomPutWithContext(context.Background(), r, opts...)
}

/*
CustomPut Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPutWithContext(ctx context.Context, r ApiCustomPutRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", url.PathEscape(parameterToString(r.path)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetClusterIncidentsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["clusters"]; ok {
		err = json.Unmarshal(v, &r.clusters)
		if err != nil {
			err = json.Unmarshal(b, &r.clusters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetClusterIncidentsRequest represents the request with all the parameters for the API call.
type ApiGetClusterIncidentsRequest struct {
	clusters string
}

// NewApiGetClusterIncidentsRequest creates an instance of the ApiGetClusterIncidentsRequest to be used for the API call.
func (c *APIClient) NewApiGetClusterIncidentsRequest(clusters string) ApiGetClusterIncidentsRequest {
	return ApiGetClusterIncidentsRequest{
		clusters: clusters,
	}
}

/*
GetClusterIncidents List incidents for selected clusters. Wraps GetClusterIncidentsWithContext using context.Background.

List known incidents for selected clusters.

Request can be constructed by NewApiGetClusterIncidentsRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return IncidentsResponse
*/
func (c *APIClient) GetClusterIncidents(r ApiGetClusterIncidentsRequest, opts ...Option) (*IncidentsResponse, error) {
	return c.GetClusterIncidentsWithContext(context.Background(), r, opts...)
}

/*
GetClusterIncidents List incidents for selected clusters.

List known incidents for selected clusters.

Request can be constructed by NewApiGetClusterIncidentsRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return IncidentsResponse
*/
func (c *APIClient) GetClusterIncidentsWithContext(ctx context.Context, r ApiGetClusterIncidentsRequest, opts ...Option) (*IncidentsResponse, error) {
	var (
		postBody    any
		returnValue *IncidentsResponse
	)

	requestPath := "/1/incidents/{clusters}"
	requestPath = strings.ReplaceAll(requestPath, "{clusters}", url.PathEscape(parameterToString(r.clusters)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.clusters == "" {
		return returnValue, reportError("Parameter `clusters` is required when calling `GetClusterIncidents`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetClusterStatusRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["clusters"]; ok {
		err = json.Unmarshal(v, &r.clusters)
		if err != nil {
			err = json.Unmarshal(b, &r.clusters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetClusterStatusRequest represents the request with all the parameters for the API call.
type ApiGetClusterStatusRequest struct {
	clusters string
}

// NewApiGetClusterStatusRequest creates an instance of the ApiGetClusterStatusRequest to be used for the API call.
func (c *APIClient) NewApiGetClusterStatusRequest(clusters string) ApiGetClusterStatusRequest {
	return ApiGetClusterStatusRequest{
		clusters: clusters,
	}
}

/*
GetClusterStatus List statuses of selected clusters. Wraps GetClusterStatusWithContext using context.Background.

Report whether a cluster is operational.

Request can be constructed by NewApiGetClusterStatusRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return StatusResponse
*/
func (c *APIClient) GetClusterStatus(r ApiGetClusterStatusRequest, opts ...Option) (*StatusResponse, error) {
	return c.GetClusterStatusWithContext(context.Background(), r, opts...)
}

/*
GetClusterStatus List statuses of selected clusters.

Report whether a cluster is operational.

Request can be constructed by NewApiGetClusterStatusRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return StatusResponse
*/
func (c *APIClient) GetClusterStatusWithContext(ctx context.Context, r ApiGetClusterStatusRequest, opts ...Option) (*StatusResponse, error) {
	var (
		postBody    any
		returnValue *StatusResponse
	)

	requestPath := "/1/status/{clusters}"
	requestPath = strings.ReplaceAll(requestPath, "{clusters}", url.PathEscape(parameterToString(r.clusters)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.clusters == "" {
		return returnValue, reportError("Parameter `clusters` is required when calling `GetClusterStatus`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetIncidents List incidents. Wraps GetIncidentsWithContext using context.Background.

List known incidents for all clusters.

Request can be constructed by NewApiGetIncidentsRequest with parameters below.

	@return IncidentsResponse
*/
func (c *APIClient) GetIncidents(opts ...Option) (*IncidentsResponse, error) {
	return c.GetIncidentsWithContext(context.Background(), opts...)
}

/*
GetIncidents List incidents.

List known incidents for all clusters.

Request can be constructed by NewApiGetIncidentsRequest with parameters below.

	@return IncidentsResponse
*/
func (c *APIClient) GetIncidentsWithContext(ctx context.Context, opts ...Option) (*IncidentsResponse, error) {
	var (
		postBody    any
		returnValue *IncidentsResponse
	)

	requestPath := "/1/incidents"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetIndexingTimeRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["clusters"]; ok {
		err = json.Unmarshal(v, &r.clusters)
		if err != nil {
			err = json.Unmarshal(b, &r.clusters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetIndexingTimeRequest represents the request with all the parameters for the API call.
type ApiGetIndexingTimeRequest struct {
	clusters string
}

// NewApiGetIndexingTimeRequest creates an instance of the ApiGetIndexingTimeRequest to be used for the API call.
func (c *APIClient) NewApiGetIndexingTimeRequest(clusters string) ApiGetIndexingTimeRequest {
	return ApiGetIndexingTimeRequest{
		clusters: clusters,
	}
}

/*
GetIndexingTime Get indexing times. Wraps GetIndexingTimeWithContext using context.Background.

List the average times for indexing operations for selected clusters.

Request can be constructed by NewApiGetIndexingTimeRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return IndexingTimeResponse
*/
func (c *APIClient) GetIndexingTime(r ApiGetIndexingTimeRequest, opts ...Option) (*IndexingTimeResponse, error) {
	return c.GetIndexingTimeWithContext(context.Background(), r, opts...)
}

/*
GetIndexingTime Get indexing times.

List the average times for indexing operations for selected clusters.

Request can be constructed by NewApiGetIndexingTimeRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return IndexingTimeResponse
*/
func (c *APIClient) GetIndexingTimeWithContext(ctx context.Context, r ApiGetIndexingTimeRequest, opts ...Option) (*IndexingTimeResponse, error) {
	var (
		postBody    any
		returnValue *IndexingTimeResponse
	)

	requestPath := "/1/indexing/{clusters}"
	requestPath = strings.ReplaceAll(requestPath, "{clusters}", url.PathEscape(parameterToString(r.clusters)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.clusters == "" {
		return returnValue, reportError("Parameter `clusters` is required when calling `GetIndexingTime`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetInventory List servers. Wraps GetInventoryWithContext using context.Background.

List the servers belonging to clusters.

The response depends on whether you authenticate your API request:

- With authentication, the response lists the servers assigned to your
Algolia application's cluster.

- Without authentication, the response lists the servers for all Algolia
clusters.

Request can be constructed by NewApiGetInventoryRequest with parameters below.

	@return InventoryResponse
*/
func (c *APIClient) GetInventory(opts ...Option) (*InventoryResponse, error) {
	return c.GetInventoryWithContext(context.Background(), opts...)
}

/*
GetInventory List servers.

List the servers belonging to clusters.

The response depends on whether you authenticate your API request:

- With authentication, the response lists the servers assigned to your
Algolia application's cluster.

- Without authentication, the response lists the servers for all Algolia
clusters.

Request can be constructed by NewApiGetInventoryRequest with parameters below.

	@return InventoryResponse
*/
func (c *APIClient) GetInventoryWithContext(ctx context.Context, opts ...Option) (*InventoryResponse, error) {
	var (
		postBody    any
		returnValue *InventoryResponse
	)

	requestPath := "/1/inventory/servers"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetLatencyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["clusters"]; ok {
		err = json.Unmarshal(v, &r.clusters)
		if err != nil {
			err = json.Unmarshal(b, &r.clusters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetLatencyRequest represents the request with all the parameters for the API call.
type ApiGetLatencyRequest struct {
	clusters string
}

// NewApiGetLatencyRequest creates an instance of the ApiGetLatencyRequest to be used for the API call.
func (c *APIClient) NewApiGetLatencyRequest(clusters string) ApiGetLatencyRequest {
	return ApiGetLatencyRequest{
		clusters: clusters,
	}
}

/*
GetLatency Get search latency times. Wraps GetLatencyWithContext using context.Background.

List the average latency for search requests for selected clusters.

Request can be constructed by NewApiGetLatencyRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return LatencyResponse
*/
func (c *APIClient) GetLatency(r ApiGetLatencyRequest, opts ...Option) (*LatencyResponse, error) {
	return c.GetLatencyWithContext(context.Background(), r, opts...)
}

/*
GetLatency Get search latency times.

List the average latency for search requests for selected clusters.

Request can be constructed by NewApiGetLatencyRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return LatencyResponse
*/
func (c *APIClient) GetLatencyWithContext(ctx context.Context, r ApiGetLatencyRequest, opts ...Option) (*LatencyResponse, error) {
	var (
		postBody    any
		returnValue *LatencyResponse
	)

	requestPath := "/1/latency/{clusters}"
	requestPath = strings.ReplaceAll(requestPath, "{clusters}", url.PathEscape(parameterToString(r.clusters)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.clusters == "" {
		return returnValue, reportError("Parameter `clusters` is required when calling `GetLatency`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetMetricsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["metric"]; ok {
		err = json.Unmarshal(v, &r.metric)
		if err != nil {
			err = json.Unmarshal(b, &r.metric)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["period"]; ok {
		err = json.Unmarshal(v, &r.period)
		if err != nil {
			err = json.Unmarshal(b, &r.period)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetMetricsRequest represents the request with all the parameters for the API call.
type ApiGetMetricsRequest struct {
	metric Metric
	period Period
}

// NewApiGetMetricsRequest creates an instance of the ApiGetMetricsRequest to be used for the API call.
func (c *APIClient) NewApiGetMetricsRequest(metric Metric, period Period) ApiGetMetricsRequest {
	return ApiGetMetricsRequest{
		metric: metric,
		period: period,
	}
}

/*
GetMetrics Get metrics for a given period. Wraps GetMetricsWithContext using context.Background.

Report the aggregate value of a metric for a selected period of time.

Request can be constructed by NewApiGetMetricsRequest with parameters below.

	@param metric Metric - Metric to report.  For more information about the individual metrics, see the response. To include all metrics, use `*` as the parameter.
	@param period Period - Period over which to aggregate the metrics:  - `minute`. Aggregate the last minute. 1 data point per 10 seconds. - `hour`. Aggregate the last hour. 1 data point per minute. - `day`. Aggregate the last day. 1 data point per 10 minutes. - `week`. Aggregate the last week. 1 data point per hour. - `month`. Aggregate the last month. 1 data point per day.
	@return InfrastructureResponse
*/
func (c *APIClient) GetMetrics(r ApiGetMetricsRequest, opts ...Option) (*InfrastructureResponse, error) {
	return c.GetMetricsWithContext(context.Background(), r, opts...)
}

/*
GetMetrics Get metrics for a given period.

Report the aggregate value of a metric for a selected period of time.

Request can be constructed by NewApiGetMetricsRequest with parameters below.

	@param metric Metric - Metric to report.  For more information about the individual metrics, see the response. To include all metrics, use `*` as the parameter.
	@param period Period - Period over which to aggregate the metrics:  - `minute`. Aggregate the last minute. 1 data point per 10 seconds. - `hour`. Aggregate the last hour. 1 data point per minute. - `day`. Aggregate the last day. 1 data point per 10 minutes. - `week`. Aggregate the last week. 1 data point per hour. - `month`. Aggregate the last month. 1 data point per day.
	@return InfrastructureResponse
*/
func (c *APIClient) GetMetricsWithContext(ctx context.Context, r ApiGetMetricsRequest, opts ...Option) (*InfrastructureResponse, error) {
	var (
		postBody    any
		returnValue *InfrastructureResponse
	)

	requestPath := "/1/infrastructure/{metric}/period/{period}"
	requestPath = strings.ReplaceAll(requestPath, "{metric}", url.PathEscape(parameterToString(r.metric)))
	requestPath = strings.ReplaceAll(requestPath, "{period}", url.PathEscape(parameterToString(r.period)))

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetReachabilityRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["clusters"]; ok {
		err = json.Unmarshal(v, &r.clusters)
		if err != nil {
			err = json.Unmarshal(b, &r.clusters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetReachabilityRequest represents the request with all the parameters for the API call.
type ApiGetReachabilityRequest struct {
	clusters string
}

// NewApiGetReachabilityRequest creates an instance of the ApiGetReachabilityRequest to be used for the API call.
func (c *APIClient) NewApiGetReachabilityRequest(clusters string) ApiGetReachabilityRequest {
	return ApiGetReachabilityRequest{
		clusters: clusters,
	}
}

/*
GetReachability Test the reachability of clusters. Wraps GetReachabilityWithContext using context.Background.

Test whether clusters are reachable or not.

Request can be constructed by NewApiGetReachabilityRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return map[string]map[string]bool
*/
func (c *APIClient) GetReachability(r ApiGetReachabilityRequest, opts ...Option) (*map[string]map[string]bool, error) {
	return c.GetReachabilityWithContext(context.Background(), r, opts...)
}

/*
GetReachability Test the reachability of clusters.

Test whether clusters are reachable or not.

Request can be constructed by NewApiGetReachabilityRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return map[string]map[string]bool
*/
func (c *APIClient) GetReachabilityWithContext(ctx context.Context, r ApiGetReachabilityRequest, opts ...Option) (*map[string]map[string]bool, error) {
	var (
		postBody    any
		returnValue *map[string]map[string]bool
	)

	requestPath := "/1/reachability/{clusters}/probes"
	requestPath = strings.ReplaceAll(requestPath, "{clusters}", url.PathEscape(parameterToString(r.clusters)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.clusters == "" {
		return returnValue, reportError("Parameter `clusters` is required when calling `GetReachability`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetStatus List cluster statuses. Wraps GetStatusWithContext using context.Background.

Report whether clusters are operational.

The response depends on whether you authenticate your API request.

- With authentication, the response includes the status of the cluster
assigned to your Algolia application.

- Without authentication, the response lists the statuses of all public
Algolia clusters.

Request can be constructed by NewApiGetStatusRequest with parameters below.

	@return StatusResponse
*/
func (c *APIClient) GetStatus(opts ...Option) (*StatusResponse, error) {
	return c.GetStatusWithContext(context.Background(), opts...)
}

/*
GetStatus List cluster statuses.

Report whether clusters are operational.

The response depends on whether you authenticate your API request.

- With authentication, the response includes the status of the cluster
assigned to your Algolia application.

- Without authentication, the response lists the statuses of all public
Algolia clusters.

Request can be constructed by NewApiGetStatusRequest with parameters below.

	@return StatusResponse
*/
func (c *APIClient) GetStatusWithContext(ctx context.Context, opts ...Option) (*StatusResponse, error) {
	var (
		postBody    any
		returnValue *StatusResponse
	)

	requestPath := "/1/status"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
