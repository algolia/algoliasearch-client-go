// File generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation.
package monitoring

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       name,
		value:      queryParameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

func (r *ApiCustomDeleteRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomDeleteRequest represents the request with all the parameters for the API call.
type ApiCustomDeleteRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiCustomDeleteRequest creates an instance of the ApiCustomDeleteRequest to be used for the API call.
func (c *APIClient) NewApiCustomDeleteRequest(path string) ApiCustomDeleteRequest {
	return ApiCustomDeleteRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomDeleteRequest and returns the request for chaining.
func (r ApiCustomDeleteRequest) WithParameters(parameters map[string]interface{}) ApiCustomDeleteRequest {
	r.parameters = parameters
	return r
}

/*
CustomDelete Wraps CustomDeleteWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomDelete(r ApiCustomDeleteRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomDeleteWithContext(context.Background(), r, opts...)
}

/*
CustomDelete

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomDeleteWithContext(ctx context.Context, r ApiCustomDeleteRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomGetRequest represents the request with all the parameters for the API call.
type ApiCustomGetRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiCustomGetRequest creates an instance of the ApiCustomGetRequest to be used for the API call.
func (c *APIClient) NewApiCustomGetRequest(path string) ApiCustomGetRequest {
	return ApiCustomGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomGetRequest and returns the request for chaining.
func (r ApiCustomGetRequest) WithParameters(parameters map[string]interface{}) ApiCustomGetRequest {
	r.parameters = parameters
	return r
}

/*
CustomGet Wraps CustomGetWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomGet(r ApiCustomGetRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomGetWithContext(context.Background(), r, opts...)
}

/*
CustomGet

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomGetWithContext(ctx context.Context, r ApiCustomGetRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPostRequest represents the request with all the parameters for the API call.
type ApiCustomPostRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiCustomPostRequest creates an instance of the ApiCustomPostRequest to be used for the API call.
func (c *APIClient) NewApiCustomPostRequest(path string) ApiCustomPostRequest {
	return ApiCustomPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithParameters(parameters map[string]interface{}) ApiCustomPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithBody(body map[string]interface{}) ApiCustomPostRequest {
	r.body = body
	return r
}

/*
CustomPost Wraps CustomPostWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPost(r ApiCustomPostRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomPostWithContext(context.Background(), r, opts...)
}

/*
CustomPost

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPostWithContext(ctx context.Context, r ApiCustomPostRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPutRequest represents the request with all the parameters for the API call.
type ApiCustomPutRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiCustomPutRequest creates an instance of the ApiCustomPutRequest to be used for the API call.
func (c *APIClient) NewApiCustomPutRequest(path string) ApiCustomPutRequest {
	return ApiCustomPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithParameters(parameters map[string]interface{}) ApiCustomPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithBody(body map[string]interface{}) ApiCustomPutRequest {
	r.body = body
	return r
}

/*
CustomPut Wraps CustomPutWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPut(r ApiCustomPutRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomPutWithContext(context.Background(), r, opts...)
}

/*
CustomPut

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPutWithContext(ctx context.Context, r ApiCustomPutRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetClusterIncidentsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["clusters"]; ok {
		err = json.Unmarshal(v, &r.clusters)
		if err != nil {
			err = json.Unmarshal(b, &r.clusters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal clusters: %w", err)
			}
		}
	}

	return nil
}

// ApiGetClusterIncidentsRequest represents the request with all the parameters for the API call.
type ApiGetClusterIncidentsRequest struct {
	clusters string
}

// NewApiGetClusterIncidentsRequest creates an instance of the ApiGetClusterIncidentsRequest to be used for the API call.
func (c *APIClient) NewApiGetClusterIncidentsRequest(clusters string) ApiGetClusterIncidentsRequest {
	return ApiGetClusterIncidentsRequest{
		clusters: clusters,
	}
}

/*
GetClusterIncidents Wraps GetClusterIncidentsWithContext using context.Background.

List known incidents for selected clusters.

Request can be constructed by NewApiGetClusterIncidentsRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return IncidentsResponse
*/
func (c *APIClient) GetClusterIncidents(r ApiGetClusterIncidentsRequest, opts ...Option) (*IncidentsResponse, error) {
	return c.GetClusterIncidentsWithContext(context.Background(), r, opts...)
}

/*
GetClusterIncidents

List known incidents for selected clusters.

Request can be constructed by NewApiGetClusterIncidentsRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return IncidentsResponse
*/
func (c *APIClient) GetClusterIncidentsWithContext(ctx context.Context, r ApiGetClusterIncidentsRequest, opts ...Option) (*IncidentsResponse, error) {
	var (
		postBody    any
		returnValue *IncidentsResponse
	)

	requestPath := "/1/incidents/{clusters}"
	requestPath = strings.ReplaceAll(requestPath, "{clusters}", url.PathEscape(parameterToString(r.clusters)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.clusters == "" {
		return returnValue, reportError("Parameter `clusters` is required when calling `GetClusterIncidents`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetClusterStatusRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["clusters"]; ok {
		err = json.Unmarshal(v, &r.clusters)
		if err != nil {
			err = json.Unmarshal(b, &r.clusters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal clusters: %w", err)
			}
		}
	}

	return nil
}

// ApiGetClusterStatusRequest represents the request with all the parameters for the API call.
type ApiGetClusterStatusRequest struct {
	clusters string
}

// NewApiGetClusterStatusRequest creates an instance of the ApiGetClusterStatusRequest to be used for the API call.
func (c *APIClient) NewApiGetClusterStatusRequest(clusters string) ApiGetClusterStatusRequest {
	return ApiGetClusterStatusRequest{
		clusters: clusters,
	}
}

/*
GetClusterStatus Wraps GetClusterStatusWithContext using context.Background.

Report whether a cluster is operational.

Request can be constructed by NewApiGetClusterStatusRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return StatusResponse
*/
func (c *APIClient) GetClusterStatus(r ApiGetClusterStatusRequest, opts ...Option) (*StatusResponse, error) {
	return c.GetClusterStatusWithContext(context.Background(), r, opts...)
}

/*
GetClusterStatus

Report whether a cluster is operational.

Request can be constructed by NewApiGetClusterStatusRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return StatusResponse
*/
func (c *APIClient) GetClusterStatusWithContext(ctx context.Context, r ApiGetClusterStatusRequest, opts ...Option) (*StatusResponse, error) {
	var (
		postBody    any
		returnValue *StatusResponse
	)

	requestPath := "/1/status/{clusters}"
	requestPath = strings.ReplaceAll(requestPath, "{clusters}", url.PathEscape(parameterToString(r.clusters)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.clusters == "" {
		return returnValue, reportError("Parameter `clusters` is required when calling `GetClusterStatus`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetIncidents Wraps GetIncidentsWithContext using context.Background.

List known incidents for all clusters.

Request can be constructed by NewApiGetIncidentsRequest with parameters below.

	@return IncidentsResponse
*/
func (c *APIClient) GetIncidents(opts ...Option) (*IncidentsResponse, error) {
	return c.GetIncidentsWithContext(context.Background(), opts...)
}

/*
GetIncidents

List known incidents for all clusters.

Request can be constructed by NewApiGetIncidentsRequest with parameters below.

	@return IncidentsResponse
*/
func (c *APIClient) GetIncidentsWithContext(ctx context.Context, opts ...Option) (*IncidentsResponse, error) {
	var (
		postBody    any
		returnValue *IncidentsResponse
	)

	requestPath := "/1/incidents"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetIndexingTimeRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["clusters"]; ok {
		err = json.Unmarshal(v, &r.clusters)
		if err != nil {
			err = json.Unmarshal(b, &r.clusters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal clusters: %w", err)
			}
		}
	}

	return nil
}

// ApiGetIndexingTimeRequest represents the request with all the parameters for the API call.
type ApiGetIndexingTimeRequest struct {
	clusters string
}

// NewApiGetIndexingTimeRequest creates an instance of the ApiGetIndexingTimeRequest to be used for the API call.
func (c *APIClient) NewApiGetIndexingTimeRequest(clusters string) ApiGetIndexingTimeRequest {
	return ApiGetIndexingTimeRequest{
		clusters: clusters,
	}
}

/*
GetIndexingTime Wraps GetIndexingTimeWithContext using context.Background.

List the average times for indexing operations for selected clusters.

Request can be constructed by NewApiGetIndexingTimeRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return IndexingTimeResponse
*/
func (c *APIClient) GetIndexingTime(r ApiGetIndexingTimeRequest, opts ...Option) (*IndexingTimeResponse, error) {
	return c.GetIndexingTimeWithContext(context.Background(), r, opts...)
}

/*
GetIndexingTime

List the average times for indexing operations for selected clusters.

Request can be constructed by NewApiGetIndexingTimeRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return IndexingTimeResponse
*/
func (c *APIClient) GetIndexingTimeWithContext(ctx context.Context, r ApiGetIndexingTimeRequest, opts ...Option) (*IndexingTimeResponse, error) {
	var (
		postBody    any
		returnValue *IndexingTimeResponse
	)

	requestPath := "/1/indexing/{clusters}"
	requestPath = strings.ReplaceAll(requestPath, "{clusters}", url.PathEscape(parameterToString(r.clusters)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.clusters == "" {
		return returnValue, reportError("Parameter `clusters` is required when calling `GetIndexingTime`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetInventory Wraps GetInventoryWithContext using context.Background.

List the servers belonging to clusters.

The response depends on whether you authenticate your API request:

- With authentication, the response lists the servers assigned to your
Algolia application's cluster.

- Without authentication, the response lists the servers for all Algolia
clusters.

Request can be constructed by NewApiGetInventoryRequest with parameters below.

	@return InventoryResponse
*/
func (c *APIClient) GetInventory(opts ...Option) (*InventoryResponse, error) {
	return c.GetInventoryWithContext(context.Background(), opts...)
}

/*
GetInventory

List the servers belonging to clusters.

The response depends on whether you authenticate your API request:

- With authentication, the response lists the servers assigned to your
Algolia application's cluster.

- Without authentication, the response lists the servers for all Algolia
clusters.

Request can be constructed by NewApiGetInventoryRequest with parameters below.

	@return InventoryResponse
*/
func (c *APIClient) GetInventoryWithContext(ctx context.Context, opts ...Option) (*InventoryResponse, error) {
	var (
		postBody    any
		returnValue *InventoryResponse
	)

	requestPath := "/1/inventory/servers"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetLatencyRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["clusters"]; ok {
		err = json.Unmarshal(v, &r.clusters)
		if err != nil {
			err = json.Unmarshal(b, &r.clusters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal clusters: %w", err)
			}
		}
	}

	return nil
}

// ApiGetLatencyRequest represents the request with all the parameters for the API call.
type ApiGetLatencyRequest struct {
	clusters string
}

// NewApiGetLatencyRequest creates an instance of the ApiGetLatencyRequest to be used for the API call.
func (c *APIClient) NewApiGetLatencyRequest(clusters string) ApiGetLatencyRequest {
	return ApiGetLatencyRequest{
		clusters: clusters,
	}
}

/*
GetLatency Wraps GetLatencyWithContext using context.Background.

List the average latency for search requests for selected clusters.

Request can be constructed by NewApiGetLatencyRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return LatencyResponse
*/
func (c *APIClient) GetLatency(r ApiGetLatencyRequest, opts ...Option) (*LatencyResponse, error) {
	return c.GetLatencyWithContext(context.Background(), r, opts...)
}

/*
GetLatency

List the average latency for search requests for selected clusters.

Request can be constructed by NewApiGetLatencyRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return LatencyResponse
*/
func (c *APIClient) GetLatencyWithContext(ctx context.Context, r ApiGetLatencyRequest, opts ...Option) (*LatencyResponse, error) {
	var (
		postBody    any
		returnValue *LatencyResponse
	)

	requestPath := "/1/latency/{clusters}"
	requestPath = strings.ReplaceAll(requestPath, "{clusters}", url.PathEscape(parameterToString(r.clusters)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.clusters == "" {
		return returnValue, reportError("Parameter `clusters` is required when calling `GetLatency`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetMetricsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["metric"]; ok {
		err = json.Unmarshal(v, &r.metric)
		if err != nil {
			err = json.Unmarshal(b, &r.metric)
			if err != nil {
				return fmt.Errorf("cannot unmarshal metric: %w", err)
			}
		}
	}
	if v, ok := req["period"]; ok {
		err = json.Unmarshal(v, &r.period)
		if err != nil {
			err = json.Unmarshal(b, &r.period)
			if err != nil {
				return fmt.Errorf("cannot unmarshal period: %w", err)
			}
		}
	}

	return nil
}

// ApiGetMetricsRequest represents the request with all the parameters for the API call.
type ApiGetMetricsRequest struct {
	metric Metric
	period Period
}

// NewApiGetMetricsRequest creates an instance of the ApiGetMetricsRequest to be used for the API call.
func (c *APIClient) NewApiGetMetricsRequest(metric Metric, period Period) ApiGetMetricsRequest {
	return ApiGetMetricsRequest{
		metric: metric,
		period: period,
	}
}

/*
GetMetrics Wraps GetMetricsWithContext using context.Background.

Report the aggregate value of a metric for a selected period of time.

Request can be constructed by NewApiGetMetricsRequest with parameters below.

	@param metric Metric - Metric to report.  For more information about the individual metrics, see the response. To include all metrics, use `*` as the parameter.
	@param period Period - Period over which to aggregate the metrics:  - `minute`. Aggregate the last minute. 1 data point per 10 seconds. - `hour`. Aggregate the last hour. 1 data point per minute. - `day`. Aggregate the last day. 1 data point per 10 minutes. - `week`. Aggregate the last week. 1 data point per hour. - `month`. Aggregate the last month. 1 data point per day.
	@return InfrastructureResponse
*/
func (c *APIClient) GetMetrics(r ApiGetMetricsRequest, opts ...Option) (*InfrastructureResponse, error) {
	return c.GetMetricsWithContext(context.Background(), r, opts...)
}

/*
GetMetrics

Report the aggregate value of a metric for a selected period of time.

Request can be constructed by NewApiGetMetricsRequest with parameters below.

	@param metric Metric - Metric to report.  For more information about the individual metrics, see the response. To include all metrics, use `*` as the parameter.
	@param period Period - Period over which to aggregate the metrics:  - `minute`. Aggregate the last minute. 1 data point per 10 seconds. - `hour`. Aggregate the last hour. 1 data point per minute. - `day`. Aggregate the last day. 1 data point per 10 minutes. - `week`. Aggregate the last week. 1 data point per hour. - `month`. Aggregate the last month. 1 data point per day.
	@return InfrastructureResponse
*/
func (c *APIClient) GetMetricsWithContext(ctx context.Context, r ApiGetMetricsRequest, opts ...Option) (*InfrastructureResponse, error) {
	var (
		postBody    any
		returnValue *InfrastructureResponse
	)

	requestPath := "/1/infrastructure/{metric}/period/{period}"
	requestPath = strings.ReplaceAll(requestPath, "{metric}", url.PathEscape(parameterToString(r.metric)))
	requestPath = strings.ReplaceAll(requestPath, "{period}", url.PathEscape(parameterToString(r.period)))

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetReachabilityRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["clusters"]; ok {
		err = json.Unmarshal(v, &r.clusters)
		if err != nil {
			err = json.Unmarshal(b, &r.clusters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal clusters: %w", err)
			}
		}
	}

	return nil
}

// ApiGetReachabilityRequest represents the request with all the parameters for the API call.
type ApiGetReachabilityRequest struct {
	clusters string
}

// NewApiGetReachabilityRequest creates an instance of the ApiGetReachabilityRequest to be used for the API call.
func (c *APIClient) NewApiGetReachabilityRequest(clusters string) ApiGetReachabilityRequest {
	return ApiGetReachabilityRequest{
		clusters: clusters,
	}
}

/*
GetReachability Wraps GetReachabilityWithContext using context.Background.

Test whether clusters are reachable or not.

Request can be constructed by NewApiGetReachabilityRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return map[string]map[string]bool
*/
func (c *APIClient) GetReachability(r ApiGetReachabilityRequest, opts ...Option) (*map[string]map[string]bool, error) {
	return c.GetReachabilityWithContext(context.Background(), r, opts...)
}

/*
GetReachability

Test whether clusters are reachable or not.

Request can be constructed by NewApiGetReachabilityRequest with parameters below.

	@param clusters string - Subset of clusters, separated by comma.
	@return map[string]map[string]bool
*/
func (c *APIClient) GetReachabilityWithContext(ctx context.Context, r ApiGetReachabilityRequest, opts ...Option) (*map[string]map[string]bool, error) {
	var (
		postBody    any
		returnValue *map[string]map[string]bool
	)

	requestPath := "/1/reachability/{clusters}/probes"
	requestPath = strings.ReplaceAll(requestPath, "{clusters}", url.PathEscape(parameterToString(r.clusters)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.clusters == "" {
		return returnValue, reportError("Parameter `clusters` is required when calling `GetReachability`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetStatus Wraps GetStatusWithContext using context.Background.

Report whether clusters are operational.

The response depends on whether you authenticate your API request.

- With authentication, the response includes the status of the cluster
assigned to your Algolia application.

- Without authentication, the response lists the statuses of all public
Algolia clusters.

Request can be constructed by NewApiGetStatusRequest with parameters below.

	@return StatusResponse
*/
func (c *APIClient) GetStatus(opts ...Option) (*StatusResponse, error) {
	return c.GetStatusWithContext(context.Background(), opts...)
}

/*
GetStatus

Report whether clusters are operational.

The response depends on whether you authenticate your API request.

- With authentication, the response includes the status of the cluster
assigned to your Algolia application.

- Without authentication, the response lists the statuses of all public
Algolia clusters.

Request can be constructed by NewApiGetStatusRequest with parameters below.

	@return StatusResponse
*/
func (c *APIClient) GetStatusWithContext(ctx context.Context, opts ...Option) (*StatusResponse, error) {
	var (
		postBody    any
		returnValue *StatusResponse
	)

	requestPath := "/1/status"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
