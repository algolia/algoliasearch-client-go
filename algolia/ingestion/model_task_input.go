// File generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation.
package ingestion

import (
	"encoding/json"
	"fmt"
)

// TaskInput - Configuration of the task, depending on its type.
type TaskInput struct {
	OnDemandDateUtilsInput *OnDemandDateUtilsInput
	ScheduleDateUtilsInput *ScheduleDateUtilsInput
	StreamingUtilsInput    *StreamingUtilsInput
}

// OnDemandDateUtilsInputAsTaskInput is a convenience function that returns OnDemandDateUtilsInput wrapped in TaskInput.
func OnDemandDateUtilsInputAsTaskInput(v *OnDemandDateUtilsInput) *TaskInput {
	return &TaskInput{
		OnDemandDateUtilsInput: v,
	}
}

// ScheduleDateUtilsInputAsTaskInput is a convenience function that returns ScheduleDateUtilsInput wrapped in TaskInput.
func ScheduleDateUtilsInputAsTaskInput(v *ScheduleDateUtilsInput) *TaskInput {
	return &TaskInput{
		ScheduleDateUtilsInput: v,
	}
}

// StreamingUtilsInputAsTaskInput is a convenience function that returns StreamingUtilsInput wrapped in TaskInput.
func StreamingUtilsInputAsTaskInput(v *StreamingUtilsInput) *TaskInput {
	return &TaskInput{
		StreamingUtilsInput: v,
	}
}

// Unmarshal JSON data into one of the pointers in the struct.
func (dst *TaskInput) UnmarshalJSON(data []byte) error {
	var err error
	// try to unmarshal data into OnDemandDateUtilsInput
	err = newStrictDecoder(data).Decode(&dst.OnDemandDateUtilsInput)
	if err == nil && validateStruct(dst.OnDemandDateUtilsInput) == nil {
		jsonOnDemandDateUtilsInput, _ := json.Marshal(dst.OnDemandDateUtilsInput)
		if string(jsonOnDemandDateUtilsInput) == "{}" { // empty struct
			dst.OnDemandDateUtilsInput = nil
		} else {
			return nil
		}
	} else {
		dst.OnDemandDateUtilsInput = nil
	}

	// try to unmarshal data into ScheduleDateUtilsInput
	err = newStrictDecoder(data).Decode(&dst.ScheduleDateUtilsInput)
	if err == nil && validateStruct(dst.ScheduleDateUtilsInput) == nil {
		jsonScheduleDateUtilsInput, _ := json.Marshal(dst.ScheduleDateUtilsInput)
		if string(jsonScheduleDateUtilsInput) == "{}" { // empty struct
			dst.ScheduleDateUtilsInput = nil
		} else {
			return nil
		}
	} else {
		dst.ScheduleDateUtilsInput = nil
	}

	// try to unmarshal data into StreamingUtilsInput
	err = newStrictDecoder(data).Decode(&dst.StreamingUtilsInput)
	if err == nil && validateStruct(dst.StreamingUtilsInput) == nil {
		jsonStreamingUtilsInput, _ := json.Marshal(dst.StreamingUtilsInput)
		if string(jsonStreamingUtilsInput) == "{}" { // empty struct
			dst.StreamingUtilsInput = nil
		} else {
			return nil
		}
	} else {
		dst.StreamingUtilsInput = nil
	}

	return fmt.Errorf("Data failed to match schemas in oneOf(TaskInput)")
}

// Marshal data from the first non-nil pointers in the struct to JSON.
func (src TaskInput) MarshalJSON() ([]byte, error) {
	if src.OnDemandDateUtilsInput != nil {
		serialized, err := json.Marshal(&src.OnDemandDateUtilsInput)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal one of OnDemandDateUtilsInput of TaskInput: %w", err)
		}

		return serialized, nil
	}

	if src.ScheduleDateUtilsInput != nil {
		serialized, err := json.Marshal(&src.ScheduleDateUtilsInput)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal one of ScheduleDateUtilsInput of TaskInput: %w", err)
		}

		return serialized, nil
	}

	if src.StreamingUtilsInput != nil {
		serialized, err := json.Marshal(&src.StreamingUtilsInput)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal one of StreamingUtilsInput of TaskInput: %w", err)
		}

		return serialized, nil
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance.
func (obj TaskInput) GetActualInstance() any {
	if obj.OnDemandDateUtilsInput != nil {
		return *obj.OnDemandDateUtilsInput
	}

	if obj.ScheduleDateUtilsInput != nil {
		return *obj.ScheduleDateUtilsInput
	}

	if obj.StreamingUtilsInput != nil {
		return *obj.StreamingUtilsInput
	}

	// all schemas are nil
	return nil
}

type NullableTaskInput struct {
	value *TaskInput
	isSet bool
}

func (v NullableTaskInput) Get() *TaskInput {
	return v.value
}

func (v *NullableTaskInput) Set(val *TaskInput) {
	v.value = val
	v.isSet = true
}

func (v NullableTaskInput) IsSet() bool {
	return v.isSet
}

func (v *NullableTaskInput) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTaskInput(val *TaskInput) *NullableTaskInput {
	return &NullableTaskInput{value: val, isSet: true}
}

func (v NullableTaskInput) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value) //nolint:wrapcheck
}

func (v *NullableTaskInput) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value) //nolint:wrapcheck
}
