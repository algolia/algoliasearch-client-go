// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package ingestion

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       queryParameterToString(name),
		value:      queryParameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

func (r *ApiCreateAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationCreate"]; ok {
		err = json.Unmarshal(v, &r.authenticationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter authenticationCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateAuthenticationRequest represents the request with all the parameters for the API call.
type ApiCreateAuthenticationRequest struct {
	authenticationCreate *AuthenticationCreate
}

// NewApiCreateAuthenticationRequest creates an instance of the ApiCreateAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiCreateAuthenticationRequest(authenticationCreate *AuthenticationCreate) ApiCreateAuthenticationRequest {
	return ApiCreateAuthenticationRequest{
		authenticationCreate: authenticationCreate,
	}
}

/*
CreateAuthentication calls the API and returns the raw response from it.

Creates a new authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateAuthenticationRequest with parameters below.

	@param authenticationCreate AuthenticationCreate -
	@return AuthenticationCreateResponse
*/
func (c *APIClient) CreateAuthenticationWithHTTPInfo(ctx context.Context, r ApiCreateAuthenticationRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/authentications"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.authenticationCreate == nil {
		return nil, nil, reportError("Parameter `authenticationCreate` is required when calling `CreateAuthentication`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.authenticationCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CreateAuthentication wraps CreateAuthenticationWithContext using context.Background.

Creates a new authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateAuthenticationRequest with parameters below.

	@param authenticationCreate AuthenticationCreate -
	@return AuthenticationCreateResponse
*/
func (c *APIClient) CreateAuthentication(r ApiCreateAuthenticationRequest, opts ...Option) (*AuthenticationCreateResponse, error) {
	return c.CreateAuthenticationWithContext(context.Background(), r, opts...)
}

/*
CreateAuthentication casts the HTTP response body to a defined struct.

Creates a new authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateAuthenticationRequest with parameters below.

	@param authenticationCreate AuthenticationCreate -
	@return AuthenticationCreateResponse
*/
func (c *APIClient) CreateAuthenticationWithContext(ctx context.Context, r ApiCreateAuthenticationRequest, opts ...Option) (*AuthenticationCreateResponse, error) {
	var returnValue *AuthenticationCreateResponse

	res, resBody, err := c.CreateAuthenticationWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationCreate"]; ok {
		err = json.Unmarshal(v, &r.destinationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter destinationCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateDestinationRequest represents the request with all the parameters for the API call.
type ApiCreateDestinationRequest struct {
	destinationCreate *DestinationCreate
}

// NewApiCreateDestinationRequest creates an instance of the ApiCreateDestinationRequest to be used for the API call.
func (c *APIClient) NewApiCreateDestinationRequest(destinationCreate *DestinationCreate) ApiCreateDestinationRequest {
	return ApiCreateDestinationRequest{
		destinationCreate: destinationCreate,
	}
}

/*
CreateDestination calls the API and returns the raw response from it.

Creates a new destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateDestinationRequest with parameters below.

	@param destinationCreate DestinationCreate -
	@return DestinationCreateResponse
*/
func (c *APIClient) CreateDestinationWithHTTPInfo(ctx context.Context, r ApiCreateDestinationRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/destinations"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.destinationCreate == nil {
		return nil, nil, reportError("Parameter `destinationCreate` is required when calling `CreateDestination`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.destinationCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CreateDestination wraps CreateDestinationWithContext using context.Background.

Creates a new destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateDestinationRequest with parameters below.

	@param destinationCreate DestinationCreate -
	@return DestinationCreateResponse
*/
func (c *APIClient) CreateDestination(r ApiCreateDestinationRequest, opts ...Option) (*DestinationCreateResponse, error) {
	return c.CreateDestinationWithContext(context.Background(), r, opts...)
}

/*
CreateDestination casts the HTTP response body to a defined struct.

Creates a new destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateDestinationRequest with parameters below.

	@param destinationCreate DestinationCreate -
	@return DestinationCreateResponse
*/
func (c *APIClient) CreateDestinationWithContext(ctx context.Context, r ApiCreateDestinationRequest, opts ...Option) (*DestinationCreateResponse, error) {
	var returnValue *DestinationCreateResponse

	res, resBody, err := c.CreateDestinationWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceCreate"]; ok {
		err = json.Unmarshal(v, &r.sourceCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateSourceRequest represents the request with all the parameters for the API call.
type ApiCreateSourceRequest struct {
	sourceCreate *SourceCreate
}

// NewApiCreateSourceRequest creates an instance of the ApiCreateSourceRequest to be used for the API call.
func (c *APIClient) NewApiCreateSourceRequest(sourceCreate *SourceCreate) ApiCreateSourceRequest {
	return ApiCreateSourceRequest{
		sourceCreate: sourceCreate,
	}
}

/*
CreateSource calls the API and returns the raw response from it.

Creates a new source.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceCreateResponse
*/
func (c *APIClient) CreateSourceWithHTTPInfo(ctx context.Context, r ApiCreateSourceRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/sources"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.sourceCreate == nil {
		return nil, nil, reportError("Parameter `sourceCreate` is required when calling `CreateSource`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.sourceCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CreateSource wraps CreateSourceWithContext using context.Background.

Creates a new source.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceCreateResponse
*/
func (c *APIClient) CreateSource(r ApiCreateSourceRequest, opts ...Option) (*SourceCreateResponse, error) {
	return c.CreateSourceWithContext(context.Background(), r, opts...)
}

/*
CreateSource casts the HTTP response body to a defined struct.

Creates a new source.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceCreateResponse
*/
func (c *APIClient) CreateSourceWithContext(ctx context.Context, r ApiCreateSourceRequest, opts ...Option) (*SourceCreateResponse, error) {
	var returnValue *SourceCreateResponse

	res, resBody, err := c.CreateSourceWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskCreate"]; ok {
		err = json.Unmarshal(v, &r.taskCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateTaskRequest represents the request with all the parameters for the API call.
type ApiCreateTaskRequest struct {
	taskCreate *TaskCreate
}

// NewApiCreateTaskRequest creates an instance of the ApiCreateTaskRequest to be used for the API call.
func (c *APIClient) NewApiCreateTaskRequest(taskCreate *TaskCreate) ApiCreateTaskRequest {
	return ApiCreateTaskRequest{
		taskCreate: taskCreate,
	}
}

/*
CreateTask calls the API and returns the raw response from it.

Creates a new task.

Request can be constructed by NewApiCreateTaskRequest with parameters below.

	@param taskCreate TaskCreate - Request body for creating a task.
	@return TaskCreateResponse
*/
func (c *APIClient) CreateTaskWithHTTPInfo(ctx context.Context, r ApiCreateTaskRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/tasks"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.taskCreate == nil {
		return nil, nil, reportError("Parameter `taskCreate` is required when calling `CreateTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.taskCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CreateTask wraps CreateTaskWithContext using context.Background.

Creates a new task.

Request can be constructed by NewApiCreateTaskRequest with parameters below.

	@param taskCreate TaskCreate - Request body for creating a task.
	@return TaskCreateResponse
*/
func (c *APIClient) CreateTask(r ApiCreateTaskRequest, opts ...Option) (*TaskCreateResponse, error) {
	return c.CreateTaskWithContext(context.Background(), r, opts...)
}

/*
CreateTask casts the HTTP response body to a defined struct.

Creates a new task.

Request can be constructed by NewApiCreateTaskRequest with parameters below.

	@param taskCreate TaskCreate - Request body for creating a task.
	@return TaskCreateResponse
*/
func (c *APIClient) CreateTaskWithContext(ctx context.Context, r ApiCreateTaskRequest, opts ...Option) (*TaskCreateResponse, error) {
	var returnValue *TaskCreateResponse

	res, resBody, err := c.CreateTaskWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationCreate"]; ok {
		err = json.Unmarshal(v, &r.transformationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateTransformationRequest represents the request with all the parameters for the API call.
type ApiCreateTransformationRequest struct {
	transformationCreate *TransformationCreate
}

// NewApiCreateTransformationRequest creates an instance of the ApiCreateTransformationRequest to be used for the API call.
func (c *APIClient) NewApiCreateTransformationRequest(transformationCreate *TransformationCreate) ApiCreateTransformationRequest {
	return ApiCreateTransformationRequest{
		transformationCreate: transformationCreate,
	}
}

/*
CreateTransformation calls the API and returns the raw response from it.

Creates a new transformation.

Request can be constructed by NewApiCreateTransformationRequest with parameters below.

	@param transformationCreate TransformationCreate - Request body for creating a transformation.
	@return TransformationCreateResponse
*/
func (c *APIClient) CreateTransformationWithHTTPInfo(ctx context.Context, r ApiCreateTransformationRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/transformations"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.transformationCreate == nil {
		return nil, nil, reportError("Parameter `transformationCreate` is required when calling `CreateTransformation`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.transformationCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CreateTransformation wraps CreateTransformationWithContext using context.Background.

Creates a new transformation.

Request can be constructed by NewApiCreateTransformationRequest with parameters below.

	@param transformationCreate TransformationCreate - Request body for creating a transformation.
	@return TransformationCreateResponse
*/
func (c *APIClient) CreateTransformation(r ApiCreateTransformationRequest, opts ...Option) (*TransformationCreateResponse, error) {
	return c.CreateTransformationWithContext(context.Background(), r, opts...)
}

/*
CreateTransformation casts the HTTP response body to a defined struct.

Creates a new transformation.

Request can be constructed by NewApiCreateTransformationRequest with parameters below.

	@param transformationCreate TransformationCreate - Request body for creating a transformation.
	@return TransformationCreateResponse
*/
func (c *APIClient) CreateTransformationWithContext(ctx context.Context, r ApiCreateTransformationRequest, opts ...Option) (*TransformationCreateResponse, error) {
	var returnValue *TransformationCreateResponse

	res, resBody, err := c.CreateTransformationWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomDeleteRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomDeleteRequest represents the request with all the parameters for the API call.
type ApiCustomDeleteRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomDeleteRequest creates an instance of the ApiCustomDeleteRequest to be used for the API call.
func (c *APIClient) NewApiCustomDeleteRequest(path string) ApiCustomDeleteRequest {
	return ApiCustomDeleteRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomDeleteRequest and returns the request for chaining.
func (r ApiCustomDeleteRequest) WithParameters(parameters map[string]any) ApiCustomDeleteRequest {
	r.parameters = parameters
	return r
}

/*
CustomDelete calls the API and returns the raw response from it.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomDeleteWithHTTPInfo(ctx context.Context, r ApiCustomDeleteRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomDelete wraps CustomDeleteWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomDelete(r ApiCustomDeleteRequest, opts ...Option) (*map[string]any, error) {
	return c.CustomDeleteWithContext(context.Background(), r, opts...)
}

/*
CustomDelete casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomDeleteWithContext(ctx context.Context, r ApiCustomDeleteRequest, opts ...Option) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomGetRequest represents the request with all the parameters for the API call.
type ApiCustomGetRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomGetRequest creates an instance of the ApiCustomGetRequest to be used for the API call.
func (c *APIClient) NewApiCustomGetRequest(path string) ApiCustomGetRequest {
	return ApiCustomGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomGetRequest and returns the request for chaining.
func (r ApiCustomGetRequest) WithParameters(parameters map[string]any) ApiCustomGetRequest {
	r.parameters = parameters
	return r
}

/*
CustomGet calls the API and returns the raw response from it.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomGetWithHTTPInfo(ctx context.Context, r ApiCustomGetRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomGet wraps CustomGetWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomGet(r ApiCustomGetRequest, opts ...Option) (*map[string]any, error) {
	return c.CustomGetWithContext(context.Background(), r, opts...)
}

/*
CustomGet casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomGetWithContext(ctx context.Context, r ApiCustomGetRequest, opts ...Option) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPostRequest represents the request with all the parameters for the API call.
type ApiCustomPostRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPostRequest creates an instance of the ApiCustomPostRequest to be used for the API call.
func (c *APIClient) NewApiCustomPostRequest(path string) ApiCustomPostRequest {
	return ApiCustomPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithParameters(parameters map[string]any) ApiCustomPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithBody(body map[string]any) ApiCustomPostRequest {
	r.body = body
	return r
}

/*
CustomPost calls the API and returns the raw response from it.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPostWithHTTPInfo(ctx context.Context, r ApiCustomPostRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomPost wraps CustomPostWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPost(r ApiCustomPostRequest, opts ...Option) (*map[string]any, error) {
	return c.CustomPostWithContext(context.Background(), r, opts...)
}

/*
CustomPost casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPostWithContext(ctx context.Context, r ApiCustomPostRequest, opts ...Option) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPutRequest represents the request with all the parameters for the API call.
type ApiCustomPutRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPutRequest creates an instance of the ApiCustomPutRequest to be used for the API call.
func (c *APIClient) NewApiCustomPutRequest(path string) ApiCustomPutRequest {
	return ApiCustomPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithParameters(parameters map[string]any) ApiCustomPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithBody(body map[string]any) ApiCustomPutRequest {
	r.body = body
	return r
}

/*
CustomPut calls the API and returns the raw response from it.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPutWithHTTPInfo(ctx context.Context, r ApiCustomPutRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomPut wraps CustomPutWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPut(r ApiCustomPutRequest, opts ...Option) (*map[string]any, error) {
	return c.CustomPutWithContext(context.Background(), r, opts...)
}

/*
CustomPut casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPutWithContext(ctx context.Context, r ApiCustomPutRequest, opts ...Option) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteAuthenticationRequest represents the request with all the parameters for the API call.
type ApiDeleteAuthenticationRequest struct {
	authenticationID string
}

// NewApiDeleteAuthenticationRequest creates an instance of the ApiDeleteAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteAuthenticationRequest(authenticationID string) ApiDeleteAuthenticationRequest {
	return ApiDeleteAuthenticationRequest{
		authenticationID: authenticationID,
	}
}

/*
DeleteAuthentication calls the API and returns the raw response from it.

Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return DeleteResponse
*/
func (c *APIClient) DeleteAuthenticationWithHTTPInfo(ctx context.Context, r ApiDeleteAuthenticationRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(parameterToString(r.authenticationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.authenticationID == "" {
		return nil, nil, reportError("Parameter `authenticationID` is required when calling `DeleteAuthentication`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteAuthentication wraps DeleteAuthenticationWithContext using context.Background.

Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return DeleteResponse
*/
func (c *APIClient) DeleteAuthentication(r ApiDeleteAuthenticationRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteAuthenticationWithContext(context.Background(), r, opts...)
}

/*
DeleteAuthentication casts the HTTP response body to a defined struct.

Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return DeleteResponse
*/
func (c *APIClient) DeleteAuthenticationWithContext(ctx context.Context, r ApiDeleteAuthenticationRequest, opts ...Option) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteAuthenticationWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteDestinationRequest represents the request with all the parameters for the API call.
type ApiDeleteDestinationRequest struct {
	destinationID string
}

// NewApiDeleteDestinationRequest creates an instance of the ApiDeleteDestinationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteDestinationRequest(destinationID string) ApiDeleteDestinationRequest {
	return ApiDeleteDestinationRequest{
		destinationID: destinationID,
	}
}

/*
DeleteDestination calls the API and returns the raw response from it.

Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return DeleteResponse
*/
func (c *APIClient) DeleteDestinationWithHTTPInfo(ctx context.Context, r ApiDeleteDestinationRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(parameterToString(r.destinationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `DeleteDestination`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteDestination wraps DeleteDestinationWithContext using context.Background.

Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return DeleteResponse
*/
func (c *APIClient) DeleteDestination(r ApiDeleteDestinationRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteDestinationWithContext(context.Background(), r, opts...)
}

/*
DeleteDestination casts the HTTP response body to a defined struct.

Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return DeleteResponse
*/
func (c *APIClient) DeleteDestinationWithContext(ctx context.Context, r ApiDeleteDestinationRequest, opts ...Option) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteDestinationWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteSourceRequest represents the request with all the parameters for the API call.
type ApiDeleteSourceRequest struct {
	sourceID string
}

// NewApiDeleteSourceRequest creates an instance of the ApiDeleteSourceRequest to be used for the API call.
func (c *APIClient) NewApiDeleteSourceRequest(sourceID string) ApiDeleteSourceRequest {
	return ApiDeleteSourceRequest{
		sourceID: sourceID,
	}
}

/*
DeleteSource calls the API and returns the raw response from it.

Deletes a source by its ID. You can't delete sources that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return DeleteResponse
*/
func (c *APIClient) DeleteSourceWithHTTPInfo(ctx context.Context, r ApiDeleteSourceRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(parameterToString(r.sourceID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `DeleteSource`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteSource wraps DeleteSourceWithContext using context.Background.

Deletes a source by its ID. You can't delete sources that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return DeleteResponse
*/
func (c *APIClient) DeleteSource(r ApiDeleteSourceRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteSourceWithContext(context.Background(), r, opts...)
}

/*
DeleteSource casts the HTTP response body to a defined struct.

Deletes a source by its ID. You can't delete sources that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return DeleteResponse
*/
func (c *APIClient) DeleteSourceWithContext(ctx context.Context, r ApiDeleteSourceRequest, opts ...Option) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteSourceWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteTaskRequest represents the request with all the parameters for the API call.
type ApiDeleteTaskRequest struct {
	taskID string
}

// NewApiDeleteTaskRequest creates an instance of the ApiDeleteTaskRequest to be used for the API call.
func (c *APIClient) NewApiDeleteTaskRequest(taskID string) ApiDeleteTaskRequest {
	return ApiDeleteTaskRequest{
		taskID: taskID,
	}
}

/*
DeleteTask calls the API and returns the raw response from it.

Deletes a task by its ID.

Request can be constructed by NewApiDeleteTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTaskWithHTTPInfo(ctx context.Context, r ApiDeleteTaskRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DeleteTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteTask wraps DeleteTaskWithContext using context.Background.

Deletes a task by its ID.

Request can be constructed by NewApiDeleteTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTask(r ApiDeleteTaskRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteTaskWithContext(context.Background(), r, opts...)
}

/*
DeleteTask casts the HTTP response body to a defined struct.

Deletes a task by its ID.

Request can be constructed by NewApiDeleteTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTaskWithContext(ctx context.Context, r ApiDeleteTaskRequest, opts ...Option) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteTaskWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationID"]; ok {
		err = json.Unmarshal(v, &r.transformationID)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteTransformationRequest represents the request with all the parameters for the API call.
type ApiDeleteTransformationRequest struct {
	transformationID string
}

// NewApiDeleteTransformationRequest creates an instance of the ApiDeleteTransformationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteTransformationRequest(transformationID string) ApiDeleteTransformationRequest {
	return ApiDeleteTransformationRequest{
		transformationID: transformationID,
	}
}

/*
DeleteTransformation calls the API and returns the raw response from it.

Deletes a transformation by its ID.

Request can be constructed by NewApiDeleteTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTransformationWithHTTPInfo(ctx context.Context, r ApiDeleteTransformationRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/transformations/{transformationID}"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(parameterToString(r.transformationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `DeleteTransformation`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteTransformation wraps DeleteTransformationWithContext using context.Background.

Deletes a transformation by its ID.

Request can be constructed by NewApiDeleteTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTransformation(r ApiDeleteTransformationRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteTransformationWithContext(context.Background(), r, opts...)
}

/*
DeleteTransformation casts the HTTP response body to a defined struct.

Deletes a transformation by its ID.

Request can be constructed by NewApiDeleteTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTransformationWithContext(ctx context.Context, r ApiDeleteTransformationRequest, opts ...Option) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteTransformationWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDisableTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiDisableTaskRequest represents the request with all the parameters for the API call.
type ApiDisableTaskRequest struct {
	taskID string
}

// NewApiDisableTaskRequest creates an instance of the ApiDisableTaskRequest to be used for the API call.
func (c *APIClient) NewApiDisableTaskRequest(taskID string) ApiDisableTaskRequest {
	return ApiDisableTaskRequest{
		taskID: taskID,
	}
}

/*
DisableTask calls the API and returns the raw response from it.

Disables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDisableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) DisableTaskWithHTTPInfo(ctx context.Context, r ApiDisableTaskRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/tasks/{taskID}/disable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DisableTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DisableTask wraps DisableTaskWithContext using context.Background.

Disables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDisableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) DisableTask(r ApiDisableTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	return c.DisableTaskWithContext(context.Background(), r, opts...)
}

/*
DisableTask casts the HTTP response body to a defined struct.

Disables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDisableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) DisableTaskWithContext(ctx context.Context, r ApiDisableTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.DisableTaskWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiEnableTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiEnableTaskRequest represents the request with all the parameters for the API call.
type ApiEnableTaskRequest struct {
	taskID string
}

// NewApiEnableTaskRequest creates an instance of the ApiEnableTaskRequest to be used for the API call.
func (c *APIClient) NewApiEnableTaskRequest(taskID string) ApiEnableTaskRequest {
	return ApiEnableTaskRequest{
		taskID: taskID,
	}
}

/*
EnableTask calls the API and returns the raw response from it.

Enables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiEnableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) EnableTaskWithHTTPInfo(ctx context.Context, r ApiEnableTaskRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/tasks/{taskID}/enable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `EnableTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
EnableTask wraps EnableTaskWithContext using context.Background.

Enables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiEnableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) EnableTask(r ApiEnableTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	return c.EnableTaskWithContext(context.Background(), r, opts...)
}

/*
EnableTask casts the HTTP response body to a defined struct.

Enables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiEnableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) EnableTaskWithContext(ctx context.Context, r ApiEnableTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.EnableTaskWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetAuthenticationRequest represents the request with all the parameters for the API call.
type ApiGetAuthenticationRequest struct {
	authenticationID string
}

// NewApiGetAuthenticationRequest creates an instance of the ApiGetAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiGetAuthenticationRequest(authenticationID string) ApiGetAuthenticationRequest {
	return ApiGetAuthenticationRequest{
		authenticationID: authenticationID,
	}
}

/*
GetAuthentication calls the API and returns the raw response from it.

Retrieves an authentication resource by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return Authentication
*/
func (c *APIClient) GetAuthenticationWithHTTPInfo(ctx context.Context, r ApiGetAuthenticationRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(parameterToString(r.authenticationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.authenticationID == "" {
		return nil, nil, reportError("Parameter `authenticationID` is required when calling `GetAuthentication`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetAuthentication wraps GetAuthenticationWithContext using context.Background.

Retrieves an authentication resource by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return Authentication
*/
func (c *APIClient) GetAuthentication(r ApiGetAuthenticationRequest, opts ...Option) (*Authentication, error) {
	return c.GetAuthenticationWithContext(context.Background(), r, opts...)
}

/*
GetAuthentication casts the HTTP response body to a defined struct.

Retrieves an authentication resource by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return Authentication
*/
func (c *APIClient) GetAuthenticationWithContext(ctx context.Context, r ApiGetAuthenticationRequest, opts ...Option) (*Authentication, error) {
	var returnValue *Authentication

	res, resBody, err := c.GetAuthenticationWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetAuthenticationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["platform"]; ok {
		err = json.Unmarshal(v, &r.platform)
		if err != nil {
			err = json.Unmarshal(b, &r.platform)
			if err != nil {
				return fmt.Errorf("cannot unmarshal platform: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiGetAuthenticationsRequest represents the request with all the parameters for the API call.
type ApiGetAuthenticationsRequest struct {
	itemsPerPage *int32
	page         *int32
	type_        []AuthenticationType
	platform     []PlatformWithNone
	sort         AuthenticationSortKeys
	order        OrderKeys
}

// NewApiGetAuthenticationsRequest creates an instance of the ApiGetAuthenticationsRequest to be used for the API call.
func (c *APIClient) NewApiGetAuthenticationsRequest() ApiGetAuthenticationsRequest {
	return ApiGetAuthenticationsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithItemsPerPage(itemsPerPage int32) ApiGetAuthenticationsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithPage(page int32) ApiGetAuthenticationsRequest {
	r.page = &page
	return r
}

// WithType adds the type_ to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithType(type_ []AuthenticationType) ApiGetAuthenticationsRequest {
	r.type_ = type_
	return r
}

// WithPlatform adds the platform to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithPlatform(platform []PlatformWithNone) ApiGetAuthenticationsRequest {
	r.platform = platform
	return r
}

// WithSort adds the sort to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithSort(sort AuthenticationSortKeys) ApiGetAuthenticationsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithOrder(order OrderKeys) ApiGetAuthenticationsRequest {
	r.order = order
	return r
}

/*
GetAuthentications calls the API and returns the raw response from it.

Retrieves a list of all authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetAuthenticationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []AuthenticationType - Type of authentication resource to retrieve.
	@param platform []PlatformWithNone - Ecommerce platform for which to retrieve authentication resources.
	@param sort AuthenticationSortKeys - Property by which to sort the list of authentication resources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListAuthenticationsResponse
*/
func (c *APIClient) GetAuthenticationsWithHTTPInfo(ctx context.Context, r ApiGetAuthenticationsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/authentications"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", queryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		queryParams.Set("type", queryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.platform) {
		queryParams.Set("platform", queryParameterToString(r.platform))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetAuthentications wraps GetAuthenticationsWithContext using context.Background.

Retrieves a list of all authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetAuthenticationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []AuthenticationType - Type of authentication resource to retrieve.
	@param platform []PlatformWithNone - Ecommerce platform for which to retrieve authentication resources.
	@param sort AuthenticationSortKeys - Property by which to sort the list of authentication resources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListAuthenticationsResponse
*/
func (c *APIClient) GetAuthentications(r ApiGetAuthenticationsRequest, opts ...Option) (*ListAuthenticationsResponse, error) {
	return c.GetAuthenticationsWithContext(context.Background(), r, opts...)
}

/*
GetAuthentications casts the HTTP response body to a defined struct.

Retrieves a list of all authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetAuthenticationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []AuthenticationType - Type of authentication resource to retrieve.
	@param platform []PlatformWithNone - Ecommerce platform for which to retrieve authentication resources.
	@param sort AuthenticationSortKeys - Property by which to sort the list of authentication resources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListAuthenticationsResponse
*/
func (c *APIClient) GetAuthenticationsWithContext(ctx context.Context, r ApiGetAuthenticationsRequest, opts ...Option) (*ListAuthenticationsResponse, error) {
	var returnValue *ListAuthenticationsResponse

	res, resBody, err := c.GetAuthenticationsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetDestinationRequest represents the request with all the parameters for the API call.
type ApiGetDestinationRequest struct {
	destinationID string
}

// NewApiGetDestinationRequest creates an instance of the ApiGetDestinationRequest to be used for the API call.
func (c *APIClient) NewApiGetDestinationRequest(destinationID string) ApiGetDestinationRequest {
	return ApiGetDestinationRequest{
		destinationID: destinationID,
	}
}

/*
GetDestination calls the API and returns the raw response from it.

Retrieves a destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return Destination
*/
func (c *APIClient) GetDestinationWithHTTPInfo(ctx context.Context, r ApiGetDestinationRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(parameterToString(r.destinationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `GetDestination`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetDestination wraps GetDestinationWithContext using context.Background.

Retrieves a destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return Destination
*/
func (c *APIClient) GetDestination(r ApiGetDestinationRequest, opts ...Option) (*Destination, error) {
	return c.GetDestinationWithContext(context.Background(), r, opts...)
}

/*
GetDestination casts the HTTP response body to a defined struct.

Retrieves a destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return Destination
*/
func (c *APIClient) GetDestinationWithContext(ctx context.Context, r ApiGetDestinationRequest, opts ...Option) (*Destination, error) {
	var returnValue *Destination

	res, resBody, err := c.GetDestinationWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetDestinationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiGetDestinationsRequest represents the request with all the parameters for the API call.
type ApiGetDestinationsRequest struct {
	itemsPerPage     *int32
	page             *int32
	type_            []DestinationType
	authenticationID []string
	sort             DestinationSortKeys
	order            OrderKeys
}

// NewApiGetDestinationsRequest creates an instance of the ApiGetDestinationsRequest to be used for the API call.
func (c *APIClient) NewApiGetDestinationsRequest() ApiGetDestinationsRequest {
	return ApiGetDestinationsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithItemsPerPage(itemsPerPage int32) ApiGetDestinationsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithPage(page int32) ApiGetDestinationsRequest {
	r.page = &page
	return r
}

// WithType adds the type_ to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithType(type_ []DestinationType) ApiGetDestinationsRequest {
	r.type_ = type_
	return r
}

// WithAuthenticationID adds the authenticationID to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithAuthenticationID(authenticationID []string) ApiGetDestinationsRequest {
	r.authenticationID = authenticationID
	return r
}

// WithSort adds the sort to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithSort(sort DestinationSortKeys) ApiGetDestinationsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithOrder(order OrderKeys) ApiGetDestinationsRequest {
	r.order = order
	return r
}

/*
GetDestinations calls the API and returns the raw response from it.

Retrieves a list of destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDestinationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []DestinationType - Destination type.
	@param authenticationID []string - Authentication ID used by destinations.
	@param sort DestinationSortKeys - Property by which to sort the destinations.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListDestinationsResponse
*/
func (c *APIClient) GetDestinationsWithHTTPInfo(ctx context.Context, r ApiGetDestinationsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/destinations"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", queryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		queryParams.Set("type", queryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.authenticationID) {
		queryParams.Set("authenticationID", queryParameterToString(r.authenticationID))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetDestinations wraps GetDestinationsWithContext using context.Background.

Retrieves a list of destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDestinationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []DestinationType - Destination type.
	@param authenticationID []string - Authentication ID used by destinations.
	@param sort DestinationSortKeys - Property by which to sort the destinations.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListDestinationsResponse
*/
func (c *APIClient) GetDestinations(r ApiGetDestinationsRequest, opts ...Option) (*ListDestinationsResponse, error) {
	return c.GetDestinationsWithContext(context.Background(), r, opts...)
}

/*
GetDestinations casts the HTTP response body to a defined struct.

Retrieves a list of destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDestinationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []DestinationType - Destination type.
	@param authenticationID []string - Authentication ID used by destinations.
	@param sort DestinationSortKeys - Property by which to sort the destinations.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListDestinationsResponse
*/
func (c *APIClient) GetDestinationsWithContext(ctx context.Context, r ApiGetDestinationsRequest, opts ...Option) (*ListDestinationsResponse, error) {
	var returnValue *ListDestinationsResponse

	res, resBody, err := c.GetDestinationsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetEventRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runID: %w", err)
			}
		}
	}
	if v, ok := req["eventID"]; ok {
		err = json.Unmarshal(v, &r.eventID)
		if err != nil {
			err = json.Unmarshal(b, &r.eventID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal eventID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetEventRequest represents the request with all the parameters for the API call.
type ApiGetEventRequest struct {
	runID   string
	eventID string
}

// NewApiGetEventRequest creates an instance of the ApiGetEventRequest to be used for the API call.
func (c *APIClient) NewApiGetEventRequest(runID string, eventID string) ApiGetEventRequest {
	return ApiGetEventRequest{
		runID:   runID,
		eventID: eventID,
	}
}

/*
GetEvent calls the API and returns the raw response from it.

Retrieves a single task run event by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetEventRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param eventID string - Unique identifier of an event.
	@return Event
*/
func (c *APIClient) GetEventWithHTTPInfo(ctx context.Context, r ApiGetEventRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/runs/{runID}/events/{eventID}"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(parameterToString(r.runID)))
	requestPath = strings.ReplaceAll(requestPath, "{eventID}", url.PathEscape(parameterToString(r.eventID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.runID == "" {
		return nil, nil, reportError("Parameter `runID` is required when calling `GetEvent`.")
	}
	if r.eventID == "" {
		return nil, nil, reportError("Parameter `eventID` is required when calling `GetEvent`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetEvent wraps GetEventWithContext using context.Background.

Retrieves a single task run event by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetEventRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param eventID string - Unique identifier of an event.
	@return Event
*/
func (c *APIClient) GetEvent(r ApiGetEventRequest, opts ...Option) (*Event, error) {
	return c.GetEventWithContext(context.Background(), r, opts...)
}

/*
GetEvent casts the HTTP response body to a defined struct.

Retrieves a single task run event by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetEventRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param eventID string - Unique identifier of an event.
	@return Event
*/
func (c *APIClient) GetEventWithContext(ctx context.Context, r ApiGetEventRequest, opts ...Option) (*Event, error) {
	var returnValue *Event

	res, resBody, err := c.GetEventWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetEventsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runID: %w", err)
			}
		}
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["status"]; ok {
		err = json.Unmarshal(v, &r.status)
		if err != nil {
			err = json.Unmarshal(b, &r.status)
			if err != nil {
				return fmt.Errorf("cannot unmarshal status: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}

	return nil
}

// ApiGetEventsRequest represents the request with all the parameters for the API call.
type ApiGetEventsRequest struct {
	runID        string
	itemsPerPage *int32
	page         *int32
	status       []EventStatus
	type_        []EventType
	sort         EventSortKeys
	order        OrderKeys
	startDate    *string
	endDate      *string
}

// NewApiGetEventsRequest creates an instance of the ApiGetEventsRequest to be used for the API call.
func (c *APIClient) NewApiGetEventsRequest(runID string) ApiGetEventsRequest {
	return ApiGetEventsRequest{
		runID: runID,
	}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithItemsPerPage(itemsPerPage int32) ApiGetEventsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithPage(page int32) ApiGetEventsRequest {
	r.page = &page
	return r
}

// WithStatus adds the status to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithStatus(status []EventStatus) ApiGetEventsRequest {
	r.status = status
	return r
}

// WithType adds the type_ to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithType(type_ []EventType) ApiGetEventsRequest {
	r.type_ = type_
	return r
}

// WithSort adds the sort to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithSort(sort EventSortKeys) ApiGetEventsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithOrder(order OrderKeys) ApiGetEventsRequest {
	r.order = order
	return r
}

// WithStartDate adds the startDate to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithStartDate(startDate string) ApiGetEventsRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithEndDate(endDate string) ApiGetEventsRequest {
	r.endDate = &endDate
	return r
}

/*
GetEvents calls the API and returns the raw response from it.

Retrieves a list of events for a task run, identified by it's ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetEventsRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []EventStatus - Event status for filtering the list of task runs.
	@param type_ []EventType - Event type for filtering the list of task runs.
	@param sort EventSortKeys - Property by which to sort the list of task run events.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
	@param endDate string - Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used.
	@return ListEventsResponse
*/
func (c *APIClient) GetEventsWithHTTPInfo(ctx context.Context, r ApiGetEventsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/runs/{runID}/events"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(parameterToString(r.runID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.runID == "" {
		return nil, nil, reportError("Parameter `runID` is required when calling `GetEvents`.")
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", queryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.status) {
		queryParams.Set("status", queryParameterToString(r.status))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		queryParams.Set("type", queryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", queryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", queryParameterToString(*r.endDate))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetEvents wraps GetEventsWithContext using context.Background.

Retrieves a list of events for a task run, identified by it's ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetEventsRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []EventStatus - Event status for filtering the list of task runs.
	@param type_ []EventType - Event type for filtering the list of task runs.
	@param sort EventSortKeys - Property by which to sort the list of task run events.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
	@param endDate string - Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used.
	@return ListEventsResponse
*/
func (c *APIClient) GetEvents(r ApiGetEventsRequest, opts ...Option) (*ListEventsResponse, error) {
	return c.GetEventsWithContext(context.Background(), r, opts...)
}

/*
GetEvents casts the HTTP response body to a defined struct.

Retrieves a list of events for a task run, identified by it's ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetEventsRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []EventStatus - Event status for filtering the list of task runs.
	@param type_ []EventType - Event type for filtering the list of task runs.
	@param sort EventSortKeys - Property by which to sort the list of task run events.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
	@param endDate string - Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used.
	@return ListEventsResponse
*/
func (c *APIClient) GetEventsWithContext(ctx context.Context, r ApiGetEventsRequest, opts ...Option) (*ListEventsResponse, error) {
	var returnValue *ListEventsResponse

	res, resBody, err := c.GetEventsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRunRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetRunRequest represents the request with all the parameters for the API call.
type ApiGetRunRequest struct {
	runID string
}

// NewApiGetRunRequest creates an instance of the ApiGetRunRequest to be used for the API call.
func (c *APIClient) NewApiGetRunRequest(runID string) ApiGetRunRequest {
	return ApiGetRunRequest{
		runID: runID,
	}
}

/*
GetRun calls the API and returns the raw response from it.

Retrieve a single task run by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetRunRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@return Run
*/
func (c *APIClient) GetRunWithHTTPInfo(ctx context.Context, r ApiGetRunRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/runs/{runID}"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(parameterToString(r.runID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.runID == "" {
		return nil, nil, reportError("Parameter `runID` is required when calling `GetRun`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetRun wraps GetRunWithContext using context.Background.

Retrieve a single task run by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetRunRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@return Run
*/
func (c *APIClient) GetRun(r ApiGetRunRequest, opts ...Option) (*Run, error) {
	return c.GetRunWithContext(context.Background(), r, opts...)
}

/*
GetRun casts the HTTP response body to a defined struct.

Retrieve a single task run by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetRunRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@return Run
*/
func (c *APIClient) GetRunWithContext(ctx context.Context, r ApiGetRunRequest, opts ...Option) (*Run, error) {
	var returnValue *Run

	res, resBody, err := c.GetRunWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRunsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["status"]; ok {
		err = json.Unmarshal(v, &r.status)
		if err != nil {
			err = json.Unmarshal(b, &r.status)
			if err != nil {
				return fmt.Errorf("cannot unmarshal status: %w", err)
			}
		}
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}

	return nil
}

// ApiGetRunsRequest represents the request with all the parameters for the API call.
type ApiGetRunsRequest struct {
	itemsPerPage *int32
	page         *int32
	status       []RunStatus
	taskID       *string
	sort         RunSortKeys
	order        OrderKeys
	startDate    *string
	endDate      *string
}

// NewApiGetRunsRequest creates an instance of the ApiGetRunsRequest to be used for the API call.
func (c *APIClient) NewApiGetRunsRequest() ApiGetRunsRequest {
	return ApiGetRunsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithItemsPerPage(itemsPerPage int32) ApiGetRunsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithPage(page int32) ApiGetRunsRequest {
	r.page = &page
	return r
}

// WithStatus adds the status to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithStatus(status []RunStatus) ApiGetRunsRequest {
	r.status = status
	return r
}

// WithTaskID adds the taskID to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithTaskID(taskID string) ApiGetRunsRequest {
	r.taskID = &taskID
	return r
}

// WithSort adds the sort to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithSort(sort RunSortKeys) ApiGetRunsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithOrder(order OrderKeys) ApiGetRunsRequest {
	r.order = order
	return r
}

// WithStartDate adds the startDate to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithStartDate(startDate string) ApiGetRunsRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithEndDate(endDate string) ApiGetRunsRequest {
	r.endDate = &endDate
	return r
}

/*
GetRuns calls the API and returns the raw response from it.

Retrieve a list of task runs.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetRunsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []RunStatus - Run status for filtering the list of task runs.
	@param taskID string - Task ID for filtering the list of task runs.
	@param sort RunSortKeys - Property by which to sort the list of task runs.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
	@param endDate string - Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used.
	@return RunListResponse
*/
func (c *APIClient) GetRunsWithHTTPInfo(ctx context.Context, r ApiGetRunsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/runs"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", queryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.status) {
		queryParams.Set("status", queryParameterToString(r.status))
	}
	if !utils.IsNilOrEmpty(r.taskID) {
		queryParams.Set("taskID", queryParameterToString(*r.taskID))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", queryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", queryParameterToString(*r.endDate))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetRuns wraps GetRunsWithContext using context.Background.

Retrieve a list of task runs.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetRunsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []RunStatus - Run status for filtering the list of task runs.
	@param taskID string - Task ID for filtering the list of task runs.
	@param sort RunSortKeys - Property by which to sort the list of task runs.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
	@param endDate string - Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used.
	@return RunListResponse
*/
func (c *APIClient) GetRuns(r ApiGetRunsRequest, opts ...Option) (*RunListResponse, error) {
	return c.GetRunsWithContext(context.Background(), r, opts...)
}

/*
GetRuns casts the HTTP response body to a defined struct.

Retrieve a list of task runs.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetRunsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []RunStatus - Run status for filtering the list of task runs.
	@param taskID string - Task ID for filtering the list of task runs.
	@param sort RunSortKeys - Property by which to sort the list of task runs.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
	@param endDate string - Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used.
	@return RunListResponse
*/
func (c *APIClient) GetRunsWithContext(ctx context.Context, r ApiGetRunsRequest, opts ...Option) (*RunListResponse, error) {
	var returnValue *RunListResponse

	res, resBody, err := c.GetRunsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSourceRequest represents the request with all the parameters for the API call.
type ApiGetSourceRequest struct {
	sourceID string
}

// NewApiGetSourceRequest creates an instance of the ApiGetSourceRequest to be used for the API call.
func (c *APIClient) NewApiGetSourceRequest(sourceID string) ApiGetSourceRequest {
	return ApiGetSourceRequest{
		sourceID: sourceID,
	}
}

/*
GetSource calls the API and returns the raw response from it.

Retrieve a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return Source
*/
func (c *APIClient) GetSourceWithHTTPInfo(ctx context.Context, r ApiGetSourceRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(parameterToString(r.sourceID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `GetSource`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetSource wraps GetSourceWithContext using context.Background.

Retrieve a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return Source
*/
func (c *APIClient) GetSource(r ApiGetSourceRequest, opts ...Option) (*Source, error) {
	return c.GetSourceWithContext(context.Background(), r, opts...)
}

/*
GetSource casts the HTTP response body to a defined struct.

Retrieve a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return Source
*/
func (c *APIClient) GetSourceWithContext(ctx context.Context, r ApiGetSourceRequest, opts ...Option) (*Source, error) {
	var returnValue *Source

	res, resBody, err := c.GetSourceWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSourcesRequest represents the request with all the parameters for the API call.
type ApiGetSourcesRequest struct {
	itemsPerPage     *int32
	page             *int32
	type_            []SourceType
	authenticationID []string
	sort             SourceSortKeys
	order            OrderKeys
}

// NewApiGetSourcesRequest creates an instance of the ApiGetSourcesRequest to be used for the API call.
func (c *APIClient) NewApiGetSourcesRequest() ApiGetSourcesRequest {
	return ApiGetSourcesRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithItemsPerPage(itemsPerPage int32) ApiGetSourcesRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithPage(page int32) ApiGetSourcesRequest {
	r.page = &page
	return r
}

// WithType adds the type_ to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithType(type_ []SourceType) ApiGetSourcesRequest {
	r.type_ = type_
	return r
}

// WithAuthenticationID adds the authenticationID to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithAuthenticationID(authenticationID []string) ApiGetSourcesRequest {
	r.authenticationID = authenticationID
	return r
}

// WithSort adds the sort to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithSort(sort SourceSortKeys) ApiGetSourcesRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithOrder(order OrderKeys) ApiGetSourcesRequest {
	r.order = order
	return r
}

/*
GetSources calls the API and returns the raw response from it.

Retrieves a list of sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []SourceType - Source type. Some sources require authentication.
	@param authenticationID []string - Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication resource.
	@param sort SourceSortKeys - Property by which to sort the list of sources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListSourcesResponse
*/
func (c *APIClient) GetSourcesWithHTTPInfo(ctx context.Context, r ApiGetSourcesRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/sources"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", queryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		queryParams.Set("type", queryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.authenticationID) {
		queryParams.Set("authenticationID", queryParameterToString(r.authenticationID))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetSources wraps GetSourcesWithContext using context.Background.

Retrieves a list of sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []SourceType - Source type. Some sources require authentication.
	@param authenticationID []string - Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication resource.
	@param sort SourceSortKeys - Property by which to sort the list of sources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListSourcesResponse
*/
func (c *APIClient) GetSources(r ApiGetSourcesRequest, opts ...Option) (*ListSourcesResponse, error) {
	return c.GetSourcesWithContext(context.Background(), r, opts...)
}

/*
GetSources casts the HTTP response body to a defined struct.

Retrieves a list of sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []SourceType - Source type. Some sources require authentication.
	@param authenticationID []string - Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication resource.
	@param sort SourceSortKeys - Property by which to sort the list of sources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListSourcesResponse
*/
func (c *APIClient) GetSourcesWithContext(ctx context.Context, r ApiGetSourcesRequest, opts ...Option) (*ListSourcesResponse, error) {
	var returnValue *ListSourcesResponse

	res, resBody, err := c.GetSourcesWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTaskRequest represents the request with all the parameters for the API call.
type ApiGetTaskRequest struct {
	taskID string
}

// NewApiGetTaskRequest creates an instance of the ApiGetTaskRequest to be used for the API call.
func (c *APIClient) NewApiGetTaskRequest(taskID string) ApiGetTaskRequest {
	return ApiGetTaskRequest{
		taskID: taskID,
	}
}

/*
GetTask calls the API and returns the raw response from it.

Retrieves a task by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return Task
*/
func (c *APIClient) GetTaskWithHTTPInfo(ctx context.Context, r ApiGetTaskRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `GetTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetTask wraps GetTaskWithContext using context.Background.

Retrieves a task by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return Task
*/
func (c *APIClient) GetTask(r ApiGetTaskRequest, opts ...Option) (*Task, error) {
	return c.GetTaskWithContext(context.Background(), r, opts...)
}

/*
GetTask casts the HTTP response body to a defined struct.

Retrieves a task by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return Task
*/
func (c *APIClient) GetTaskWithContext(ctx context.Context, r ApiGetTaskRequest, opts ...Option) (*Task, error) {
	var returnValue *Task

	res, resBody, err := c.GetTaskWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTasksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["action"]; ok {
		err = json.Unmarshal(v, &r.action)
		if err != nil {
			err = json.Unmarshal(b, &r.action)
			if err != nil {
				return fmt.Errorf("cannot unmarshal action: %w", err)
			}
		}
	}
	if v, ok := req["enabled"]; ok {
		err = json.Unmarshal(v, &r.enabled)
		if err != nil {
			err = json.Unmarshal(b, &r.enabled)
			if err != nil {
				return fmt.Errorf("cannot unmarshal enabled: %w", err)
			}
		}
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}
	if v, ok := req["triggerType"]; ok {
		err = json.Unmarshal(v, &r.triggerType)
		if err != nil {
			err = json.Unmarshal(b, &r.triggerType)
			if err != nil {
				return fmt.Errorf("cannot unmarshal triggerType: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTasksRequest represents the request with all the parameters for the API call.
type ApiGetTasksRequest struct {
	itemsPerPage  *int32
	page          *int32
	action        []ActionType
	enabled       *bool
	sourceID      []string
	destinationID []string
	triggerType   []TriggerType
	sort          TaskSortKeys
	order         OrderKeys
}

// NewApiGetTasksRequest creates an instance of the ApiGetTasksRequest to be used for the API call.
func (c *APIClient) NewApiGetTasksRequest() ApiGetTasksRequest {
	return ApiGetTasksRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithItemsPerPage(itemsPerPage int32) ApiGetTasksRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithPage(page int32) ApiGetTasksRequest {
	r.page = &page
	return r
}

// WithAction adds the action to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithAction(action []ActionType) ApiGetTasksRequest {
	r.action = action
	return r
}

// WithEnabled adds the enabled to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithEnabled(enabled bool) ApiGetTasksRequest {
	r.enabled = &enabled
	return r
}

// WithSourceID adds the sourceID to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithSourceID(sourceID []string) ApiGetTasksRequest {
	r.sourceID = sourceID
	return r
}

// WithDestinationID adds the destinationID to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithDestinationID(destinationID []string) ApiGetTasksRequest {
	r.destinationID = destinationID
	return r
}

// WithTriggerType adds the triggerType to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithTriggerType(triggerType []TriggerType) ApiGetTasksRequest {
	r.triggerType = triggerType
	return r
}

// WithSort adds the sort to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithSort(sort TaskSortKeys) ApiGetTasksRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithOrder(order OrderKeys) ApiGetTasksRequest {
	r.order = order
	return r
}

/*
GetTasks calls the API and returns the raw response from it.

Retrieves a list of tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTasksRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param action []ActionType - Actions for filtering the list of tasks.
	@param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	@param sourceID []string - Source IDs for filtering the list of tasks.
	@param destinationID []string - Destination IDs for filtering the list of tasks.
	@param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	@param sort TaskSortKeys - Property by which to sort the list of tasks.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTasksResponse
*/
func (c *APIClient) GetTasksWithHTTPInfo(ctx context.Context, r ApiGetTasksRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/tasks"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", queryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.action) {
		queryParams.Set("action", queryParameterToString(r.action))
	}
	if !utils.IsNilOrEmpty(r.enabled) {
		queryParams.Set("enabled", queryParameterToString(*r.enabled))
	}
	if !utils.IsNilOrEmpty(r.sourceID) {
		queryParams.Set("sourceID", queryParameterToString(r.sourceID))
	}
	if !utils.IsNilOrEmpty(r.destinationID) {
		queryParams.Set("destinationID", queryParameterToString(r.destinationID))
	}
	if !utils.IsNilOrEmpty(r.triggerType) {
		queryParams.Set("triggerType", queryParameterToString(r.triggerType))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetTasks wraps GetTasksWithContext using context.Background.

Retrieves a list of tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTasksRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param action []ActionType - Actions for filtering the list of tasks.
	@param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	@param sourceID []string - Source IDs for filtering the list of tasks.
	@param destinationID []string - Destination IDs for filtering the list of tasks.
	@param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	@param sort TaskSortKeys - Property by which to sort the list of tasks.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTasksResponse
*/
func (c *APIClient) GetTasks(r ApiGetTasksRequest, opts ...Option) (*ListTasksResponse, error) {
	return c.GetTasksWithContext(context.Background(), r, opts...)
}

/*
GetTasks casts the HTTP response body to a defined struct.

Retrieves a list of tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTasksRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param action []ActionType - Actions for filtering the list of tasks.
	@param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	@param sourceID []string - Source IDs for filtering the list of tasks.
	@param destinationID []string - Destination IDs for filtering the list of tasks.
	@param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	@param sort TaskSortKeys - Property by which to sort the list of tasks.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTasksResponse
*/
func (c *APIClient) GetTasksWithContext(ctx context.Context, r ApiGetTasksRequest, opts ...Option) (*ListTasksResponse, error) {
	var returnValue *ListTasksResponse

	res, resBody, err := c.GetTasksWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationID"]; ok {
		err = json.Unmarshal(v, &r.transformationID)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTransformationRequest represents the request with all the parameters for the API call.
type ApiGetTransformationRequest struct {
	transformationID string
}

// NewApiGetTransformationRequest creates an instance of the ApiGetTransformationRequest to be used for the API call.
func (c *APIClient) NewApiGetTransformationRequest(transformationID string) ApiGetTransformationRequest {
	return ApiGetTransformationRequest{
		transformationID: transformationID,
	}
}

/*
GetTransformation calls the API and returns the raw response from it.

Retrieves a transformation by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@return Transformation
*/
func (c *APIClient) GetTransformationWithHTTPInfo(ctx context.Context, r ApiGetTransformationRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/transformations/{transformationID}"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(parameterToString(r.transformationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `GetTransformation`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetTransformation wraps GetTransformationWithContext using context.Background.

Retrieves a transformation by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@return Transformation
*/
func (c *APIClient) GetTransformation(r ApiGetTransformationRequest, opts ...Option) (*Transformation, error) {
	return c.GetTransformationWithContext(context.Background(), r, opts...)
}

/*
GetTransformation casts the HTTP response body to a defined struct.

Retrieves a transformation by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@return Transformation
*/
func (c *APIClient) GetTransformationWithContext(ctx context.Context, r ApiGetTransformationRequest, opts ...Option) (*Transformation, error) {
	var returnValue *Transformation

	res, resBody, err := c.GetTransformationWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTransformationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTransformationsRequest represents the request with all the parameters for the API call.
type ApiGetTransformationsRequest struct {
	sort  SortKeys
	order OrderKeys
}

// NewApiGetTransformationsRequest creates an instance of the ApiGetTransformationsRequest to be used for the API call.
func (c *APIClient) NewApiGetTransformationsRequest() ApiGetTransformationsRequest {
	return ApiGetTransformationsRequest{}
}

// WithSort adds the sort to the ApiGetTransformationsRequest and returns the request for chaining.
func (r ApiGetTransformationsRequest) WithSort(sort SortKeys) ApiGetTransformationsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetTransformationsRequest and returns the request for chaining.
func (r ApiGetTransformationsRequest) WithOrder(order OrderKeys) ApiGetTransformationsRequest {
	r.order = order
	return r
}

/*
GetTransformations calls the API and returns the raw response from it.

Retrieves a list of transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTransformationsRequest with parameters below.

	@param sort SortKeys - Property by which to sort the list.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTransformationsResponse
*/
func (c *APIClient) GetTransformationsWithHTTPInfo(ctx context.Context, r ApiGetTransformationsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/transformations"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetTransformations wraps GetTransformationsWithContext using context.Background.

Retrieves a list of transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTransformationsRequest with parameters below.

	@param sort SortKeys - Property by which to sort the list.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTransformationsResponse
*/
func (c *APIClient) GetTransformations(r ApiGetTransformationsRequest, opts ...Option) (*ListTransformationsResponse, error) {
	return c.GetTransformationsWithContext(context.Background(), r, opts...)
}

/*
GetTransformations casts the HTTP response body to a defined struct.

Retrieves a list of transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTransformationsRequest with parameters below.

	@param sort SortKeys - Property by which to sort the list.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTransformationsResponse
*/
func (c *APIClient) GetTransformationsWithContext(ctx context.Context, r ApiGetTransformationsRequest, opts ...Option) (*ListTransformationsResponse, error) {
	var returnValue *ListTransformationsResponse

	res, resBody, err := c.GetTransformationsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRunTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiRunTaskRequest represents the request with all the parameters for the API call.
type ApiRunTaskRequest struct {
	taskID string
}

// NewApiRunTaskRequest creates an instance of the ApiRunTaskRequest to be used for the API call.
func (c *APIClient) NewApiRunTaskRequest(taskID string) ApiRunTaskRequest {
	return ApiRunTaskRequest{
		taskID: taskID,
	}
}

/*
RunTask calls the API and returns the raw response from it.

Runs a task. You can check the status of task runs with the observability endpoints.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiRunTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return RunResponse
*/
func (c *APIClient) RunTaskWithHTTPInfo(ctx context.Context, r ApiRunTaskRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/tasks/{taskID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `RunTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
RunTask wraps RunTaskWithContext using context.Background.

Runs a task. You can check the status of task runs with the observability endpoints.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiRunTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return RunResponse
*/
func (c *APIClient) RunTask(r ApiRunTaskRequest, opts ...Option) (*RunResponse, error) {
	return c.RunTaskWithContext(context.Background(), r, opts...)
}

/*
RunTask casts the HTTP response body to a defined struct.

Runs a task. You can check the status of task runs with the observability endpoints.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiRunTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return RunResponse
*/
func (c *APIClient) RunTaskWithContext(ctx context.Context, r ApiRunTaskRequest, opts ...Option) (*RunResponse, error) {
	var returnValue *RunResponse

	res, resBody, err := c.RunTaskWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchAuthenticationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationSearch"]; ok {
		err = json.Unmarshal(v, &r.authenticationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter authenticationSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchAuthenticationsRequest represents the request with all the parameters for the API call.
type ApiSearchAuthenticationsRequest struct {
	authenticationSearch *AuthenticationSearch
}

// NewApiSearchAuthenticationsRequest creates an instance of the ApiSearchAuthenticationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchAuthenticationsRequest(authenticationSearch *AuthenticationSearch) ApiSearchAuthenticationsRequest {
	return ApiSearchAuthenticationsRequest{
		authenticationSearch: authenticationSearch,
	}
}

/*
SearchAuthentications calls the API and returns the raw response from it.

Searches for authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchAuthenticationsRequest with parameters below.

	@param authenticationSearch AuthenticationSearch
	@return []Authentication
*/
func (c *APIClient) SearchAuthenticationsWithHTTPInfo(ctx context.Context, r ApiSearchAuthenticationsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/authentications/search"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.authenticationSearch == nil {
		return nil, nil, reportError("Parameter `authenticationSearch` is required when calling `SearchAuthentications`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.authenticationSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SearchAuthentications wraps SearchAuthenticationsWithContext using context.Background.

Searches for authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchAuthenticationsRequest with parameters below.

	@param authenticationSearch AuthenticationSearch
	@return []Authentication
*/
func (c *APIClient) SearchAuthentications(r ApiSearchAuthenticationsRequest, opts ...Option) ([]Authentication, error) {
	return c.SearchAuthenticationsWithContext(context.Background(), r, opts...)
}

/*
SearchAuthentications casts the HTTP response body to a defined struct.

Searches for authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchAuthenticationsRequest with parameters below.

	@param authenticationSearch AuthenticationSearch
	@return []Authentication
*/
func (c *APIClient) SearchAuthenticationsWithContext(ctx context.Context, r ApiSearchAuthenticationsRequest, opts ...Option) ([]Authentication, error) {
	var returnValue []Authentication

	res, resBody, err := c.SearchAuthenticationsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchDestinationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationSearch"]; ok {
		err = json.Unmarshal(v, &r.destinationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter destinationSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchDestinationsRequest represents the request with all the parameters for the API call.
type ApiSearchDestinationsRequest struct {
	destinationSearch *DestinationSearch
}

// NewApiSearchDestinationsRequest creates an instance of the ApiSearchDestinationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchDestinationsRequest(destinationSearch *DestinationSearch) ApiSearchDestinationsRequest {
	return ApiSearchDestinationsRequest{
		destinationSearch: destinationSearch,
	}
}

/*
SearchDestinations calls the API and returns the raw response from it.

Searches for destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchDestinationsRequest with parameters below.

	@param destinationSearch DestinationSearch
	@return []Destination
*/
func (c *APIClient) SearchDestinationsWithHTTPInfo(ctx context.Context, r ApiSearchDestinationsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/destinations/search"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.destinationSearch == nil {
		return nil, nil, reportError("Parameter `destinationSearch` is required when calling `SearchDestinations`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.destinationSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SearchDestinations wraps SearchDestinationsWithContext using context.Background.

Searches for destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchDestinationsRequest with parameters below.

	@param destinationSearch DestinationSearch
	@return []Destination
*/
func (c *APIClient) SearchDestinations(r ApiSearchDestinationsRequest, opts ...Option) ([]Destination, error) {
	return c.SearchDestinationsWithContext(context.Background(), r, opts...)
}

/*
SearchDestinations casts the HTTP response body to a defined struct.

Searches for destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchDestinationsRequest with parameters below.

	@param destinationSearch DestinationSearch
	@return []Destination
*/
func (c *APIClient) SearchDestinationsWithContext(ctx context.Context, r ApiSearchDestinationsRequest, opts ...Option) ([]Destination, error) {
	var returnValue []Destination

	res, resBody, err := c.SearchDestinationsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceSearch"]; ok {
		err = json.Unmarshal(v, &r.sourceSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchSourcesRequest represents the request with all the parameters for the API call.
type ApiSearchSourcesRequest struct {
	sourceSearch *SourceSearch
}

// NewApiSearchSourcesRequest creates an instance of the ApiSearchSourcesRequest to be used for the API call.
func (c *APIClient) NewApiSearchSourcesRequest(sourceSearch *SourceSearch) ApiSearchSourcesRequest {
	return ApiSearchSourcesRequest{
		sourceSearch: sourceSearch,
	}
}

/*
SearchSources calls the API and returns the raw response from it.

Searches for sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchSourcesRequest with parameters below.

	@param sourceSearch SourceSearch
	@return []Source
*/
func (c *APIClient) SearchSourcesWithHTTPInfo(ctx context.Context, r ApiSearchSourcesRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/sources/search"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.sourceSearch == nil {
		return nil, nil, reportError("Parameter `sourceSearch` is required when calling `SearchSources`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.sourceSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SearchSources wraps SearchSourcesWithContext using context.Background.

Searches for sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchSourcesRequest with parameters below.

	@param sourceSearch SourceSearch
	@return []Source
*/
func (c *APIClient) SearchSources(r ApiSearchSourcesRequest, opts ...Option) ([]Source, error) {
	return c.SearchSourcesWithContext(context.Background(), r, opts...)
}

/*
SearchSources casts the HTTP response body to a defined struct.

Searches for sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchSourcesRequest with parameters below.

	@param sourceSearch SourceSearch
	@return []Source
*/
func (c *APIClient) SearchSourcesWithContext(ctx context.Context, r ApiSearchSourcesRequest, opts ...Option) ([]Source, error) {
	var returnValue []Source

	res, resBody, err := c.SearchSourcesWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchTasksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskSearch"]; ok {
		err = json.Unmarshal(v, &r.taskSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.taskSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchTasksRequest represents the request with all the parameters for the API call.
type ApiSearchTasksRequest struct {
	taskSearch *TaskSearch
}

// NewApiSearchTasksRequest creates an instance of the ApiSearchTasksRequest to be used for the API call.
func (c *APIClient) NewApiSearchTasksRequest(taskSearch *TaskSearch) ApiSearchTasksRequest {
	return ApiSearchTasksRequest{
		taskSearch: taskSearch,
	}
}

/*
SearchTasks calls the API and returns the raw response from it.

Searches for tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTasksRequest with parameters below.

	@param taskSearch TaskSearch
	@return []Task
*/
func (c *APIClient) SearchTasksWithHTTPInfo(ctx context.Context, r ApiSearchTasksRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/tasks/search"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.taskSearch == nil {
		return nil, nil, reportError("Parameter `taskSearch` is required when calling `SearchTasks`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.taskSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SearchTasks wraps SearchTasksWithContext using context.Background.

Searches for tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTasksRequest with parameters below.

	@param taskSearch TaskSearch
	@return []Task
*/
func (c *APIClient) SearchTasks(r ApiSearchTasksRequest, opts ...Option) ([]Task, error) {
	return c.SearchTasksWithContext(context.Background(), r, opts...)
}

/*
SearchTasks casts the HTTP response body to a defined struct.

Searches for tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTasksRequest with parameters below.

	@param taskSearch TaskSearch
	@return []Task
*/
func (c *APIClient) SearchTasksWithContext(ctx context.Context, r ApiSearchTasksRequest, opts ...Option) ([]Task, error) {
	var returnValue []Task

	res, resBody, err := c.SearchTasksWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchTransformationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationSearch"]; ok {
		err = json.Unmarshal(v, &r.transformationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchTransformationsRequest represents the request with all the parameters for the API call.
type ApiSearchTransformationsRequest struct {
	transformationSearch *TransformationSearch
}

// NewApiSearchTransformationsRequest creates an instance of the ApiSearchTransformationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchTransformationsRequest(transformationSearch *TransformationSearch) ApiSearchTransformationsRequest {
	return ApiSearchTransformationsRequest{
		transformationSearch: transformationSearch,
	}
}

/*
SearchTransformations calls the API and returns the raw response from it.

Searches for transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTransformationsRequest with parameters below.

	@param transformationSearch TransformationSearch
	@return []Transformation
*/
func (c *APIClient) SearchTransformationsWithHTTPInfo(ctx context.Context, r ApiSearchTransformationsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/transformations/search"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.transformationSearch == nil {
		return nil, nil, reportError("Parameter `transformationSearch` is required when calling `SearchTransformations`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.transformationSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SearchTransformations wraps SearchTransformationsWithContext using context.Background.

Searches for transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTransformationsRequest with parameters below.

	@param transformationSearch TransformationSearch
	@return []Transformation
*/
func (c *APIClient) SearchTransformations(r ApiSearchTransformationsRequest, opts ...Option) ([]Transformation, error) {
	return c.SearchTransformationsWithContext(context.Background(), r, opts...)
}

/*
SearchTransformations casts the HTTP response body to a defined struct.

Searches for transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTransformationsRequest with parameters below.

	@param transformationSearch TransformationSearch
	@return []Transformation
*/
func (c *APIClient) SearchTransformationsWithContext(ctx context.Context, r ApiSearchTransformationsRequest, opts ...Option) ([]Transformation, error) {
	var returnValue []Transformation

	res, resBody, err := c.SearchTransformationsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiTriggerDockerSourceDiscoverRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiTriggerDockerSourceDiscoverRequest represents the request with all the parameters for the API call.
type ApiTriggerDockerSourceDiscoverRequest struct {
	sourceID string
}

// NewApiTriggerDockerSourceDiscoverRequest creates an instance of the ApiTriggerDockerSourceDiscoverRequest to be used for the API call.
func (c *APIClient) NewApiTriggerDockerSourceDiscoverRequest(sourceID string) ApiTriggerDockerSourceDiscoverRequest {
	return ApiTriggerDockerSourceDiscoverRequest{
		sourceID: sourceID,
	}
}

/*
TriggerDockerSourceDiscover calls the API and returns the raw response from it.

Triggers a stream-listing request for a source.
Triggering stream-listing requests only works with sources with `type: docker` and `imageType: singer`.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTriggerDockerSourceDiscoverRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return SourceWatchResponse
*/
func (c *APIClient) TriggerDockerSourceDiscoverWithHTTPInfo(ctx context.Context, r ApiTriggerDockerSourceDiscoverRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/sources/{sourceID}/discover"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(parameterToString(r.sourceID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `TriggerDockerSourceDiscover`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
TriggerDockerSourceDiscover wraps TriggerDockerSourceDiscoverWithContext using context.Background.

Triggers a stream-listing request for a source.
Triggering stream-listing requests only works with sources with `type: docker` and `imageType: singer`.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTriggerDockerSourceDiscoverRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return SourceWatchResponse
*/
func (c *APIClient) TriggerDockerSourceDiscover(r ApiTriggerDockerSourceDiscoverRequest, opts ...Option) (*SourceWatchResponse, error) {
	return c.TriggerDockerSourceDiscoverWithContext(context.Background(), r, opts...)
}

/*
TriggerDockerSourceDiscover casts the HTTP response body to a defined struct.

Triggers a stream-listing request for a source.
Triggering stream-listing requests only works with sources with `type: docker` and `imageType: singer`.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTriggerDockerSourceDiscoverRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return SourceWatchResponse
*/
func (c *APIClient) TriggerDockerSourceDiscoverWithContext(ctx context.Context, r ApiTriggerDockerSourceDiscoverRequest, opts ...Option) (*SourceWatchResponse, error) {
	var returnValue *SourceWatchResponse

	res, resBody, err := c.TriggerDockerSourceDiscoverWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiTryTransformationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationTry"]; ok {
		err = json.Unmarshal(v, &r.transformationTry)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationTry)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationTry: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationTry)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationTry: %w", err)
		}
	}

	return nil
}

// ApiTryTransformationsRequest represents the request with all the parameters for the API call.
type ApiTryTransformationsRequest struct {
	transformationTry *TransformationTry
}

// NewApiTryTransformationsRequest creates an instance of the ApiTryTransformationsRequest to be used for the API call.
func (c *APIClient) NewApiTryTransformationsRequest(transformationTry *TransformationTry) ApiTryTransformationsRequest {
	return ApiTryTransformationsRequest{
		transformationTry: transformationTry,
	}
}

/*
TryTransformations calls the API and returns the raw response from it.

Searches for transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTryTransformationsRequest with parameters below.

	@param transformationTry TransformationTry
	@return TransformationTryResponse
*/
func (c *APIClient) TryTransformationsWithHTTPInfo(ctx context.Context, r ApiTryTransformationsRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/transformations/try"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.transformationTry == nil {
		return nil, nil, reportError("Parameter `transformationTry` is required when calling `TryTransformations`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.transformationTry
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
TryTransformations wraps TryTransformationsWithContext using context.Background.

Searches for transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTryTransformationsRequest with parameters below.

	@param transformationTry TransformationTry
	@return TransformationTryResponse
*/
func (c *APIClient) TryTransformations(r ApiTryTransformationsRequest, opts ...Option) (*TransformationTryResponse, error) {
	return c.TryTransformationsWithContext(context.Background(), r, opts...)
}

/*
TryTransformations casts the HTTP response body to a defined struct.

Searches for transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTryTransformationsRequest with parameters below.

	@param transformationTry TransformationTry
	@return TransformationTryResponse
*/
func (c *APIClient) TryTransformationsWithContext(ctx context.Context, r ApiTryTransformationsRequest, opts ...Option) (*TransformationTryResponse, error) {
	var returnValue *TransformationTryResponse

	res, resBody, err := c.TryTransformationsWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}
	if v, ok := req["authenticationUpdate"]; ok {
		err = json.Unmarshal(v, &r.authenticationUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter authenticationUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateAuthenticationRequest represents the request with all the parameters for the API call.
type ApiUpdateAuthenticationRequest struct {
	authenticationID     string
	authenticationUpdate *AuthenticationUpdate
}

// NewApiUpdateAuthenticationRequest creates an instance of the ApiUpdateAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateAuthenticationRequest(authenticationID string, authenticationUpdate *AuthenticationUpdate) ApiUpdateAuthenticationRequest {
	return ApiUpdateAuthenticationRequest{
		authenticationID:     authenticationID,
		authenticationUpdate: authenticationUpdate,
	}
}

/*
UpdateAuthentication calls the API and returns the raw response from it.

Updates an authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@param authenticationUpdate AuthenticationUpdate
	@return AuthenticationUpdateResponse
*/
func (c *APIClient) UpdateAuthenticationWithHTTPInfo(ctx context.Context, r ApiUpdateAuthenticationRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(parameterToString(r.authenticationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.authenticationID == "" {
		return nil, nil, reportError("Parameter `authenticationID` is required when calling `UpdateAuthentication`.")
	}

	if r.authenticationUpdate == nil {
		return nil, nil, reportError("Parameter `authenticationUpdate` is required when calling `UpdateAuthentication`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.authenticationUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateAuthentication wraps UpdateAuthenticationWithContext using context.Background.

Updates an authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@param authenticationUpdate AuthenticationUpdate
	@return AuthenticationUpdateResponse
*/
func (c *APIClient) UpdateAuthentication(r ApiUpdateAuthenticationRequest, opts ...Option) (*AuthenticationUpdateResponse, error) {
	return c.UpdateAuthenticationWithContext(context.Background(), r, opts...)
}

/*
UpdateAuthentication casts the HTTP response body to a defined struct.

Updates an authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@param authenticationUpdate AuthenticationUpdate
	@return AuthenticationUpdateResponse
*/
func (c *APIClient) UpdateAuthenticationWithContext(ctx context.Context, r ApiUpdateAuthenticationRequest, opts ...Option) (*AuthenticationUpdateResponse, error) {
	var returnValue *AuthenticationUpdateResponse

	res, resBody, err := c.UpdateAuthenticationWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}
	if v, ok := req["destinationUpdate"]; ok {
		err = json.Unmarshal(v, &r.destinationUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter destinationUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateDestinationRequest represents the request with all the parameters for the API call.
type ApiUpdateDestinationRequest struct {
	destinationID     string
	destinationUpdate *DestinationUpdate
}

// NewApiUpdateDestinationRequest creates an instance of the ApiUpdateDestinationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateDestinationRequest(destinationID string, destinationUpdate *DestinationUpdate) ApiUpdateDestinationRequest {
	return ApiUpdateDestinationRequest{
		destinationID:     destinationID,
		destinationUpdate: destinationUpdate,
	}
}

/*
UpdateDestination calls the API and returns the raw response from it.

Updates the destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@param destinationUpdate DestinationUpdate
	@return DestinationUpdateResponse
*/
func (c *APIClient) UpdateDestinationWithHTTPInfo(ctx context.Context, r ApiUpdateDestinationRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(parameterToString(r.destinationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `UpdateDestination`.")
	}

	if r.destinationUpdate == nil {
		return nil, nil, reportError("Parameter `destinationUpdate` is required when calling `UpdateDestination`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.destinationUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateDestination wraps UpdateDestinationWithContext using context.Background.

Updates the destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@param destinationUpdate DestinationUpdate
	@return DestinationUpdateResponse
*/
func (c *APIClient) UpdateDestination(r ApiUpdateDestinationRequest, opts ...Option) (*DestinationUpdateResponse, error) {
	return c.UpdateDestinationWithContext(context.Background(), r, opts...)
}

/*
UpdateDestination casts the HTTP response body to a defined struct.

Updates the destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@param destinationUpdate DestinationUpdate
	@return DestinationUpdateResponse
*/
func (c *APIClient) UpdateDestinationWithContext(ctx context.Context, r ApiUpdateDestinationRequest, opts ...Option) (*DestinationUpdateResponse, error) {
	var returnValue *DestinationUpdateResponse

	res, resBody, err := c.UpdateDestinationWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}
	if v, ok := req["sourceUpdate"]; ok {
		err = json.Unmarshal(v, &r.sourceUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateSourceRequest represents the request with all the parameters for the API call.
type ApiUpdateSourceRequest struct {
	sourceID     string
	sourceUpdate *SourceUpdate
}

// NewApiUpdateSourceRequest creates an instance of the ApiUpdateSourceRequest to be used for the API call.
func (c *APIClient) NewApiUpdateSourceRequest(sourceID string, sourceUpdate *SourceUpdate) ApiUpdateSourceRequest {
	return ApiUpdateSourceRequest{
		sourceID:     sourceID,
		sourceUpdate: sourceUpdate,
	}
}

/*
UpdateSource calls the API and returns the raw response from it.

Updates a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param sourceUpdate SourceUpdate
	@return SourceUpdateResponse
*/
func (c *APIClient) UpdateSourceWithHTTPInfo(ctx context.Context, r ApiUpdateSourceRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(parameterToString(r.sourceID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `UpdateSource`.")
	}

	if r.sourceUpdate == nil {
		return nil, nil, reportError("Parameter `sourceUpdate` is required when calling `UpdateSource`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.sourceUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateSource wraps UpdateSourceWithContext using context.Background.

Updates a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param sourceUpdate SourceUpdate
	@return SourceUpdateResponse
*/
func (c *APIClient) UpdateSource(r ApiUpdateSourceRequest, opts ...Option) (*SourceUpdateResponse, error) {
	return c.UpdateSourceWithContext(context.Background(), r, opts...)
}

/*
UpdateSource casts the HTTP response body to a defined struct.

Updates a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param sourceUpdate SourceUpdate
	@return SourceUpdateResponse
*/
func (c *APIClient) UpdateSourceWithContext(ctx context.Context, r ApiUpdateSourceRequest, opts ...Option) (*SourceUpdateResponse, error) {
	var returnValue *SourceUpdateResponse

	res, resBody, err := c.UpdateSourceWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}
	if v, ok := req["taskUpdate"]; ok {
		err = json.Unmarshal(v, &r.taskUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateTaskRequest represents the request with all the parameters for the API call.
type ApiUpdateTaskRequest struct {
	taskID     string
	taskUpdate *TaskUpdate
}

// NewApiUpdateTaskRequest creates an instance of the ApiUpdateTaskRequest to be used for the API call.
func (c *APIClient) NewApiUpdateTaskRequest(taskID string, taskUpdate *TaskUpdate) ApiUpdateTaskRequest {
	return ApiUpdateTaskRequest{
		taskID:     taskID,
		taskUpdate: taskUpdate,
	}
}

/*
UpdateTask calls the API and returns the raw response from it.

Updates a task by its ID.

Request can be constructed by NewApiUpdateTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@param taskUpdate TaskUpdate
	@return TaskUpdateResponse
*/
func (c *APIClient) UpdateTaskWithHTTPInfo(ctx context.Context, r ApiUpdateTaskRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `UpdateTask`.")
	}

	if r.taskUpdate == nil {
		return nil, nil, reportError("Parameter `taskUpdate` is required when calling `UpdateTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.taskUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateTask wraps UpdateTaskWithContext using context.Background.

Updates a task by its ID.

Request can be constructed by NewApiUpdateTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@param taskUpdate TaskUpdate
	@return TaskUpdateResponse
*/
func (c *APIClient) UpdateTask(r ApiUpdateTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	return c.UpdateTaskWithContext(context.Background(), r, opts...)
}

/*
UpdateTask casts the HTTP response body to a defined struct.

Updates a task by its ID.

Request can be constructed by NewApiUpdateTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@param taskUpdate TaskUpdate
	@return TaskUpdateResponse
*/
func (c *APIClient) UpdateTaskWithContext(ctx context.Context, r ApiUpdateTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.UpdateTaskWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationID"]; ok {
		err = json.Unmarshal(v, &r.transformationID)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationID: %w", err)
			}
		}
	}
	if v, ok := req["transformationCreate"]; ok {
		err = json.Unmarshal(v, &r.transformationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationCreate: %w", err)
		}
	}

	return nil
}

// ApiUpdateTransformationRequest represents the request with all the parameters for the API call.
type ApiUpdateTransformationRequest struct {
	transformationID     string
	transformationCreate *TransformationCreate
}

// NewApiUpdateTransformationRequest creates an instance of the ApiUpdateTransformationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateTransformationRequest(transformationID string, transformationCreate *TransformationCreate) ApiUpdateTransformationRequest {
	return ApiUpdateTransformationRequest{
		transformationID:     transformationID,
		transformationCreate: transformationCreate,
	}
}

/*
UpdateTransformation calls the API and returns the raw response from it.

Updates a transformation by its ID.

Request can be constructed by NewApiUpdateTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@param transformationCreate TransformationCreate
	@return TransformationUpdateResponse
*/
func (c *APIClient) UpdateTransformationWithHTTPInfo(ctx context.Context, r ApiUpdateTransformationRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/transformations/{transformationID}"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(parameterToString(r.transformationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `UpdateTransformation`.")
	}

	if r.transformationCreate == nil {
		return nil, nil, reportError("Parameter `transformationCreate` is required when calling `UpdateTransformation`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.transformationCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateTransformation wraps UpdateTransformationWithContext using context.Background.

Updates a transformation by its ID.

Request can be constructed by NewApiUpdateTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@param transformationCreate TransformationCreate
	@return TransformationUpdateResponse
*/
func (c *APIClient) UpdateTransformation(r ApiUpdateTransformationRequest, opts ...Option) (*TransformationUpdateResponse, error) {
	return c.UpdateTransformationWithContext(context.Background(), r, opts...)
}

/*
UpdateTransformation casts the HTTP response body to a defined struct.

Updates a transformation by its ID.

Request can be constructed by NewApiUpdateTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@param transformationCreate TransformationCreate
	@return TransformationUpdateResponse
*/
func (c *APIClient) UpdateTransformationWithContext(ctx context.Context, r ApiUpdateTransformationRequest, opts ...Option) (*TransformationUpdateResponse, error) {
	var returnValue *TransformationUpdateResponse

	res, resBody, err := c.UpdateTransformationWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiValidateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceCreate"]; ok {
		err = json.Unmarshal(v, &r.sourceCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceCreate: %w", err)
			}
		}
	}

	return nil
}

// ApiValidateSourceRequest represents the request with all the parameters for the API call.
type ApiValidateSourceRequest struct {
	sourceCreate *SourceCreate
}

// NewApiValidateSourceRequest creates an instance of the ApiValidateSourceRequest to be used for the API call.
func (c *APIClient) NewApiValidateSourceRequest() ApiValidateSourceRequest {
	return ApiValidateSourceRequest{}
}

// WithSourceCreate adds the sourceCreate to the ApiValidateSourceRequest and returns the request for chaining.
func (r ApiValidateSourceRequest) WithSourceCreate(sourceCreate *SourceCreate) ApiValidateSourceRequest {
	r.sourceCreate = sourceCreate
	return r
}

/*
ValidateSource calls the API and returns the raw response from it.

Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiValidateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceWatchResponse
*/
func (c *APIClient) ValidateSourceWithHTTPInfo(ctx context.Context, r ApiValidateSourceRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/sources/validate"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.sourceCreate) {
		postBody = "{}"
	} else {
		postBody = r.sourceCreate
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ValidateSource wraps ValidateSourceWithContext using context.Background.

Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiValidateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceWatchResponse
*/
func (c *APIClient) ValidateSource(r ApiValidateSourceRequest, opts ...Option) (*SourceWatchResponse, error) {
	return c.ValidateSourceWithContext(context.Background(), r, opts...)
}

/*
ValidateSource casts the HTTP response body to a defined struct.

Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiValidateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceWatchResponse
*/
func (c *APIClient) ValidateSourceWithContext(ctx context.Context, r ApiValidateSourceRequest, opts ...Option) (*SourceWatchResponse, error) {
	var returnValue *SourceWatchResponse

	res, resBody, err := c.ValidateSourceWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiValidateSourceBeforeUpdateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}
	if v, ok := req["sourceUpdate"]; ok {
		err = json.Unmarshal(v, &r.sourceUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceUpdate: %w", err)
		}
	}

	return nil
}

// ApiValidateSourceBeforeUpdateRequest represents the request with all the parameters for the API call.
type ApiValidateSourceBeforeUpdateRequest struct {
	sourceID     string
	sourceUpdate *SourceUpdate
}

// NewApiValidateSourceBeforeUpdateRequest creates an instance of the ApiValidateSourceBeforeUpdateRequest to be used for the API call.
func (c *APIClient) NewApiValidateSourceBeforeUpdateRequest(sourceID string, sourceUpdate *SourceUpdate) ApiValidateSourceBeforeUpdateRequest {
	return ApiValidateSourceBeforeUpdateRequest{
		sourceID:     sourceID,
		sourceUpdate: sourceUpdate,
	}
}

/*
ValidateSourceBeforeUpdate calls the API and returns the raw response from it.

Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiValidateSourceBeforeUpdateRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param sourceUpdate SourceUpdate
	@return SourceWatchResponse
*/
func (c *APIClient) ValidateSourceBeforeUpdateWithHTTPInfo(ctx context.Context, r ApiValidateSourceBeforeUpdateRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/sources/{sourceID}/validate"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(parameterToString(r.sourceID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `ValidateSourceBeforeUpdate`.")
	}

	if r.sourceUpdate == nil {
		return nil, nil, reportError("Parameter `sourceUpdate` is required when calling `ValidateSourceBeforeUpdate`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.sourceUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ValidateSourceBeforeUpdate wraps ValidateSourceBeforeUpdateWithContext using context.Background.

Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiValidateSourceBeforeUpdateRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param sourceUpdate SourceUpdate
	@return SourceWatchResponse
*/
func (c *APIClient) ValidateSourceBeforeUpdate(r ApiValidateSourceBeforeUpdateRequest, opts ...Option) (*SourceWatchResponse, error) {
	return c.ValidateSourceBeforeUpdateWithContext(context.Background(), r, opts...)
}

/*
ValidateSourceBeforeUpdate casts the HTTP response body to a defined struct.

Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiValidateSourceBeforeUpdateRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param sourceUpdate SourceUpdate
	@return SourceWatchResponse
*/
func (c *APIClient) ValidateSourceBeforeUpdateWithContext(ctx context.Context, r ApiValidateSourceBeforeUpdateRequest, opts ...Option) (*SourceWatchResponse, error) {
	var returnValue *SourceWatchResponse

	res, resBody, err := c.ValidateSourceBeforeUpdateWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
