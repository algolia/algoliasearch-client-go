// File generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation.
package ingestion

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       queryParameterToString(name),
		value:      queryParameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

func (r *ApiCreateAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationCreate"]; ok {
		err = json.Unmarshal(v, &r.authenticationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter authenticationCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateAuthenticationRequest represents the request with all the parameters for the API call.
type ApiCreateAuthenticationRequest struct {
	authenticationCreate *AuthenticationCreate
}

// NewApiCreateAuthenticationRequest creates an instance of the ApiCreateAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiCreateAuthenticationRequest(authenticationCreate *AuthenticationCreate) ApiCreateAuthenticationRequest {
	return ApiCreateAuthenticationRequest{
		authenticationCreate: authenticationCreate,
	}
}

/*
CreateAuthentication Wraps CreateAuthenticationWithContext using context.Background.

Creates a new authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateAuthenticationRequest with parameters below.

	@param authenticationCreate AuthenticationCreate -
	@return AuthenticationCreateResponse
*/
func (c *APIClient) CreateAuthentication(r ApiCreateAuthenticationRequest, opts ...Option) (*AuthenticationCreateResponse, error) {
	return c.CreateAuthenticationWithContext(context.Background(), r, opts...)
}

/*
CreateAuthentication

Creates a new authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateAuthenticationRequest with parameters below.

	@param authenticationCreate AuthenticationCreate -
	@return AuthenticationCreateResponse
*/
func (c *APIClient) CreateAuthenticationWithContext(ctx context.Context, r ApiCreateAuthenticationRequest, opts ...Option) (*AuthenticationCreateResponse, error) {
	var (
		postBody    any
		returnValue *AuthenticationCreateResponse
	)

	requestPath := "/1/authentications"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.authenticationCreate == nil {
		return returnValue, reportError("Parameter `authenticationCreate` is required when calling `CreateAuthentication`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.authenticationCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationCreate"]; ok {
		err = json.Unmarshal(v, &r.destinationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter destinationCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateDestinationRequest represents the request with all the parameters for the API call.
type ApiCreateDestinationRequest struct {
	destinationCreate *DestinationCreate
}

// NewApiCreateDestinationRequest creates an instance of the ApiCreateDestinationRequest to be used for the API call.
func (c *APIClient) NewApiCreateDestinationRequest(destinationCreate *DestinationCreate) ApiCreateDestinationRequest {
	return ApiCreateDestinationRequest{
		destinationCreate: destinationCreate,
	}
}

/*
CreateDestination Wraps CreateDestinationWithContext using context.Background.

Creates a new destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateDestinationRequest with parameters below.

	@param destinationCreate DestinationCreate -
	@return DestinationCreateResponse
*/
func (c *APIClient) CreateDestination(r ApiCreateDestinationRequest, opts ...Option) (*DestinationCreateResponse, error) {
	return c.CreateDestinationWithContext(context.Background(), r, opts...)
}

/*
CreateDestination

Creates a new destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateDestinationRequest with parameters below.

	@param destinationCreate DestinationCreate -
	@return DestinationCreateResponse
*/
func (c *APIClient) CreateDestinationWithContext(ctx context.Context, r ApiCreateDestinationRequest, opts ...Option) (*DestinationCreateResponse, error) {
	var (
		postBody    any
		returnValue *DestinationCreateResponse
	)

	requestPath := "/1/destinations"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.destinationCreate == nil {
		return returnValue, reportError("Parameter `destinationCreate` is required when calling `CreateDestination`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.destinationCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceCreate"]; ok {
		err = json.Unmarshal(v, &r.sourceCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateSourceRequest represents the request with all the parameters for the API call.
type ApiCreateSourceRequest struct {
	sourceCreate *SourceCreate
}

// NewApiCreateSourceRequest creates an instance of the ApiCreateSourceRequest to be used for the API call.
func (c *APIClient) NewApiCreateSourceRequest(sourceCreate *SourceCreate) ApiCreateSourceRequest {
	return ApiCreateSourceRequest{
		sourceCreate: sourceCreate,
	}
}

/*
CreateSource Wraps CreateSourceWithContext using context.Background.

Creates a new source.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceCreateResponse
*/
func (c *APIClient) CreateSource(r ApiCreateSourceRequest, opts ...Option) (*SourceCreateResponse, error) {
	return c.CreateSourceWithContext(context.Background(), r, opts...)
}

/*
CreateSource

Creates a new source.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceCreateResponse
*/
func (c *APIClient) CreateSourceWithContext(ctx context.Context, r ApiCreateSourceRequest, opts ...Option) (*SourceCreateResponse, error) {
	var (
		postBody    any
		returnValue *SourceCreateResponse
	)

	requestPath := "/1/sources"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.sourceCreate == nil {
		return returnValue, reportError("Parameter `sourceCreate` is required when calling `CreateSource`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.sourceCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskCreate"]; ok {
		err = json.Unmarshal(v, &r.taskCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateTaskRequest represents the request with all the parameters for the API call.
type ApiCreateTaskRequest struct {
	taskCreate *TaskCreate
}

// NewApiCreateTaskRequest creates an instance of the ApiCreateTaskRequest to be used for the API call.
func (c *APIClient) NewApiCreateTaskRequest(taskCreate *TaskCreate) ApiCreateTaskRequest {
	return ApiCreateTaskRequest{
		taskCreate: taskCreate,
	}
}

/*
CreateTask Wraps CreateTaskWithContext using context.Background.

Creates a new task.

Request can be constructed by NewApiCreateTaskRequest with parameters below.

	@param taskCreate TaskCreate - Request body for creating a task.
	@return TaskCreateResponse
*/
func (c *APIClient) CreateTask(r ApiCreateTaskRequest, opts ...Option) (*TaskCreateResponse, error) {
	return c.CreateTaskWithContext(context.Background(), r, opts...)
}

/*
CreateTask

Creates a new task.

Request can be constructed by NewApiCreateTaskRequest with parameters below.

	@param taskCreate TaskCreate - Request body for creating a task.
	@return TaskCreateResponse
*/
func (c *APIClient) CreateTaskWithContext(ctx context.Context, r ApiCreateTaskRequest, opts ...Option) (*TaskCreateResponse, error) {
	var (
		postBody    any
		returnValue *TaskCreateResponse
	)

	requestPath := "/1/tasks"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.taskCreate == nil {
		return returnValue, reportError("Parameter `taskCreate` is required when calling `CreateTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.taskCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomDeleteRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomDeleteRequest represents the request with all the parameters for the API call.
type ApiCustomDeleteRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiCustomDeleteRequest creates an instance of the ApiCustomDeleteRequest to be used for the API call.
func (c *APIClient) NewApiCustomDeleteRequest(path string) ApiCustomDeleteRequest {
	return ApiCustomDeleteRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomDeleteRequest and returns the request for chaining.
func (r ApiCustomDeleteRequest) WithParameters(parameters map[string]interface{}) ApiCustomDeleteRequest {
	r.parameters = parameters
	return r
}

/*
CustomDelete Wraps CustomDeleteWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomDelete(r ApiCustomDeleteRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomDeleteWithContext(context.Background(), r, opts...)
}

/*
CustomDelete

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomDeleteWithContext(ctx context.Context, r ApiCustomDeleteRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomGetRequest represents the request with all the parameters for the API call.
type ApiCustomGetRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiCustomGetRequest creates an instance of the ApiCustomGetRequest to be used for the API call.
func (c *APIClient) NewApiCustomGetRequest(path string) ApiCustomGetRequest {
	return ApiCustomGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomGetRequest and returns the request for chaining.
func (r ApiCustomGetRequest) WithParameters(parameters map[string]interface{}) ApiCustomGetRequest {
	r.parameters = parameters
	return r
}

/*
CustomGet Wraps CustomGetWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomGet(r ApiCustomGetRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomGetWithContext(context.Background(), r, opts...)
}

/*
CustomGet

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomGetWithContext(ctx context.Context, r ApiCustomGetRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPostRequest represents the request with all the parameters for the API call.
type ApiCustomPostRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiCustomPostRequest creates an instance of the ApiCustomPostRequest to be used for the API call.
func (c *APIClient) NewApiCustomPostRequest(path string) ApiCustomPostRequest {
	return ApiCustomPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithParameters(parameters map[string]interface{}) ApiCustomPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithBody(body map[string]interface{}) ApiCustomPostRequest {
	r.body = body
	return r
}

/*
CustomPost Wraps CustomPostWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPost(r ApiCustomPostRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomPostWithContext(context.Background(), r, opts...)
}

/*
CustomPost

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPostWithContext(ctx context.Context, r ApiCustomPostRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPutRequest represents the request with all the parameters for the API call.
type ApiCustomPutRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiCustomPutRequest creates an instance of the ApiCustomPutRequest to be used for the API call.
func (c *APIClient) NewApiCustomPutRequest(path string) ApiCustomPutRequest {
	return ApiCustomPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithParameters(parameters map[string]interface{}) ApiCustomPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithBody(body map[string]interface{}) ApiCustomPutRequest {
	r.body = body
	return r
}

/*
CustomPut Wraps CustomPutWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPut(r ApiCustomPutRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomPutWithContext(context.Background(), r, opts...)
}

/*
CustomPut

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPutWithContext(ctx context.Context, r ApiCustomPutRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteAuthenticationRequest represents the request with all the parameters for the API call.
type ApiDeleteAuthenticationRequest struct {
	authenticationID string
}

// NewApiDeleteAuthenticationRequest creates an instance of the ApiDeleteAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteAuthenticationRequest(authenticationID string) ApiDeleteAuthenticationRequest {
	return ApiDeleteAuthenticationRequest{
		authenticationID: authenticationID,
	}
}

/*
DeleteAuthentication Wraps DeleteAuthenticationWithContext using context.Background.

Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return DeleteResponse
*/
func (c *APIClient) DeleteAuthentication(r ApiDeleteAuthenticationRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteAuthenticationWithContext(context.Background(), r, opts...)
}

/*
DeleteAuthentication

Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return DeleteResponse
*/
func (c *APIClient) DeleteAuthenticationWithContext(ctx context.Context, r ApiDeleteAuthenticationRequest, opts ...Option) (*DeleteResponse, error) {
	var (
		postBody    any
		returnValue *DeleteResponse
	)

	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(parameterToString(r.authenticationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.authenticationID == "" {
		return returnValue, reportError("Parameter `authenticationID` is required when calling `DeleteAuthentication`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteDestinationRequest represents the request with all the parameters for the API call.
type ApiDeleteDestinationRequest struct {
	destinationID string
}

// NewApiDeleteDestinationRequest creates an instance of the ApiDeleteDestinationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteDestinationRequest(destinationID string) ApiDeleteDestinationRequest {
	return ApiDeleteDestinationRequest{
		destinationID: destinationID,
	}
}

/*
DeleteDestination Wraps DeleteDestinationWithContext using context.Background.

Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return DeleteResponse
*/
func (c *APIClient) DeleteDestination(r ApiDeleteDestinationRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteDestinationWithContext(context.Background(), r, opts...)
}

/*
DeleteDestination

Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return DeleteResponse
*/
func (c *APIClient) DeleteDestinationWithContext(ctx context.Context, r ApiDeleteDestinationRequest, opts ...Option) (*DeleteResponse, error) {
	var (
		postBody    any
		returnValue *DeleteResponse
	)

	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(parameterToString(r.destinationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.destinationID == "" {
		return returnValue, reportError("Parameter `destinationID` is required when calling `DeleteDestination`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteSourceRequest represents the request with all the parameters for the API call.
type ApiDeleteSourceRequest struct {
	sourceID string
}

// NewApiDeleteSourceRequest creates an instance of the ApiDeleteSourceRequest to be used for the API call.
func (c *APIClient) NewApiDeleteSourceRequest(sourceID string) ApiDeleteSourceRequest {
	return ApiDeleteSourceRequest{
		sourceID: sourceID,
	}
}

/*
DeleteSource Wraps DeleteSourceWithContext using context.Background.

Deletes a source by its ID. You can't delete sources that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return DeleteResponse
*/
func (c *APIClient) DeleteSource(r ApiDeleteSourceRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteSourceWithContext(context.Background(), r, opts...)
}

/*
DeleteSource

Deletes a source by its ID. You can't delete sources that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return DeleteResponse
*/
func (c *APIClient) DeleteSourceWithContext(ctx context.Context, r ApiDeleteSourceRequest, opts ...Option) (*DeleteResponse, error) {
	var (
		postBody    any
		returnValue *DeleteResponse
	)

	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(parameterToString(r.sourceID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceID == "" {
		return returnValue, reportError("Parameter `sourceID` is required when calling `DeleteSource`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteTaskRequest represents the request with all the parameters for the API call.
type ApiDeleteTaskRequest struct {
	taskID string
}

// NewApiDeleteTaskRequest creates an instance of the ApiDeleteTaskRequest to be used for the API call.
func (c *APIClient) NewApiDeleteTaskRequest(taskID string) ApiDeleteTaskRequest {
	return ApiDeleteTaskRequest{
		taskID: taskID,
	}
}

/*
DeleteTask Wraps DeleteTaskWithContext using context.Background.

Deletes a task by its ID.

Request can be constructed by NewApiDeleteTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTask(r ApiDeleteTaskRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteTaskWithContext(context.Background(), r, opts...)
}

/*
DeleteTask

Deletes a task by its ID.

Request can be constructed by NewApiDeleteTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTaskWithContext(ctx context.Context, r ApiDeleteTaskRequest, opts ...Option) (*DeleteResponse, error) {
	var (
		postBody    any
		returnValue *DeleteResponse
	)

	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskID == "" {
		return returnValue, reportError("Parameter `taskID` is required when calling `DeleteTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDisableTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiDisableTaskRequest represents the request with all the parameters for the API call.
type ApiDisableTaskRequest struct {
	taskID string
}

// NewApiDisableTaskRequest creates an instance of the ApiDisableTaskRequest to be used for the API call.
func (c *APIClient) NewApiDisableTaskRequest(taskID string) ApiDisableTaskRequest {
	return ApiDisableTaskRequest{
		taskID: taskID,
	}
}

/*
DisableTask Wraps DisableTaskWithContext using context.Background.

Disables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDisableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) DisableTask(r ApiDisableTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	return c.DisableTaskWithContext(context.Background(), r, opts...)
}

/*
DisableTask

Disables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDisableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) DisableTaskWithContext(ctx context.Context, r ApiDisableTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	var (
		postBody    any
		returnValue *TaskUpdateResponse
	)

	requestPath := "/1/tasks/{taskID}/disable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskID == "" {
		return returnValue, reportError("Parameter `taskID` is required when calling `DisableTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiEnableTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiEnableTaskRequest represents the request with all the parameters for the API call.
type ApiEnableTaskRequest struct {
	taskID string
}

// NewApiEnableTaskRequest creates an instance of the ApiEnableTaskRequest to be used for the API call.
func (c *APIClient) NewApiEnableTaskRequest(taskID string) ApiEnableTaskRequest {
	return ApiEnableTaskRequest{
		taskID: taskID,
	}
}

/*
EnableTask Wraps EnableTaskWithContext using context.Background.

Enables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiEnableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) EnableTask(r ApiEnableTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	return c.EnableTaskWithContext(context.Background(), r, opts...)
}

/*
EnableTask

Enables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiEnableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) EnableTaskWithContext(ctx context.Context, r ApiEnableTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	var (
		postBody    any
		returnValue *TaskUpdateResponse
	)

	requestPath := "/1/tasks/{taskID}/enable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskID == "" {
		return returnValue, reportError("Parameter `taskID` is required when calling `EnableTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetAuthenticationRequest represents the request with all the parameters for the API call.
type ApiGetAuthenticationRequest struct {
	authenticationID string
}

// NewApiGetAuthenticationRequest creates an instance of the ApiGetAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiGetAuthenticationRequest(authenticationID string) ApiGetAuthenticationRequest {
	return ApiGetAuthenticationRequest{
		authenticationID: authenticationID,
	}
}

/*
GetAuthentication Wraps GetAuthenticationWithContext using context.Background.

Retrieves an authentication resource by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return Authentication
*/
func (c *APIClient) GetAuthentication(r ApiGetAuthenticationRequest, opts ...Option) (*Authentication, error) {
	return c.GetAuthenticationWithContext(context.Background(), r, opts...)
}

/*
GetAuthentication

Retrieves an authentication resource by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return Authentication
*/
func (c *APIClient) GetAuthenticationWithContext(ctx context.Context, r ApiGetAuthenticationRequest, opts ...Option) (*Authentication, error) {
	var (
		postBody    any
		returnValue *Authentication
	)

	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(parameterToString(r.authenticationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.authenticationID == "" {
		return returnValue, reportError("Parameter `authenticationID` is required when calling `GetAuthentication`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetAuthenticationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["platform"]; ok {
		err = json.Unmarshal(v, &r.platform)
		if err != nil {
			err = json.Unmarshal(b, &r.platform)
			if err != nil {
				return fmt.Errorf("cannot unmarshal platform: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiGetAuthenticationsRequest represents the request with all the parameters for the API call.
type ApiGetAuthenticationsRequest struct {
	itemsPerPage *int32
	page         *int32
	type_        []AuthenticationType
	platform     []PlatformWithNone
	sort         AuthenticationSortKeys
	order        OrderKeys
}

// NewApiGetAuthenticationsRequest creates an instance of the ApiGetAuthenticationsRequest to be used for the API call.
func (c *APIClient) NewApiGetAuthenticationsRequest() ApiGetAuthenticationsRequest {
	return ApiGetAuthenticationsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithItemsPerPage(itemsPerPage int32) ApiGetAuthenticationsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithPage(page int32) ApiGetAuthenticationsRequest {
	r.page = &page
	return r
}

// WithType adds the type_ to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithType(type_ []AuthenticationType) ApiGetAuthenticationsRequest {
	r.type_ = type_
	return r
}

// WithPlatform adds the platform to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithPlatform(platform []PlatformWithNone) ApiGetAuthenticationsRequest {
	r.platform = platform
	return r
}

// WithSort adds the sort to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithSort(sort AuthenticationSortKeys) ApiGetAuthenticationsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithOrder(order OrderKeys) ApiGetAuthenticationsRequest {
	r.order = order
	return r
}

/*
GetAuthentications Wraps GetAuthenticationsWithContext using context.Background.

Retrieves a list of all authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetAuthenticationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []AuthenticationType - Type of authentication resource to retrieve.
	@param platform []PlatformWithNone - Ecommerce platform for which to retrieve authentication resources.
	@param sort AuthenticationSortKeys - Property by which to sort the list of authentication resources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListAuthenticationsResponse
*/
func (c *APIClient) GetAuthentications(r ApiGetAuthenticationsRequest, opts ...Option) (*ListAuthenticationsResponse, error) {
	return c.GetAuthenticationsWithContext(context.Background(), r, opts...)
}

/*
GetAuthentications

Retrieves a list of all authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetAuthenticationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []AuthenticationType - Type of authentication resource to retrieve.
	@param platform []PlatformWithNone - Ecommerce platform for which to retrieve authentication resources.
	@param sort AuthenticationSortKeys - Property by which to sort the list of authentication resources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListAuthenticationsResponse
*/
func (c *APIClient) GetAuthenticationsWithContext(ctx context.Context, r ApiGetAuthenticationsRequest, opts ...Option) (*ListAuthenticationsResponse, error) {
	var (
		postBody    any
		returnValue *ListAuthenticationsResponse
	)

	requestPath := "/1/authentications"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", queryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		queryParams.Set("type", queryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.platform) {
		queryParams.Set("platform", queryParameterToString(r.platform))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetDestinationRequest represents the request with all the parameters for the API call.
type ApiGetDestinationRequest struct {
	destinationID string
}

// NewApiGetDestinationRequest creates an instance of the ApiGetDestinationRequest to be used for the API call.
func (c *APIClient) NewApiGetDestinationRequest(destinationID string) ApiGetDestinationRequest {
	return ApiGetDestinationRequest{
		destinationID: destinationID,
	}
}

/*
GetDestination Wraps GetDestinationWithContext using context.Background.

Retrieves a destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return Destination
*/
func (c *APIClient) GetDestination(r ApiGetDestinationRequest, opts ...Option) (*Destination, error) {
	return c.GetDestinationWithContext(context.Background(), r, opts...)
}

/*
GetDestination

Retrieves a destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return Destination
*/
func (c *APIClient) GetDestinationWithContext(ctx context.Context, r ApiGetDestinationRequest, opts ...Option) (*Destination, error) {
	var (
		postBody    any
		returnValue *Destination
	)

	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(parameterToString(r.destinationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.destinationID == "" {
		return returnValue, reportError("Parameter `destinationID` is required when calling `GetDestination`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetDestinationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiGetDestinationsRequest represents the request with all the parameters for the API call.
type ApiGetDestinationsRequest struct {
	itemsPerPage     *int32
	page             *int32
	type_            []DestinationType
	authenticationID []string
	sort             DestinationSortKeys
	order            OrderKeys
}

// NewApiGetDestinationsRequest creates an instance of the ApiGetDestinationsRequest to be used for the API call.
func (c *APIClient) NewApiGetDestinationsRequest() ApiGetDestinationsRequest {
	return ApiGetDestinationsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithItemsPerPage(itemsPerPage int32) ApiGetDestinationsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithPage(page int32) ApiGetDestinationsRequest {
	r.page = &page
	return r
}

// WithType adds the type_ to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithType(type_ []DestinationType) ApiGetDestinationsRequest {
	r.type_ = type_
	return r
}

// WithAuthenticationID adds the authenticationID to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithAuthenticationID(authenticationID []string) ApiGetDestinationsRequest {
	r.authenticationID = authenticationID
	return r
}

// WithSort adds the sort to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithSort(sort DestinationSortKeys) ApiGetDestinationsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithOrder(order OrderKeys) ApiGetDestinationsRequest {
	r.order = order
	return r
}

/*
GetDestinations Wraps GetDestinationsWithContext using context.Background.

Retrieves a list of destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDestinationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []DestinationType - Destination type.
	@param authenticationID []string - Authentication ID used by destinations.
	@param sort DestinationSortKeys - Property by which to sort the destinations.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListDestinationsResponse
*/
func (c *APIClient) GetDestinations(r ApiGetDestinationsRequest, opts ...Option) (*ListDestinationsResponse, error) {
	return c.GetDestinationsWithContext(context.Background(), r, opts...)
}

/*
GetDestinations

Retrieves a list of destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDestinationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []DestinationType - Destination type.
	@param authenticationID []string - Authentication ID used by destinations.
	@param sort DestinationSortKeys - Property by which to sort the destinations.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListDestinationsResponse
*/
func (c *APIClient) GetDestinationsWithContext(ctx context.Context, r ApiGetDestinationsRequest, opts ...Option) (*ListDestinationsResponse, error) {
	var (
		postBody    any
		returnValue *ListDestinationsResponse
	)

	requestPath := "/1/destinations"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", queryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		queryParams.Set("type", queryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.authenticationID) {
		queryParams.Set("authenticationID", queryParameterToString(r.authenticationID))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetDockerSourceStreamsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetDockerSourceStreamsRequest represents the request with all the parameters for the API call.
type ApiGetDockerSourceStreamsRequest struct {
	sourceID string
}

// NewApiGetDockerSourceStreamsRequest creates an instance of the ApiGetDockerSourceStreamsRequest to be used for the API call.
func (c *APIClient) NewApiGetDockerSourceStreamsRequest(sourceID string) ApiGetDockerSourceStreamsRequest {
	return ApiGetDockerSourceStreamsRequest{
		sourceID: sourceID,
	}
}

/*
GetDockerSourceStreams Wraps GetDockerSourceStreamsWithContext using context.Background.

Retrieves a stream listing for a source.

Listing streams only works with sources with `type: docker` and `imageType: singer`.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDockerSourceStreamsRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return DockerSourceStreams
*/
func (c *APIClient) GetDockerSourceStreams(r ApiGetDockerSourceStreamsRequest, opts ...Option) (*DockerSourceStreams, error) {
	return c.GetDockerSourceStreamsWithContext(context.Background(), r, opts...)
}

/*
GetDockerSourceStreams

Retrieves a stream listing for a source.

Listing streams only works with sources with `type: docker` and `imageType: singer`.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDockerSourceStreamsRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return DockerSourceStreams
*/
func (c *APIClient) GetDockerSourceStreamsWithContext(ctx context.Context, r ApiGetDockerSourceStreamsRequest, opts ...Option) (*DockerSourceStreams, error) {
	var (
		postBody    any
		returnValue *DockerSourceStreams
	)

	requestPath := "/1/sources/{sourceID}/discover"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(parameterToString(r.sourceID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceID == "" {
		return returnValue, reportError("Parameter `sourceID` is required when calling `GetDockerSourceStreams`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetEventRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runID: %w", err)
			}
		}
	}
	if v, ok := req["eventID"]; ok {
		err = json.Unmarshal(v, &r.eventID)
		if err != nil {
			err = json.Unmarshal(b, &r.eventID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal eventID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetEventRequest represents the request with all the parameters for the API call.
type ApiGetEventRequest struct {
	runID   string
	eventID string
}

// NewApiGetEventRequest creates an instance of the ApiGetEventRequest to be used for the API call.
func (c *APIClient) NewApiGetEventRequest(runID string, eventID string) ApiGetEventRequest {
	return ApiGetEventRequest{
		runID:   runID,
		eventID: eventID,
	}
}

/*
GetEvent Wraps GetEventWithContext using context.Background.

Retrieves a single task run event by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetEventRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param eventID string - Unique identifier of an event.
	@return Event
*/
func (c *APIClient) GetEvent(r ApiGetEventRequest, opts ...Option) (*Event, error) {
	return c.GetEventWithContext(context.Background(), r, opts...)
}

/*
GetEvent

Retrieves a single task run event by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetEventRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param eventID string - Unique identifier of an event.
	@return Event
*/
func (c *APIClient) GetEventWithContext(ctx context.Context, r ApiGetEventRequest, opts ...Option) (*Event, error) {
	var (
		postBody    any
		returnValue *Event
	)

	requestPath := "/1/runs/{runID}/events/{eventID}"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(parameterToString(r.runID)))
	requestPath = strings.ReplaceAll(requestPath, "{eventID}", url.PathEscape(parameterToString(r.eventID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.runID == "" {
		return returnValue, reportError("Parameter `runID` is required when calling `GetEvent`.")
	}
	if r.eventID == "" {
		return returnValue, reportError("Parameter `eventID` is required when calling `GetEvent`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetEventsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runID: %w", err)
			}
		}
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["status"]; ok {
		err = json.Unmarshal(v, &r.status)
		if err != nil {
			err = json.Unmarshal(b, &r.status)
			if err != nil {
				return fmt.Errorf("cannot unmarshal status: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}

	return nil
}

// ApiGetEventsRequest represents the request with all the parameters for the API call.
type ApiGetEventsRequest struct {
	runID        string
	itemsPerPage *int32
	page         *int32
	status       []EventStatus
	type_        []EventType
	sort         EventSortKeys
	order        OrderKeys
	startDate    *string
	endDate      *string
}

// NewApiGetEventsRequest creates an instance of the ApiGetEventsRequest to be used for the API call.
func (c *APIClient) NewApiGetEventsRequest(runID string) ApiGetEventsRequest {
	return ApiGetEventsRequest{
		runID: runID,
	}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithItemsPerPage(itemsPerPage int32) ApiGetEventsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithPage(page int32) ApiGetEventsRequest {
	r.page = &page
	return r
}

// WithStatus adds the status to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithStatus(status []EventStatus) ApiGetEventsRequest {
	r.status = status
	return r
}

// WithType adds the type_ to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithType(type_ []EventType) ApiGetEventsRequest {
	r.type_ = type_
	return r
}

// WithSort adds the sort to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithSort(sort EventSortKeys) ApiGetEventsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithOrder(order OrderKeys) ApiGetEventsRequest {
	r.order = order
	return r
}

// WithStartDate adds the startDate to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithStartDate(startDate string) ApiGetEventsRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithEndDate(endDate string) ApiGetEventsRequest {
	r.endDate = &endDate
	return r
}

/*
GetEvents Wraps GetEventsWithContext using context.Background.

Retrieves a list of events for a task run, identified by it's ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetEventsRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []EventStatus - Event status for filtering the list of task runs.
	@param type_ []EventType - Event type for filtering the list of task runs.
	@param sort EventSortKeys - Property by which to sort the list of task run events.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date and time in RFC3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
	@param endDate string - Date and time in RFC3339 format for the latest events to retrieve. By default, the current time is used.
	@return ListEventsResponse
*/
func (c *APIClient) GetEvents(r ApiGetEventsRequest, opts ...Option) (*ListEventsResponse, error) {
	return c.GetEventsWithContext(context.Background(), r, opts...)
}

/*
GetEvents

Retrieves a list of events for a task run, identified by it's ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetEventsRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []EventStatus - Event status for filtering the list of task runs.
	@param type_ []EventType - Event type for filtering the list of task runs.
	@param sort EventSortKeys - Property by which to sort the list of task run events.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date and time in RFC3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
	@param endDate string - Date and time in RFC3339 format for the latest events to retrieve. By default, the current time is used.
	@return ListEventsResponse
*/
func (c *APIClient) GetEventsWithContext(ctx context.Context, r ApiGetEventsRequest, opts ...Option) (*ListEventsResponse, error) {
	var (
		postBody    any
		returnValue *ListEventsResponse
	)

	requestPath := "/1/runs/{runID}/events"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(parameterToString(r.runID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.runID == "" {
		return returnValue, reportError("Parameter `runID` is required when calling `GetEvents`.")
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", queryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.status) {
		queryParams.Set("status", queryParameterToString(r.status))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		queryParams.Set("type", queryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", queryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", queryParameterToString(*r.endDate))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRunRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetRunRequest represents the request with all the parameters for the API call.
type ApiGetRunRequest struct {
	runID string
}

// NewApiGetRunRequest creates an instance of the ApiGetRunRequest to be used for the API call.
func (c *APIClient) NewApiGetRunRequest(runID string) ApiGetRunRequest {
	return ApiGetRunRequest{
		runID: runID,
	}
}

/*
GetRun Wraps GetRunWithContext using context.Background.

Retrieve a single task run by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetRunRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@return Run
*/
func (c *APIClient) GetRun(r ApiGetRunRequest, opts ...Option) (*Run, error) {
	return c.GetRunWithContext(context.Background(), r, opts...)
}

/*
GetRun

Retrieve a single task run by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetRunRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@return Run
*/
func (c *APIClient) GetRunWithContext(ctx context.Context, r ApiGetRunRequest, opts ...Option) (*Run, error) {
	var (
		postBody    any
		returnValue *Run
	)

	requestPath := "/1/runs/{runID}"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(parameterToString(r.runID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.runID == "" {
		return returnValue, reportError("Parameter `runID` is required when calling `GetRun`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRunsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["status"]; ok {
		err = json.Unmarshal(v, &r.status)
		if err != nil {
			err = json.Unmarshal(b, &r.status)
			if err != nil {
				return fmt.Errorf("cannot unmarshal status: %w", err)
			}
		}
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}

	return nil
}

// ApiGetRunsRequest represents the request with all the parameters for the API call.
type ApiGetRunsRequest struct {
	itemsPerPage *int32
	page         *int32
	status       []RunStatus
	taskID       *string
	sort         RunSortKeys
	order        OrderKeys
	startDate    *string
	endDate      *string
}

// NewApiGetRunsRequest creates an instance of the ApiGetRunsRequest to be used for the API call.
func (c *APIClient) NewApiGetRunsRequest() ApiGetRunsRequest {
	return ApiGetRunsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithItemsPerPage(itemsPerPage int32) ApiGetRunsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithPage(page int32) ApiGetRunsRequest {
	r.page = &page
	return r
}

// WithStatus adds the status to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithStatus(status []RunStatus) ApiGetRunsRequest {
	r.status = status
	return r
}

// WithTaskID adds the taskID to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithTaskID(taskID string) ApiGetRunsRequest {
	r.taskID = &taskID
	return r
}

// WithSort adds the sort to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithSort(sort RunSortKeys) ApiGetRunsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithOrder(order OrderKeys) ApiGetRunsRequest {
	r.order = order
	return r
}

// WithStartDate adds the startDate to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithStartDate(startDate string) ApiGetRunsRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithEndDate(endDate string) ApiGetRunsRequest {
	r.endDate = &endDate
	return r
}

/*
GetRuns Wraps GetRunsWithContext using context.Background.

Retrieve a list of task runs.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetRunsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []RunStatus - Run status for filtering the list of task runs.
	@param taskID string - Task ID for filtering the list of task runs.
	@param sort RunSortKeys - Property by which to sort the list of task runs.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date in RFC3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
	@param endDate string - Date in RFC3339 format for the latest run to retrieve. By default, the current day is used.
	@return RunListResponse
*/
func (c *APIClient) GetRuns(r ApiGetRunsRequest, opts ...Option) (*RunListResponse, error) {
	return c.GetRunsWithContext(context.Background(), r, opts...)
}

/*
GetRuns

Retrieve a list of task runs.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetRunsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []RunStatus - Run status for filtering the list of task runs.
	@param taskID string - Task ID for filtering the list of task runs.
	@param sort RunSortKeys - Property by which to sort the list of task runs.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date in RFC3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
	@param endDate string - Date in RFC3339 format for the latest run to retrieve. By default, the current day is used.
	@return RunListResponse
*/
func (c *APIClient) GetRunsWithContext(ctx context.Context, r ApiGetRunsRequest, opts ...Option) (*RunListResponse, error) {
	var (
		postBody    any
		returnValue *RunListResponse
	)

	requestPath := "/1/runs"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", queryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.status) {
		queryParams.Set("status", queryParameterToString(r.status))
	}
	if !utils.IsNilOrEmpty(r.taskID) {
		queryParams.Set("taskID", queryParameterToString(*r.taskID))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		queryParams.Set("startDate", queryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		queryParams.Set("endDate", queryParameterToString(*r.endDate))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSourceRequest represents the request with all the parameters for the API call.
type ApiGetSourceRequest struct {
	sourceID string
}

// NewApiGetSourceRequest creates an instance of the ApiGetSourceRequest to be used for the API call.
func (c *APIClient) NewApiGetSourceRequest(sourceID string) ApiGetSourceRequest {
	return ApiGetSourceRequest{
		sourceID: sourceID,
	}
}

/*
GetSource Wraps GetSourceWithContext using context.Background.

Retrieve a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return Source
*/
func (c *APIClient) GetSource(r ApiGetSourceRequest, opts ...Option) (*Source, error) {
	return c.GetSourceWithContext(context.Background(), r, opts...)
}

/*
GetSource

Retrieve a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return Source
*/
func (c *APIClient) GetSourceWithContext(ctx context.Context, r ApiGetSourceRequest, opts ...Option) (*Source, error) {
	var (
		postBody    any
		returnValue *Source
	)

	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(parameterToString(r.sourceID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceID == "" {
		return returnValue, reportError("Parameter `sourceID` is required when calling `GetSource`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSourcesRequest represents the request with all the parameters for the API call.
type ApiGetSourcesRequest struct {
	itemsPerPage     *int32
	page             *int32
	type_            []SourceType
	authenticationID []string
	sort             SourceSortKeys
	order            OrderKeys
}

// NewApiGetSourcesRequest creates an instance of the ApiGetSourcesRequest to be used for the API call.
func (c *APIClient) NewApiGetSourcesRequest() ApiGetSourcesRequest {
	return ApiGetSourcesRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithItemsPerPage(itemsPerPage int32) ApiGetSourcesRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithPage(page int32) ApiGetSourcesRequest {
	r.page = &page
	return r
}

// WithType adds the type_ to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithType(type_ []SourceType) ApiGetSourcesRequest {
	r.type_ = type_
	return r
}

// WithAuthenticationID adds the authenticationID to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithAuthenticationID(authenticationID []string) ApiGetSourcesRequest {
	r.authenticationID = authenticationID
	return r
}

// WithSort adds the sort to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithSort(sort SourceSortKeys) ApiGetSourcesRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithOrder(order OrderKeys) ApiGetSourcesRequest {
	r.order = order
	return r
}

/*
GetSources Wraps GetSourcesWithContext using context.Background.

Retrieves a list of sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []SourceType - Source type. Some sources require authentication.
	@param authenticationID []string - Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication resource.
	@param sort SourceSortKeys - Property by which to sort the list of sources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListSourcesResponse
*/
func (c *APIClient) GetSources(r ApiGetSourcesRequest, opts ...Option) (*ListSourcesResponse, error) {
	return c.GetSourcesWithContext(context.Background(), r, opts...)
}

/*
GetSources

Retrieves a list of sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []SourceType - Source type. Some sources require authentication.
	@param authenticationID []string - Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication resource.
	@param sort SourceSortKeys - Property by which to sort the list of sources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListSourcesResponse
*/
func (c *APIClient) GetSourcesWithContext(ctx context.Context, r ApiGetSourcesRequest, opts ...Option) (*ListSourcesResponse, error) {
	var (
		postBody    any
		returnValue *ListSourcesResponse
	)

	requestPath := "/1/sources"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", queryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		queryParams.Set("type", queryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.authenticationID) {
		queryParams.Set("authenticationID", queryParameterToString(r.authenticationID))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTaskRequest represents the request with all the parameters for the API call.
type ApiGetTaskRequest struct {
	taskID string
}

// NewApiGetTaskRequest creates an instance of the ApiGetTaskRequest to be used for the API call.
func (c *APIClient) NewApiGetTaskRequest(taskID string) ApiGetTaskRequest {
	return ApiGetTaskRequest{
		taskID: taskID,
	}
}

/*
GetTask Wraps GetTaskWithContext using context.Background.

Retrieves a task by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return Task
*/
func (c *APIClient) GetTask(r ApiGetTaskRequest, opts ...Option) (*Task, error) {
	return c.GetTaskWithContext(context.Background(), r, opts...)
}

/*
GetTask

Retrieves a task by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return Task
*/
func (c *APIClient) GetTaskWithContext(ctx context.Context, r ApiGetTaskRequest, opts ...Option) (*Task, error) {
	var (
		postBody    any
		returnValue *Task
	)

	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskID == "" {
		return returnValue, reportError("Parameter `taskID` is required when calling `GetTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTasksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["action"]; ok {
		err = json.Unmarshal(v, &r.action)
		if err != nil {
			err = json.Unmarshal(b, &r.action)
			if err != nil {
				return fmt.Errorf("cannot unmarshal action: %w", err)
			}
		}
	}
	if v, ok := req["enabled"]; ok {
		err = json.Unmarshal(v, &r.enabled)
		if err != nil {
			err = json.Unmarshal(b, &r.enabled)
			if err != nil {
				return fmt.Errorf("cannot unmarshal enabled: %w", err)
			}
		}
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}
	if v, ok := req["triggerType"]; ok {
		err = json.Unmarshal(v, &r.triggerType)
		if err != nil {
			err = json.Unmarshal(b, &r.triggerType)
			if err != nil {
				return fmt.Errorf("cannot unmarshal triggerType: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTasksRequest represents the request with all the parameters for the API call.
type ApiGetTasksRequest struct {
	itemsPerPage  *int32
	page          *int32
	action        []ActionType
	enabled       *bool
	sourceID      []string
	destinationID []string
	triggerType   []TriggerType
	sort          TaskSortKeys
	order         OrderKeys
}

// NewApiGetTasksRequest creates an instance of the ApiGetTasksRequest to be used for the API call.
func (c *APIClient) NewApiGetTasksRequest() ApiGetTasksRequest {
	return ApiGetTasksRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithItemsPerPage(itemsPerPage int32) ApiGetTasksRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithPage(page int32) ApiGetTasksRequest {
	r.page = &page
	return r
}

// WithAction adds the action to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithAction(action []ActionType) ApiGetTasksRequest {
	r.action = action
	return r
}

// WithEnabled adds the enabled to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithEnabled(enabled bool) ApiGetTasksRequest {
	r.enabled = &enabled
	return r
}

// WithSourceID adds the sourceID to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithSourceID(sourceID []string) ApiGetTasksRequest {
	r.sourceID = sourceID
	return r
}

// WithDestinationID adds the destinationID to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithDestinationID(destinationID []string) ApiGetTasksRequest {
	r.destinationID = destinationID
	return r
}

// WithTriggerType adds the triggerType to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithTriggerType(triggerType []TriggerType) ApiGetTasksRequest {
	r.triggerType = triggerType
	return r
}

// WithSort adds the sort to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithSort(sort TaskSortKeys) ApiGetTasksRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithOrder(order OrderKeys) ApiGetTasksRequest {
	r.order = order
	return r
}

/*
GetTasks Wraps GetTasksWithContext using context.Background.

Retrieves a list of tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTasksRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param action []ActionType - Actions for filtering the list of tasks.
	@param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	@param sourceID []string - Source IDs for filtering the list of tasks.
	@param destinationID []string - Destination IDs for filtering the list of tasks.
	@param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	@param sort TaskSortKeys - Property by which to sort the list of tasks.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTasksResponse
*/
func (c *APIClient) GetTasks(r ApiGetTasksRequest, opts ...Option) (*ListTasksResponse, error) {
	return c.GetTasksWithContext(context.Background(), r, opts...)
}

/*
GetTasks

Retrieves a list of tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTasksRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param action []ActionType - Actions for filtering the list of tasks.
	@param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	@param sourceID []string - Source IDs for filtering the list of tasks.
	@param destinationID []string - Destination IDs for filtering the list of tasks.
	@param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	@param sort TaskSortKeys - Property by which to sort the list of tasks.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTasksResponse
*/
func (c *APIClient) GetTasksWithContext(ctx context.Context, r ApiGetTasksRequest, opts ...Option) (*ListTasksResponse, error) {
	var (
		postBody    any
		returnValue *ListTasksResponse
	)

	requestPath := "/1/tasks"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", queryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		queryParams.Set("page", queryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.action) {
		queryParams.Set("action", queryParameterToString(r.action))
	}
	if !utils.IsNilOrEmpty(r.enabled) {
		queryParams.Set("enabled", queryParameterToString(*r.enabled))
	}
	if !utils.IsNilOrEmpty(r.sourceID) {
		queryParams.Set("sourceID", queryParameterToString(r.sourceID))
	}
	if !utils.IsNilOrEmpty(r.destinationID) {
		queryParams.Set("destinationID", queryParameterToString(r.destinationID))
	}
	if !utils.IsNilOrEmpty(r.triggerType) {
		queryParams.Set("triggerType", queryParameterToString(r.triggerType))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		queryParams.Set("sort", queryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		queryParams.Set("order", queryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRunTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiRunTaskRequest represents the request with all the parameters for the API call.
type ApiRunTaskRequest struct {
	taskID string
}

// NewApiRunTaskRequest creates an instance of the ApiRunTaskRequest to be used for the API call.
func (c *APIClient) NewApiRunTaskRequest(taskID string) ApiRunTaskRequest {
	return ApiRunTaskRequest{
		taskID: taskID,
	}
}

/*
RunTask Wraps RunTaskWithContext using context.Background.

Runs a task. You can check the status of task runs with the observability endpoints.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiRunTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return RunResponse
*/
func (c *APIClient) RunTask(r ApiRunTaskRequest, opts ...Option) (*RunResponse, error) {
	return c.RunTaskWithContext(context.Background(), r, opts...)
}

/*
RunTask

Runs a task. You can check the status of task runs with the observability endpoints.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiRunTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return RunResponse
*/
func (c *APIClient) RunTaskWithContext(ctx context.Context, r ApiRunTaskRequest, opts ...Option) (*RunResponse, error) {
	var (
		postBody    any
		returnValue *RunResponse
	)

	requestPath := "/1/tasks/{taskID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskID == "" {
		return returnValue, reportError("Parameter `taskID` is required when calling `RunTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchAuthenticationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationSearch"]; ok {
		err = json.Unmarshal(v, &r.authenticationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter authenticationSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchAuthenticationsRequest represents the request with all the parameters for the API call.
type ApiSearchAuthenticationsRequest struct {
	authenticationSearch *AuthenticationSearch
}

// NewApiSearchAuthenticationsRequest creates an instance of the ApiSearchAuthenticationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchAuthenticationsRequest(authenticationSearch *AuthenticationSearch) ApiSearchAuthenticationsRequest {
	return ApiSearchAuthenticationsRequest{
		authenticationSearch: authenticationSearch,
	}
}

/*
SearchAuthentications Wraps SearchAuthenticationsWithContext using context.Background.

Searches for authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchAuthenticationsRequest with parameters below.

	@param authenticationSearch AuthenticationSearch
	@return []Authentication
*/
func (c *APIClient) SearchAuthentications(r ApiSearchAuthenticationsRequest, opts ...Option) ([]Authentication, error) {
	return c.SearchAuthenticationsWithContext(context.Background(), r, opts...)
}

/*
SearchAuthentications

Searches for authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchAuthenticationsRequest with parameters below.

	@param authenticationSearch AuthenticationSearch
	@return []Authentication
*/
func (c *APIClient) SearchAuthenticationsWithContext(ctx context.Context, r ApiSearchAuthenticationsRequest, opts ...Option) ([]Authentication, error) {
	var (
		postBody    any
		returnValue []Authentication
	)

	requestPath := "/1/authentications/search"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.authenticationSearch == nil {
		return returnValue, reportError("Parameter `authenticationSearch` is required when calling `SearchAuthentications`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.authenticationSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchDestinationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationSearch"]; ok {
		err = json.Unmarshal(v, &r.destinationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter destinationSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchDestinationsRequest represents the request with all the parameters for the API call.
type ApiSearchDestinationsRequest struct {
	destinationSearch *DestinationSearch
}

// NewApiSearchDestinationsRequest creates an instance of the ApiSearchDestinationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchDestinationsRequest(destinationSearch *DestinationSearch) ApiSearchDestinationsRequest {
	return ApiSearchDestinationsRequest{
		destinationSearch: destinationSearch,
	}
}

/*
SearchDestinations Wraps SearchDestinationsWithContext using context.Background.

Searches for destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchDestinationsRequest with parameters below.

	@param destinationSearch DestinationSearch
	@return []Destination
*/
func (c *APIClient) SearchDestinations(r ApiSearchDestinationsRequest, opts ...Option) ([]Destination, error) {
	return c.SearchDestinationsWithContext(context.Background(), r, opts...)
}

/*
SearchDestinations

Searches for destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchDestinationsRequest with parameters below.

	@param destinationSearch DestinationSearch
	@return []Destination
*/
func (c *APIClient) SearchDestinationsWithContext(ctx context.Context, r ApiSearchDestinationsRequest, opts ...Option) ([]Destination, error) {
	var (
		postBody    any
		returnValue []Destination
	)

	requestPath := "/1/destinations/search"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.destinationSearch == nil {
		return returnValue, reportError("Parameter `destinationSearch` is required when calling `SearchDestinations`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.destinationSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceSearch"]; ok {
		err = json.Unmarshal(v, &r.sourceSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchSourcesRequest represents the request with all the parameters for the API call.
type ApiSearchSourcesRequest struct {
	sourceSearch *SourceSearch
}

// NewApiSearchSourcesRequest creates an instance of the ApiSearchSourcesRequest to be used for the API call.
func (c *APIClient) NewApiSearchSourcesRequest(sourceSearch *SourceSearch) ApiSearchSourcesRequest {
	return ApiSearchSourcesRequest{
		sourceSearch: sourceSearch,
	}
}

/*
SearchSources Wraps SearchSourcesWithContext using context.Background.

Searches for sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchSourcesRequest with parameters below.

	@param sourceSearch SourceSearch
	@return []Source
*/
func (c *APIClient) SearchSources(r ApiSearchSourcesRequest, opts ...Option) ([]Source, error) {
	return c.SearchSourcesWithContext(context.Background(), r, opts...)
}

/*
SearchSources

Searches for sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchSourcesRequest with parameters below.

	@param sourceSearch SourceSearch
	@return []Source
*/
func (c *APIClient) SearchSourcesWithContext(ctx context.Context, r ApiSearchSourcesRequest, opts ...Option) ([]Source, error) {
	var (
		postBody    any
		returnValue []Source
	)

	requestPath := "/1/sources/search"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.sourceSearch == nil {
		return returnValue, reportError("Parameter `sourceSearch` is required when calling `SearchSources`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.sourceSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchTasksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskSearch"]; ok {
		err = json.Unmarshal(v, &r.taskSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.taskSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchTasksRequest represents the request with all the parameters for the API call.
type ApiSearchTasksRequest struct {
	taskSearch *TaskSearch
}

// NewApiSearchTasksRequest creates an instance of the ApiSearchTasksRequest to be used for the API call.
func (c *APIClient) NewApiSearchTasksRequest(taskSearch *TaskSearch) ApiSearchTasksRequest {
	return ApiSearchTasksRequest{
		taskSearch: taskSearch,
	}
}

/*
SearchTasks Wraps SearchTasksWithContext using context.Background.

Searches for tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTasksRequest with parameters below.

	@param taskSearch TaskSearch
	@return []Task
*/
func (c *APIClient) SearchTasks(r ApiSearchTasksRequest, opts ...Option) ([]Task, error) {
	return c.SearchTasksWithContext(context.Background(), r, opts...)
}

/*
SearchTasks

Searches for tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTasksRequest with parameters below.

	@param taskSearch TaskSearch
	@return []Task
*/
func (c *APIClient) SearchTasksWithContext(ctx context.Context, r ApiSearchTasksRequest, opts ...Option) ([]Task, error) {
	var (
		postBody    any
		returnValue []Task
	)

	requestPath := "/1/tasks/search"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.taskSearch == nil {
		return returnValue, reportError("Parameter `taskSearch` is required when calling `SearchTasks`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.taskSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiTriggerDockerSourceDiscoverRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiTriggerDockerSourceDiscoverRequest represents the request with all the parameters for the API call.
type ApiTriggerDockerSourceDiscoverRequest struct {
	sourceID string
}

// NewApiTriggerDockerSourceDiscoverRequest creates an instance of the ApiTriggerDockerSourceDiscoverRequest to be used for the API call.
func (c *APIClient) NewApiTriggerDockerSourceDiscoverRequest(sourceID string) ApiTriggerDockerSourceDiscoverRequest {
	return ApiTriggerDockerSourceDiscoverRequest{
		sourceID: sourceID,
	}
}

/*
TriggerDockerSourceDiscover Wraps TriggerDockerSourceDiscoverWithContext using context.Background.

Triggers a stream-listing request for a source.
Triggering stream-listing requests only works with sources with `type: docker` and `imageType: singer`.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTriggerDockerSourceDiscoverRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return DockerSourceDiscover
*/
func (c *APIClient) TriggerDockerSourceDiscover(r ApiTriggerDockerSourceDiscoverRequest, opts ...Option) (*DockerSourceDiscover, error) {
	return c.TriggerDockerSourceDiscoverWithContext(context.Background(), r, opts...)
}

/*
TriggerDockerSourceDiscover

Triggers a stream-listing request for a source.
Triggering stream-listing requests only works with sources with `type: docker` and `imageType: singer`.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTriggerDockerSourceDiscoverRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return DockerSourceDiscover
*/
func (c *APIClient) TriggerDockerSourceDiscoverWithContext(ctx context.Context, r ApiTriggerDockerSourceDiscoverRequest, opts ...Option) (*DockerSourceDiscover, error) {
	var (
		postBody    any
		returnValue *DockerSourceDiscover
	)

	requestPath := "/1/sources/{sourceID}/discover"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(parameterToString(r.sourceID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceID == "" {
		return returnValue, reportError("Parameter `sourceID` is required when calling `TriggerDockerSourceDiscover`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}
	if v, ok := req["authenticationUpdate"]; ok {
		err = json.Unmarshal(v, &r.authenticationUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter authenticationUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateAuthenticationRequest represents the request with all the parameters for the API call.
type ApiUpdateAuthenticationRequest struct {
	authenticationID     string
	authenticationUpdate *AuthenticationUpdate
}

// NewApiUpdateAuthenticationRequest creates an instance of the ApiUpdateAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateAuthenticationRequest(authenticationID string, authenticationUpdate *AuthenticationUpdate) ApiUpdateAuthenticationRequest {
	return ApiUpdateAuthenticationRequest{
		authenticationID:     authenticationID,
		authenticationUpdate: authenticationUpdate,
	}
}

/*
UpdateAuthentication Wraps UpdateAuthenticationWithContext using context.Background.

Updates an authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@param authenticationUpdate AuthenticationUpdate
	@return AuthenticationUpdateResponse
*/
func (c *APIClient) UpdateAuthentication(r ApiUpdateAuthenticationRequest, opts ...Option) (*AuthenticationUpdateResponse, error) {
	return c.UpdateAuthenticationWithContext(context.Background(), r, opts...)
}

/*
UpdateAuthentication

Updates an authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@param authenticationUpdate AuthenticationUpdate
	@return AuthenticationUpdateResponse
*/
func (c *APIClient) UpdateAuthenticationWithContext(ctx context.Context, r ApiUpdateAuthenticationRequest, opts ...Option) (*AuthenticationUpdateResponse, error) {
	var (
		postBody    any
		returnValue *AuthenticationUpdateResponse
	)

	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(parameterToString(r.authenticationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.authenticationID == "" {
		return returnValue, reportError("Parameter `authenticationID` is required when calling `UpdateAuthentication`.")
	}

	if r.authenticationUpdate == nil {
		return returnValue, reportError("Parameter `authenticationUpdate` is required when calling `UpdateAuthentication`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.authenticationUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}
	if v, ok := req["destinationUpdate"]; ok {
		err = json.Unmarshal(v, &r.destinationUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter destinationUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateDestinationRequest represents the request with all the parameters for the API call.
type ApiUpdateDestinationRequest struct {
	destinationID     string
	destinationUpdate *DestinationUpdate
}

// NewApiUpdateDestinationRequest creates an instance of the ApiUpdateDestinationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateDestinationRequest(destinationID string, destinationUpdate *DestinationUpdate) ApiUpdateDestinationRequest {
	return ApiUpdateDestinationRequest{
		destinationID:     destinationID,
		destinationUpdate: destinationUpdate,
	}
}

/*
UpdateDestination Wraps UpdateDestinationWithContext using context.Background.

Updates the destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@param destinationUpdate DestinationUpdate
	@return DestinationUpdateResponse
*/
func (c *APIClient) UpdateDestination(r ApiUpdateDestinationRequest, opts ...Option) (*DestinationUpdateResponse, error) {
	return c.UpdateDestinationWithContext(context.Background(), r, opts...)
}

/*
UpdateDestination

Updates the destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@param destinationUpdate DestinationUpdate
	@return DestinationUpdateResponse
*/
func (c *APIClient) UpdateDestinationWithContext(ctx context.Context, r ApiUpdateDestinationRequest, opts ...Option) (*DestinationUpdateResponse, error) {
	var (
		postBody    any
		returnValue *DestinationUpdateResponse
	)

	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(parameterToString(r.destinationID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.destinationID == "" {
		return returnValue, reportError("Parameter `destinationID` is required when calling `UpdateDestination`.")
	}

	if r.destinationUpdate == nil {
		return returnValue, reportError("Parameter `destinationUpdate` is required when calling `UpdateDestination`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.destinationUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}
	if v, ok := req["sourceUpdate"]; ok {
		err = json.Unmarshal(v, &r.sourceUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateSourceRequest represents the request with all the parameters for the API call.
type ApiUpdateSourceRequest struct {
	sourceID     string
	sourceUpdate *SourceUpdate
}

// NewApiUpdateSourceRequest creates an instance of the ApiUpdateSourceRequest to be used for the API call.
func (c *APIClient) NewApiUpdateSourceRequest(sourceID string, sourceUpdate *SourceUpdate) ApiUpdateSourceRequest {
	return ApiUpdateSourceRequest{
		sourceID:     sourceID,
		sourceUpdate: sourceUpdate,
	}
}

/*
UpdateSource Wraps UpdateSourceWithContext using context.Background.

Updates a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param sourceUpdate SourceUpdate
	@return SourceUpdateResponse
*/
func (c *APIClient) UpdateSource(r ApiUpdateSourceRequest, opts ...Option) (*SourceUpdateResponse, error) {
	return c.UpdateSourceWithContext(context.Background(), r, opts...)
}

/*
UpdateSource

Updates a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param sourceUpdate SourceUpdate
	@return SourceUpdateResponse
*/
func (c *APIClient) UpdateSourceWithContext(ctx context.Context, r ApiUpdateSourceRequest, opts ...Option) (*SourceUpdateResponse, error) {
	var (
		postBody    any
		returnValue *SourceUpdateResponse
	)

	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(parameterToString(r.sourceID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceID == "" {
		return returnValue, reportError("Parameter `sourceID` is required when calling `UpdateSource`.")
	}

	if r.sourceUpdate == nil {
		return returnValue, reportError("Parameter `sourceUpdate` is required when calling `UpdateSource`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.sourceUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}
	if v, ok := req["taskUpdate"]; ok {
		err = json.Unmarshal(v, &r.taskUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateTaskRequest represents the request with all the parameters for the API call.
type ApiUpdateTaskRequest struct {
	taskID     string
	taskUpdate *TaskUpdate
}

// NewApiUpdateTaskRequest creates an instance of the ApiUpdateTaskRequest to be used for the API call.
func (c *APIClient) NewApiUpdateTaskRequest(taskID string, taskUpdate *TaskUpdate) ApiUpdateTaskRequest {
	return ApiUpdateTaskRequest{
		taskID:     taskID,
		taskUpdate: taskUpdate,
	}
}

/*
UpdateTask Wraps UpdateTaskWithContext using context.Background.

Updates a task by its ID.

Request can be constructed by NewApiUpdateTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@param taskUpdate TaskUpdate
	@return TaskUpdateResponse
*/
func (c *APIClient) UpdateTask(r ApiUpdateTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	return c.UpdateTaskWithContext(context.Background(), r, opts...)
}

/*
UpdateTask

Updates a task by its ID.

Request can be constructed by NewApiUpdateTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@param taskUpdate TaskUpdate
	@return TaskUpdateResponse
*/
func (c *APIClient) UpdateTaskWithContext(ctx context.Context, r ApiUpdateTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	var (
		postBody    any
		returnValue *TaskUpdateResponse
	)

	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskID == "" {
		return returnValue, reportError("Parameter `taskID` is required when calling `UpdateTask`.")
	}

	if r.taskUpdate == nil {
		return returnValue, reportError("Parameter `taskUpdate` is required when calling `UpdateTask`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.taskUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, resBody, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
