// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package ingestion

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type config struct {
	// -- Request options for API calls
	context      context.Context
	queryParams  url.Values
	headerParams map[string]string
}

type RequestOption interface {
	apply(*config)
}

type requestOption func(*config)

func (r requestOption) apply(c *config) {
	r(c)
}

func WithContext(ctx context.Context) requestOption {
	return requestOption(func(c *config) {
		c.context = ctx
	})
}

func WithHeaderParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.headerParams[key] = utils.ParameterToString(value)
	})
}

func WithQueryParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.queryParams.Set(utils.QueryParameterToString(key), utils.QueryParameterToString(value))
	})
}

func (r *ApiCreateAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationCreate"]; ok {
		err = json.Unmarshal(v, &r.authenticationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter authenticationCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateAuthenticationRequest represents the request with all the parameters for the API call.
type ApiCreateAuthenticationRequest struct {
	authenticationCreate *AuthenticationCreate
}

// NewApiCreateAuthenticationRequest creates an instance of the ApiCreateAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiCreateAuthenticationRequest(authenticationCreate *AuthenticationCreate) ApiCreateAuthenticationRequest {
	return ApiCreateAuthenticationRequest{
		authenticationCreate: authenticationCreate,
	}
}

/*
CreateAuthentication calls the API and returns the raw response from it.

	  Creates a new authentication resource.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiCreateAuthenticationRequest with parameters below.
	  @param authenticationCreate AuthenticationCreate -
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CreateAuthenticationWithHTTPInfo(r ApiCreateAuthenticationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/authentications"

	if r.authenticationCreate == nil {
		return nil, nil, reportError("Parameter `authenticationCreate` is required when calling `CreateAuthentication`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.authenticationCreate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CreateAuthentication casts the HTTP response body to a defined struct.

Creates a new authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateAuthenticationRequest with parameters below.

	@param authenticationCreate AuthenticationCreate -
	@return AuthenticationCreateResponse
*/
func (c *APIClient) CreateAuthentication(r ApiCreateAuthenticationRequest, opts ...RequestOption) (*AuthenticationCreateResponse, error) {
	var returnValue *AuthenticationCreateResponse

	res, resBody, err := c.CreateAuthenticationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationCreate"]; ok {
		err = json.Unmarshal(v, &r.destinationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter destinationCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateDestinationRequest represents the request with all the parameters for the API call.
type ApiCreateDestinationRequest struct {
	destinationCreate *DestinationCreate
}

// NewApiCreateDestinationRequest creates an instance of the ApiCreateDestinationRequest to be used for the API call.
func (c *APIClient) NewApiCreateDestinationRequest(destinationCreate *DestinationCreate) ApiCreateDestinationRequest {
	return ApiCreateDestinationRequest{
		destinationCreate: destinationCreate,
	}
}

/*
CreateDestination calls the API and returns the raw response from it.

	  Creates a new destination.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiCreateDestinationRequest with parameters below.
	  @param destinationCreate DestinationCreate -
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CreateDestinationWithHTTPInfo(r ApiCreateDestinationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations"

	if r.destinationCreate == nil {
		return nil, nil, reportError("Parameter `destinationCreate` is required when calling `CreateDestination`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.destinationCreate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CreateDestination casts the HTTP response body to a defined struct.

Creates a new destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateDestinationRequest with parameters below.

	@param destinationCreate DestinationCreate -
	@return DestinationCreateResponse
*/
func (c *APIClient) CreateDestination(r ApiCreateDestinationRequest, opts ...RequestOption) (*DestinationCreateResponse, error) {
	var returnValue *DestinationCreateResponse

	res, resBody, err := c.CreateDestinationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceCreate"]; ok {
		err = json.Unmarshal(v, &r.sourceCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateSourceRequest represents the request with all the parameters for the API call.
type ApiCreateSourceRequest struct {
	sourceCreate *SourceCreate
}

// NewApiCreateSourceRequest creates an instance of the ApiCreateSourceRequest to be used for the API call.
func (c *APIClient) NewApiCreateSourceRequest(sourceCreate *SourceCreate) ApiCreateSourceRequest {
	return ApiCreateSourceRequest{
		sourceCreate: sourceCreate,
	}
}

/*
CreateSource calls the API and returns the raw response from it.

	  Creates a new source.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiCreateSourceRequest with parameters below.
	  @param sourceCreate SourceCreate -
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CreateSourceWithHTTPInfo(r ApiCreateSourceRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources"

	if r.sourceCreate == nil {
		return nil, nil, reportError("Parameter `sourceCreate` is required when calling `CreateSource`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.sourceCreate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CreateSource casts the HTTP response body to a defined struct.

Creates a new source.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceCreateResponse
*/
func (c *APIClient) CreateSource(r ApiCreateSourceRequest, opts ...RequestOption) (*SourceCreateResponse, error) {
	var returnValue *SourceCreateResponse

	res, resBody, err := c.CreateSourceWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskCreate"]; ok {
		err = json.Unmarshal(v, &r.taskCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateTaskRequest represents the request with all the parameters for the API call.
type ApiCreateTaskRequest struct {
	taskCreate *TaskCreate
}

// NewApiCreateTaskRequest creates an instance of the ApiCreateTaskRequest to be used for the API call.
func (c *APIClient) NewApiCreateTaskRequest(taskCreate *TaskCreate) ApiCreateTaskRequest {
	return ApiCreateTaskRequest{
		taskCreate: taskCreate,
	}
}

/*
CreateTask calls the API and returns the raw response from it.

	  Creates a new task.


	Request can be constructed by NewApiCreateTaskRequest with parameters below.
	  @param taskCreate TaskCreate - Request body for creating a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CreateTaskWithHTTPInfo(r ApiCreateTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks"

	if r.taskCreate == nil {
		return nil, nil, reportError("Parameter `taskCreate` is required when calling `CreateTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskCreate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CreateTask casts the HTTP response body to a defined struct.

Creates a new task.

Request can be constructed by NewApiCreateTaskRequest with parameters below.

	@param taskCreate TaskCreate - Request body for creating a task.
	@return TaskCreateResponse
*/
func (c *APIClient) CreateTask(r ApiCreateTaskRequest, opts ...RequestOption) (*TaskCreateResponse, error) {
	var returnValue *TaskCreateResponse

	res, resBody, err := c.CreateTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskCreate"]; ok {
		err = json.Unmarshal(v, &r.taskCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateTaskV1Request represents the request with all the parameters for the API call.
type ApiCreateTaskV1Request struct {
	taskCreate *TaskCreateV1
}

// NewApiCreateTaskV1Request creates an instance of the ApiCreateTaskV1Request to be used for the API call.
func (c *APIClient) NewApiCreateTaskV1Request(taskCreate *TaskCreateV1) ApiCreateTaskV1Request {
	return ApiCreateTaskV1Request{
		taskCreate: taskCreate,
	}
}

/*
CreateTaskV1 calls the API and returns the raw response from it.

	  Creates a new task using the v1 endpoint, please use `createTask` instead.


	Request can be constructed by NewApiCreateTaskV1Request with parameters below.
	  @param taskCreate TaskCreateV1 - Request body for creating a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CreateTaskV1WithHTTPInfo(r ApiCreateTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks"

	if r.taskCreate == nil {
		return nil, nil, reportError("Parameter `taskCreate` is required when calling `CreateTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskCreate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CreateTaskV1 casts the HTTP response body to a defined struct.

Creates a new task using the v1 endpoint, please use `createTask` instead.

Request can be constructed by NewApiCreateTaskV1Request with parameters below.

	@param taskCreate TaskCreateV1 - Request body for creating a task.
	@return TaskCreateResponse
*/
func (c *APIClient) CreateTaskV1(r ApiCreateTaskV1Request, opts ...RequestOption) (*TaskCreateResponse, error) {
	var returnValue *TaskCreateResponse

	res, resBody, err := c.CreateTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationCreate"]; ok {
		err = json.Unmarshal(v, &r.transformationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateTransformationRequest represents the request with all the parameters for the API call.
type ApiCreateTransformationRequest struct {
	transformationCreate *TransformationCreate
}

// NewApiCreateTransformationRequest creates an instance of the ApiCreateTransformationRequest to be used for the API call.
func (c *APIClient) NewApiCreateTransformationRequest(transformationCreate *TransformationCreate) ApiCreateTransformationRequest {
	return ApiCreateTransformationRequest{
		transformationCreate: transformationCreate,
	}
}

/*
CreateTransformation calls the API and returns the raw response from it.

	  Creates a new transformation.


	Request can be constructed by NewApiCreateTransformationRequest with parameters below.
	  @param transformationCreate TransformationCreate - Request body for creating a transformation.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CreateTransformationWithHTTPInfo(r ApiCreateTransformationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations"

	if r.transformationCreate == nil {
		return nil, nil, reportError("Parameter `transformationCreate` is required when calling `CreateTransformation`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.transformationCreate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CreateTransformation casts the HTTP response body to a defined struct.

Creates a new transformation.

Request can be constructed by NewApiCreateTransformationRequest with parameters below.

	@param transformationCreate TransformationCreate - Request body for creating a transformation.
	@return TransformationCreateResponse
*/
func (c *APIClient) CreateTransformation(r ApiCreateTransformationRequest, opts ...RequestOption) (*TransformationCreateResponse, error) {
	var returnValue *TransformationCreateResponse

	res, resBody, err := c.CreateTransformationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomDeleteRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomDeleteRequest represents the request with all the parameters for the API call.
type ApiCustomDeleteRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomDeleteRequest creates an instance of the ApiCustomDeleteRequest to be used for the API call.
func (c *APIClient) NewApiCustomDeleteRequest(path string) ApiCustomDeleteRequest {
	return ApiCustomDeleteRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomDeleteRequest and returns the request for chaining.
func (r ApiCustomDeleteRequest) WithParameters(parameters map[string]any) ApiCustomDeleteRequest {
	r.parameters = parameters
	return r
}

/*
CustomDelete calls the API and returns the raw response from it.

	  This method allow you to send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomDeleteRequest with parameters below.
	  @param path string - Path of the endpoint, anything after \"/1\" must be specified.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomDeleteWithHTTPInfo(r ApiCustomDeleteRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomDelete casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomDelete(r ApiCustomDeleteRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomGetRequest represents the request with all the parameters for the API call.
type ApiCustomGetRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomGetRequest creates an instance of the ApiCustomGetRequest to be used for the API call.
func (c *APIClient) NewApiCustomGetRequest(path string) ApiCustomGetRequest {
	return ApiCustomGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomGetRequest and returns the request for chaining.
func (r ApiCustomGetRequest) WithParameters(parameters map[string]any) ApiCustomGetRequest {
	r.parameters = parameters
	return r
}

/*
CustomGet calls the API and returns the raw response from it.

	  This method allow you to send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomGetRequest with parameters below.
	  @param path string - Path of the endpoint, anything after \"/1\" must be specified.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomGetWithHTTPInfo(r ApiCustomGetRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomGet casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomGet(r ApiCustomGetRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPostRequest represents the request with all the parameters for the API call.
type ApiCustomPostRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPostRequest creates an instance of the ApiCustomPostRequest to be used for the API call.
func (c *APIClient) NewApiCustomPostRequest(path string) ApiCustomPostRequest {
	return ApiCustomPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithParameters(parameters map[string]any) ApiCustomPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithBody(body map[string]any) ApiCustomPostRequest {
	r.body = body
	return r
}

/*
CustomPost calls the API and returns the raw response from it.

	  This method allow you to send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomPostRequest with parameters below.
	  @param path string - Path of the endpoint, anything after \"/1\" must be specified.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	  @param body map[string]any - Parameters to send with the custom request.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomPostWithHTTPInfo(r ApiCustomPostRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomPost casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPost(r ApiCustomPostRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPutRequest represents the request with all the parameters for the API call.
type ApiCustomPutRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPutRequest creates an instance of the ApiCustomPutRequest to be used for the API call.
func (c *APIClient) NewApiCustomPutRequest(path string) ApiCustomPutRequest {
	return ApiCustomPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithParameters(parameters map[string]any) ApiCustomPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithBody(body map[string]any) ApiCustomPutRequest {
	r.body = body
	return r
}

/*
CustomPut calls the API and returns the raw response from it.

	  This method allow you to send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomPutRequest with parameters below.
	  @param path string - Path of the endpoint, anything after \"/1\" must be specified.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	  @param body map[string]any - Parameters to send with the custom request.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomPutWithHTTPInfo(r ApiCustomPutRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomPut casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPut(r ApiCustomPutRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteAuthenticationRequest represents the request with all the parameters for the API call.
type ApiDeleteAuthenticationRequest struct {
	authenticationID string
}

// NewApiDeleteAuthenticationRequest creates an instance of the ApiDeleteAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteAuthenticationRequest(authenticationID string) ApiDeleteAuthenticationRequest {
	return ApiDeleteAuthenticationRequest{
		authenticationID: authenticationID,
	}
}

/*
DeleteAuthentication calls the API and returns the raw response from it.

	  Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiDeleteAuthenticationRequest with parameters below.
	  @param authenticationID string - Unique identifier of an authentication resource.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteAuthenticationWithHTTPInfo(r ApiDeleteAuthenticationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(utils.ParameterToString(r.authenticationID)))

	if r.authenticationID == "" {
		return nil, nil, reportError("Parameter `authenticationID` is required when calling `DeleteAuthentication`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteAuthentication casts the HTTP response body to a defined struct.

Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return DeleteResponse
*/
func (c *APIClient) DeleteAuthentication(r ApiDeleteAuthenticationRequest, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteAuthenticationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteDestinationRequest represents the request with all the parameters for the API call.
type ApiDeleteDestinationRequest struct {
	destinationID string
}

// NewApiDeleteDestinationRequest creates an instance of the ApiDeleteDestinationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteDestinationRequest(destinationID string) ApiDeleteDestinationRequest {
	return ApiDeleteDestinationRequest{
		destinationID: destinationID,
	}
}

/*
DeleteDestination calls the API and returns the raw response from it.

	  Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiDeleteDestinationRequest with parameters below.
	  @param destinationID string - Unique identifier of a destination.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteDestinationWithHTTPInfo(r ApiDeleteDestinationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(utils.ParameterToString(r.destinationID)))

	if r.destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `DeleteDestination`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteDestination casts the HTTP response body to a defined struct.

Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return DeleteResponse
*/
func (c *APIClient) DeleteDestination(r ApiDeleteDestinationRequest, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteDestinationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteSourceRequest represents the request with all the parameters for the API call.
type ApiDeleteSourceRequest struct {
	sourceID string
}

// NewApiDeleteSourceRequest creates an instance of the ApiDeleteSourceRequest to be used for the API call.
func (c *APIClient) NewApiDeleteSourceRequest(sourceID string) ApiDeleteSourceRequest {
	return ApiDeleteSourceRequest{
		sourceID: sourceID,
	}
}

/*
DeleteSource calls the API and returns the raw response from it.

	  Deletes a source by its ID. You can't delete sources that are referenced in tasks.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiDeleteSourceRequest with parameters below.
	  @param sourceID string - Unique identifier of a source.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteSourceWithHTTPInfo(r ApiDeleteSourceRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(r.sourceID)))

	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `DeleteSource`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteSource casts the HTTP response body to a defined struct.

Deletes a source by its ID. You can't delete sources that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return DeleteResponse
*/
func (c *APIClient) DeleteSource(r ApiDeleteSourceRequest, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteSourceWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteTaskRequest represents the request with all the parameters for the API call.
type ApiDeleteTaskRequest struct {
	taskID string
}

// NewApiDeleteTaskRequest creates an instance of the ApiDeleteTaskRequest to be used for the API call.
func (c *APIClient) NewApiDeleteTaskRequest(taskID string) ApiDeleteTaskRequest {
	return ApiDeleteTaskRequest{
		taskID: taskID,
	}
}

/*
DeleteTask calls the API and returns the raw response from it.

	  Deletes a task by its ID.


	Request can be constructed by NewApiDeleteTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteTaskWithHTTPInfo(r ApiDeleteTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DeleteTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteTask casts the HTTP response body to a defined struct.

Deletes a task by its ID.

Request can be constructed by NewApiDeleteTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTask(r ApiDeleteTaskRequest, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteTaskV1Request represents the request with all the parameters for the API call.
type ApiDeleteTaskV1Request struct {
	taskID string
}

// NewApiDeleteTaskV1Request creates an instance of the ApiDeleteTaskV1Request to be used for the API call.
func (c *APIClient) NewApiDeleteTaskV1Request(taskID string) ApiDeleteTaskV1Request {
	return ApiDeleteTaskV1Request{
		taskID: taskID,
	}
}

/*
DeleteTaskV1 calls the API and returns the raw response from it.

	  Deletes a task by its ID using the v1 endpoint, please use `deleteTask` instead.


	Request can be constructed by NewApiDeleteTaskV1Request with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteTaskV1WithHTTPInfo(r ApiDeleteTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DeleteTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteTaskV1 casts the HTTP response body to a defined struct.

Deletes a task by its ID using the v1 endpoint, please use `deleteTask` instead.

Request can be constructed by NewApiDeleteTaskV1Request with parameters below.

	@param taskID string - Unique identifier of a task.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTaskV1(r ApiDeleteTaskV1Request, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationID"]; ok {
		err = json.Unmarshal(v, &r.transformationID)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteTransformationRequest represents the request with all the parameters for the API call.
type ApiDeleteTransformationRequest struct {
	transformationID string
}

// NewApiDeleteTransformationRequest creates an instance of the ApiDeleteTransformationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteTransformationRequest(transformationID string) ApiDeleteTransformationRequest {
	return ApiDeleteTransformationRequest{
		transformationID: transformationID,
	}
}

/*
DeleteTransformation calls the API and returns the raw response from it.

	  Deletes a transformation by its ID.


	Request can be constructed by NewApiDeleteTransformationRequest with parameters below.
	  @param transformationID string - Unique identifier of a transformation.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteTransformationWithHTTPInfo(r ApiDeleteTransformationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/{transformationID}"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(utils.ParameterToString(r.transformationID)))

	if r.transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `DeleteTransformation`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteTransformation casts the HTTP response body to a defined struct.

Deletes a transformation by its ID.

Request can be constructed by NewApiDeleteTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTransformation(r ApiDeleteTransformationRequest, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteTransformationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDisableTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiDisableTaskRequest represents the request with all the parameters for the API call.
type ApiDisableTaskRequest struct {
	taskID string
}

// NewApiDisableTaskRequest creates an instance of the ApiDisableTaskRequest to be used for the API call.
func (c *APIClient) NewApiDisableTaskRequest(taskID string) ApiDisableTaskRequest {
	return ApiDisableTaskRequest{
		taskID: taskID,
	}
}

/*
DisableTask calls the API and returns the raw response from it.

	  Disables a task.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiDisableTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DisableTaskWithHTTPInfo(r ApiDisableTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}/disable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DisableTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DisableTask casts the HTTP response body to a defined struct.

Disables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDisableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) DisableTask(r ApiDisableTaskRequest, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.DisableTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDisableTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiDisableTaskV1Request represents the request with all the parameters for the API call.
type ApiDisableTaskV1Request struct {
	taskID string
}

// Deprecated
// NewApiDisableTaskV1Request creates an instance of the ApiDisableTaskV1Request to be used for the API call.
func (c *APIClient) NewApiDisableTaskV1Request(taskID string) ApiDisableTaskV1Request {
	return ApiDisableTaskV1Request{
		taskID: taskID,
	}
}

/*
DisableTaskV1 calls the API and returns the raw response from it.

	  Disables a task using the v1 endpoint, please use `disableTask` instead.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiDisableTaskV1Request with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails

	  Deprecated
*/
func (c *APIClient) DisableTaskV1WithHTTPInfo(r ApiDisableTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}/disable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DisableTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DisableTaskV1 casts the HTTP response body to a defined struct.

Disables a task using the v1 endpoint, please use `disableTask` instead.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDisableTaskV1Request with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse

Deprecated.
*/
func (c *APIClient) DisableTaskV1(r ApiDisableTaskV1Request, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.DisableTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiEnableTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiEnableTaskRequest represents the request with all the parameters for the API call.
type ApiEnableTaskRequest struct {
	taskID string
}

// NewApiEnableTaskRequest creates an instance of the ApiEnableTaskRequest to be used for the API call.
func (c *APIClient) NewApiEnableTaskRequest(taskID string) ApiEnableTaskRequest {
	return ApiEnableTaskRequest{
		taskID: taskID,
	}
}

/*
EnableTask calls the API and returns the raw response from it.

	  Enables a task.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiEnableTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) EnableTaskWithHTTPInfo(r ApiEnableTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}/enable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `EnableTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
EnableTask casts the HTTP response body to a defined struct.

Enables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiEnableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) EnableTask(r ApiEnableTaskRequest, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.EnableTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiEnableTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiEnableTaskV1Request represents the request with all the parameters for the API call.
type ApiEnableTaskV1Request struct {
	taskID string
}

// NewApiEnableTaskV1Request creates an instance of the ApiEnableTaskV1Request to be used for the API call.
func (c *APIClient) NewApiEnableTaskV1Request(taskID string) ApiEnableTaskV1Request {
	return ApiEnableTaskV1Request{
		taskID: taskID,
	}
}

/*
EnableTaskV1 calls the API and returns the raw response from it.

	  Enables a task using the v1 endpoint, please use `enableTask` instead.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiEnableTaskV1Request with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) EnableTaskV1WithHTTPInfo(r ApiEnableTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}/enable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `EnableTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
EnableTaskV1 casts the HTTP response body to a defined struct.

Enables a task using the v1 endpoint, please use `enableTask` instead.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiEnableTaskV1Request with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) EnableTaskV1(r ApiEnableTaskV1Request, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.EnableTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGenerateTransformationCodeRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["generateTransformationCodePayload"]; ok {
		err = json.Unmarshal(v, &r.generateTransformationCodePayload)
		if err != nil {
			err = json.Unmarshal(b, &r.generateTransformationCodePayload)
			if err != nil {
				return fmt.Errorf("cannot unmarshal generateTransformationCodePayload: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.generateTransformationCodePayload)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter generateTransformationCodePayload: %w", err)
		}
	}

	return nil
}

// ApiGenerateTransformationCodeRequest represents the request with all the parameters for the API call.
type ApiGenerateTransformationCodeRequest struct {
	generateTransformationCodePayload *GenerateTransformationCodePayload
}

// NewApiGenerateTransformationCodeRequest creates an instance of the ApiGenerateTransformationCodeRequest to be used for the API call.
func (c *APIClient) NewApiGenerateTransformationCodeRequest(generateTransformationCodePayload *GenerateTransformationCodePayload) ApiGenerateTransformationCodeRequest {
	return ApiGenerateTransformationCodeRequest{
		generateTransformationCodePayload: generateTransformationCodePayload,
	}
}

/*
GenerateTransformationCode calls the API and returns the raw response from it.

	  Generates code for the selected model based on the given prompt.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGenerateTransformationCodeRequest with parameters below.
	  @param generateTransformationCodePayload GenerateTransformationCodePayload
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GenerateTransformationCodeWithHTTPInfo(r ApiGenerateTransformationCodeRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/models"

	if r.generateTransformationCodePayload == nil {
		return nil, nil, reportError("Parameter `generateTransformationCodePayload` is required when calling `GenerateTransformationCode`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.generateTransformationCodePayload
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GenerateTransformationCode casts the HTTP response body to a defined struct.

Generates code for the selected model based on the given prompt.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGenerateTransformationCodeRequest with parameters below.

	@param generateTransformationCodePayload GenerateTransformationCodePayload
	@return GenerateTransformationCodeResponse
*/
func (c *APIClient) GenerateTransformationCode(r ApiGenerateTransformationCodeRequest, opts ...RequestOption) (*GenerateTransformationCodeResponse, error) {
	var returnValue *GenerateTransformationCodeResponse

	res, resBody, err := c.GenerateTransformationCodeWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetAuthenticationRequest represents the request with all the parameters for the API call.
type ApiGetAuthenticationRequest struct {
	authenticationID string
}

// NewApiGetAuthenticationRequest creates an instance of the ApiGetAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiGetAuthenticationRequest(authenticationID string) ApiGetAuthenticationRequest {
	return ApiGetAuthenticationRequest{
		authenticationID: authenticationID,
	}
}

/*
GetAuthentication calls the API and returns the raw response from it.

	  Retrieves an authentication resource by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetAuthenticationRequest with parameters below.
	  @param authenticationID string - Unique identifier of an authentication resource.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetAuthenticationWithHTTPInfo(r ApiGetAuthenticationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(utils.ParameterToString(r.authenticationID)))

	if r.authenticationID == "" {
		return nil, nil, reportError("Parameter `authenticationID` is required when calling `GetAuthentication`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetAuthentication casts the HTTP response body to a defined struct.

Retrieves an authentication resource by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return Authentication
*/
func (c *APIClient) GetAuthentication(r ApiGetAuthenticationRequest, opts ...RequestOption) (*Authentication, error) {
	var returnValue *Authentication

	res, resBody, err := c.GetAuthenticationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetDestinationRequest represents the request with all the parameters for the API call.
type ApiGetDestinationRequest struct {
	destinationID string
}

// NewApiGetDestinationRequest creates an instance of the ApiGetDestinationRequest to be used for the API call.
func (c *APIClient) NewApiGetDestinationRequest(destinationID string) ApiGetDestinationRequest {
	return ApiGetDestinationRequest{
		destinationID: destinationID,
	}
}

/*
GetDestination calls the API and returns the raw response from it.

	  Retrieves a destination by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetDestinationRequest with parameters below.
	  @param destinationID string - Unique identifier of a destination.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetDestinationWithHTTPInfo(r ApiGetDestinationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(utils.ParameterToString(r.destinationID)))

	if r.destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `GetDestination`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetDestination casts the HTTP response body to a defined struct.

Retrieves a destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return Destination
*/
func (c *APIClient) GetDestination(r ApiGetDestinationRequest, opts ...RequestOption) (*Destination, error) {
	var returnValue *Destination

	res, resBody, err := c.GetDestinationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetEventRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runID: %w", err)
			}
		}
	}
	if v, ok := req["eventID"]; ok {
		err = json.Unmarshal(v, &r.eventID)
		if err != nil {
			err = json.Unmarshal(b, &r.eventID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal eventID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetEventRequest represents the request with all the parameters for the API call.
type ApiGetEventRequest struct {
	runID   string
	eventID string
}

// NewApiGetEventRequest creates an instance of the ApiGetEventRequest to be used for the API call.
func (c *APIClient) NewApiGetEventRequest(runID string, eventID string) ApiGetEventRequest {
	return ApiGetEventRequest{
		runID:   runID,
		eventID: eventID,
	}
}

/*
GetEvent calls the API and returns the raw response from it.

	  Retrieves a single task run event by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetEventRequest with parameters below.
	  @param runID string - Unique identifier of a task run.
	  @param eventID string - Unique identifier of an event.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetEventWithHTTPInfo(r ApiGetEventRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/runs/{runID}/events/{eventID}"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(utils.ParameterToString(r.runID)))
	requestPath = strings.ReplaceAll(requestPath, "{eventID}", url.PathEscape(utils.ParameterToString(r.eventID)))

	if r.runID == "" {
		return nil, nil, reportError("Parameter `runID` is required when calling `GetEvent`.")
	}
	if r.eventID == "" {
		return nil, nil, reportError("Parameter `eventID` is required when calling `GetEvent`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetEvent casts the HTTP response body to a defined struct.

Retrieves a single task run event by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetEventRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param eventID string - Unique identifier of an event.
	@return Event
*/
func (c *APIClient) GetEvent(r ApiGetEventRequest, opts ...RequestOption) (*Event, error) {
	var returnValue *Event

	res, resBody, err := c.GetEventWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRunRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetRunRequest represents the request with all the parameters for the API call.
type ApiGetRunRequest struct {
	runID string
}

// NewApiGetRunRequest creates an instance of the ApiGetRunRequest to be used for the API call.
func (c *APIClient) NewApiGetRunRequest(runID string) ApiGetRunRequest {
	return ApiGetRunRequest{
		runID: runID,
	}
}

/*
GetRun calls the API and returns the raw response from it.

	  Retrieve a single task run by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetRunRequest with parameters below.
	  @param runID string - Unique identifier of a task run.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetRunWithHTTPInfo(r ApiGetRunRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/runs/{runID}"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(utils.ParameterToString(r.runID)))

	if r.runID == "" {
		return nil, nil, reportError("Parameter `runID` is required when calling `GetRun`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetRun casts the HTTP response body to a defined struct.

Retrieve a single task run by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetRunRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@return Run
*/
func (c *APIClient) GetRun(r ApiGetRunRequest, opts ...RequestOption) (*Run, error) {
	var returnValue *Run

	res, resBody, err := c.GetRunWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSourceRequest represents the request with all the parameters for the API call.
type ApiGetSourceRequest struct {
	sourceID string
}

// NewApiGetSourceRequest creates an instance of the ApiGetSourceRequest to be used for the API call.
func (c *APIClient) NewApiGetSourceRequest(sourceID string) ApiGetSourceRequest {
	return ApiGetSourceRequest{
		sourceID: sourceID,
	}
}

/*
GetSource calls the API and returns the raw response from it.

	  Retrieve a source by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetSourceRequest with parameters below.
	  @param sourceID string - Unique identifier of a source.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetSourceWithHTTPInfo(r ApiGetSourceRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(r.sourceID)))

	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `GetSource`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetSource casts the HTTP response body to a defined struct.

Retrieve a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return Source
*/
func (c *APIClient) GetSource(r ApiGetSourceRequest, opts ...RequestOption) (*Source, error) {
	var returnValue *Source

	res, resBody, err := c.GetSourceWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTaskRequest represents the request with all the parameters for the API call.
type ApiGetTaskRequest struct {
	taskID string
}

// NewApiGetTaskRequest creates an instance of the ApiGetTaskRequest to be used for the API call.
func (c *APIClient) NewApiGetTaskRequest(taskID string) ApiGetTaskRequest {
	return ApiGetTaskRequest{
		taskID: taskID,
	}
}

/*
GetTask calls the API and returns the raw response from it.

	  Retrieves a task by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTaskWithHTTPInfo(r ApiGetTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `GetTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetTask casts the HTTP response body to a defined struct.

Retrieves a task by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return Task
*/
func (c *APIClient) GetTask(r ApiGetTaskRequest, opts ...RequestOption) (*Task, error) {
	var returnValue *Task

	res, resBody, err := c.GetTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTaskV1Request represents the request with all the parameters for the API call.
type ApiGetTaskV1Request struct {
	taskID string
}

// NewApiGetTaskV1Request creates an instance of the ApiGetTaskV1Request to be used for the API call.
func (c *APIClient) NewApiGetTaskV1Request(taskID string) ApiGetTaskV1Request {
	return ApiGetTaskV1Request{
		taskID: taskID,
	}
}

/*
GetTaskV1 calls the API and returns the raw response from it.

	  Retrieves a task by its ID using the v1 endpoint, please use `getTask` instead.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetTaskV1Request with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTaskV1WithHTTPInfo(r ApiGetTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `GetTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetTaskV1 casts the HTTP response body to a defined struct.

Retrieves a task by its ID using the v1 endpoint, please use `getTask` instead.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTaskV1Request with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskV1
*/
func (c *APIClient) GetTaskV1(r ApiGetTaskV1Request, opts ...RequestOption) (*TaskV1, error) {
	var returnValue *TaskV1

	res, resBody, err := c.GetTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationID"]; ok {
		err = json.Unmarshal(v, &r.transformationID)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTransformationRequest represents the request with all the parameters for the API call.
type ApiGetTransformationRequest struct {
	transformationID string
}

// NewApiGetTransformationRequest creates an instance of the ApiGetTransformationRequest to be used for the API call.
func (c *APIClient) NewApiGetTransformationRequest(transformationID string) ApiGetTransformationRequest {
	return ApiGetTransformationRequest{
		transformationID: transformationID,
	}
}

/*
GetTransformation calls the API and returns the raw response from it.

	  Retrieves a transformation by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetTransformationRequest with parameters below.
	  @param transformationID string - Unique identifier of a transformation.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTransformationWithHTTPInfo(r ApiGetTransformationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/{transformationID}"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(utils.ParameterToString(r.transformationID)))

	if r.transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `GetTransformation`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetTransformation casts the HTTP response body to a defined struct.

Retrieves a transformation by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@return Transformation
*/
func (c *APIClient) GetTransformation(r ApiGetTransformationRequest, opts ...RequestOption) (*Transformation, error) {
	var returnValue *Transformation

	res, resBody, err := c.GetTransformationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListAuthenticationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["platform"]; ok {
		err = json.Unmarshal(v, &r.platform)
		if err != nil {
			err = json.Unmarshal(b, &r.platform)
			if err != nil {
				return fmt.Errorf("cannot unmarshal platform: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiListAuthenticationsRequest represents the request with all the parameters for the API call.
type ApiListAuthenticationsRequest struct {
	itemsPerPage *int32
	page         *int32
	type_        []AuthenticationType
	platform     []PlatformWithNone
	sort         AuthenticationSortKeys
	order        OrderKeys
}

// NewApiListAuthenticationsRequest creates an instance of the ApiListAuthenticationsRequest to be used for the API call.
func (c *APIClient) NewApiListAuthenticationsRequest() ApiListAuthenticationsRequest {
	return ApiListAuthenticationsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListAuthenticationsRequest and returns the request for chaining.
func (r ApiListAuthenticationsRequest) WithItemsPerPage(itemsPerPage int32) ApiListAuthenticationsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiListAuthenticationsRequest and returns the request for chaining.
func (r ApiListAuthenticationsRequest) WithPage(page int32) ApiListAuthenticationsRequest {
	r.page = &page
	return r
}

// WithType adds the type_ to the ApiListAuthenticationsRequest and returns the request for chaining.
func (r ApiListAuthenticationsRequest) WithType(type_ []AuthenticationType) ApiListAuthenticationsRequest {
	r.type_ = type_
	return r
}

// WithPlatform adds the platform to the ApiListAuthenticationsRequest and returns the request for chaining.
func (r ApiListAuthenticationsRequest) WithPlatform(platform []PlatformWithNone) ApiListAuthenticationsRequest {
	r.platform = platform
	return r
}

// WithSort adds the sort to the ApiListAuthenticationsRequest and returns the request for chaining.
func (r ApiListAuthenticationsRequest) WithSort(sort AuthenticationSortKeys) ApiListAuthenticationsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiListAuthenticationsRequest and returns the request for chaining.
func (r ApiListAuthenticationsRequest) WithOrder(order OrderKeys) ApiListAuthenticationsRequest {
	r.order = order
	return r
}

/*
ListAuthentications calls the API and returns the raw response from it.

	  Retrieves a list of all authentication resources.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListAuthenticationsRequest with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param type_ []AuthenticationType - Type of authentication resource to retrieve.
	  @param platform []PlatformWithNone - Ecommerce platform for which to retrieve authentication resources.
	  @param sort AuthenticationSortKeys - Property by which to sort the list of authentication resources.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListAuthenticationsWithHTTPInfo(r ApiListAuthenticationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/authentications"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		conf.queryParams.Set("type", utils.QueryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.platform) {
		conf.queryParams.Set("platform", utils.QueryParameterToString(r.platform))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListAuthentications casts the HTTP response body to a defined struct.

Retrieves a list of all authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListAuthenticationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []AuthenticationType - Type of authentication resource to retrieve.
	@param platform []PlatformWithNone - Ecommerce platform for which to retrieve authentication resources.
	@param sort AuthenticationSortKeys - Property by which to sort the list of authentication resources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListAuthenticationsResponse
*/
func (c *APIClient) ListAuthentications(r ApiListAuthenticationsRequest, opts ...RequestOption) (*ListAuthenticationsResponse, error) {
	var returnValue *ListAuthenticationsResponse

	res, resBody, err := c.ListAuthenticationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListDestinationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiListDestinationsRequest represents the request with all the parameters for the API call.
type ApiListDestinationsRequest struct {
	itemsPerPage     *int32
	page             *int32
	type_            []DestinationType
	authenticationID []string
	sort             DestinationSortKeys
	order            OrderKeys
}

// NewApiListDestinationsRequest creates an instance of the ApiListDestinationsRequest to be used for the API call.
func (c *APIClient) NewApiListDestinationsRequest() ApiListDestinationsRequest {
	return ApiListDestinationsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithItemsPerPage(itemsPerPage int32) ApiListDestinationsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithPage(page int32) ApiListDestinationsRequest {
	r.page = &page
	return r
}

// WithType adds the type_ to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithType(type_ []DestinationType) ApiListDestinationsRequest {
	r.type_ = type_
	return r
}

// WithAuthenticationID adds the authenticationID to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithAuthenticationID(authenticationID []string) ApiListDestinationsRequest {
	r.authenticationID = authenticationID
	return r
}

// WithSort adds the sort to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithSort(sort DestinationSortKeys) ApiListDestinationsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithOrder(order OrderKeys) ApiListDestinationsRequest {
	r.order = order
	return r
}

/*
ListDestinations calls the API and returns the raw response from it.

	  Retrieves a list of destinations.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListDestinationsRequest with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param type_ []DestinationType - Destination type.
	  @param authenticationID []string - Authentication ID used by destinations.
	  @param sort DestinationSortKeys - Property by which to sort the destinations.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListDestinationsWithHTTPInfo(r ApiListDestinationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		conf.queryParams.Set("type", utils.QueryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.authenticationID) {
		conf.queryParams.Set("authenticationID", utils.QueryParameterToString(r.authenticationID))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListDestinations casts the HTTP response body to a defined struct.

Retrieves a list of destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListDestinationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []DestinationType - Destination type.
	@param authenticationID []string - Authentication ID used by destinations.
	@param sort DestinationSortKeys - Property by which to sort the destinations.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListDestinationsResponse
*/
func (c *APIClient) ListDestinations(r ApiListDestinationsRequest, opts ...RequestOption) (*ListDestinationsResponse, error) {
	var returnValue *ListDestinationsResponse

	res, resBody, err := c.ListDestinationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListEventsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runID: %w", err)
			}
		}
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["status"]; ok {
		err = json.Unmarshal(v, &r.status)
		if err != nil {
			err = json.Unmarshal(b, &r.status)
			if err != nil {
				return fmt.Errorf("cannot unmarshal status: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}

	return nil
}

// ApiListEventsRequest represents the request with all the parameters for the API call.
type ApiListEventsRequest struct {
	runID        string
	itemsPerPage *int32
	page         *int32
	status       []EventStatus
	type_        []EventType
	sort         EventSortKeys
	order        OrderKeys
	startDate    *string
	endDate      *string
}

// NewApiListEventsRequest creates an instance of the ApiListEventsRequest to be used for the API call.
func (c *APIClient) NewApiListEventsRequest(runID string) ApiListEventsRequest {
	return ApiListEventsRequest{
		runID: runID,
	}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithItemsPerPage(itemsPerPage int32) ApiListEventsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithPage(page int32) ApiListEventsRequest {
	r.page = &page
	return r
}

// WithStatus adds the status to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithStatus(status []EventStatus) ApiListEventsRequest {
	r.status = status
	return r
}

// WithType adds the type_ to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithType(type_ []EventType) ApiListEventsRequest {
	r.type_ = type_
	return r
}

// WithSort adds the sort to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithSort(sort EventSortKeys) ApiListEventsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithOrder(order OrderKeys) ApiListEventsRequest {
	r.order = order
	return r
}

// WithStartDate adds the startDate to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithStartDate(startDate string) ApiListEventsRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithEndDate(endDate string) ApiListEventsRequest {
	r.endDate = &endDate
	return r
}

/*
ListEvents calls the API and returns the raw response from it.

	  Retrieves a list of events for a task run, identified by it's ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListEventsRequest with parameters below.
	  @param runID string - Unique identifier of a task run.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param status []EventStatus - Event status for filtering the list of task runs.
	  @param type_ []EventType - Event type for filtering the list of task runs.
	  @param sort EventSortKeys - Property by which to sort the list of task run events.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	  @param startDate string - Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
	  @param endDate string - Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListEventsWithHTTPInfo(r ApiListEventsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/runs/{runID}/events"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(utils.ParameterToString(r.runID)))

	if r.runID == "" {
		return nil, nil, reportError("Parameter `runID` is required when calling `ListEvents`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.status) {
		conf.queryParams.Set("status", utils.QueryParameterToString(r.status))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		conf.queryParams.Set("type", utils.QueryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListEvents casts the HTTP response body to a defined struct.

Retrieves a list of events for a task run, identified by it's ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListEventsRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []EventStatus - Event status for filtering the list of task runs.
	@param type_ []EventType - Event type for filtering the list of task runs.
	@param sort EventSortKeys - Property by which to sort the list of task run events.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
	@param endDate string - Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used.
	@return ListEventsResponse
*/
func (c *APIClient) ListEvents(r ApiListEventsRequest, opts ...RequestOption) (*ListEventsResponse, error) {
	var returnValue *ListEventsResponse

	res, resBody, err := c.ListEventsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListRunsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["status"]; ok {
		err = json.Unmarshal(v, &r.status)
		if err != nil {
			err = json.Unmarshal(b, &r.status)
			if err != nil {
				return fmt.Errorf("cannot unmarshal status: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}

	return nil
}

// ApiListRunsRequest represents the request with all the parameters for the API call.
type ApiListRunsRequest struct {
	itemsPerPage *int32
	page         *int32
	status       []RunStatus
	type_        []RunType
	taskID       *string
	sort         RunSortKeys
	order        OrderKeys
	startDate    *string
	endDate      *string
}

// NewApiListRunsRequest creates an instance of the ApiListRunsRequest to be used for the API call.
func (c *APIClient) NewApiListRunsRequest() ApiListRunsRequest {
	return ApiListRunsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithItemsPerPage(itemsPerPage int32) ApiListRunsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithPage(page int32) ApiListRunsRequest {
	r.page = &page
	return r
}

// WithStatus adds the status to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithStatus(status []RunStatus) ApiListRunsRequest {
	r.status = status
	return r
}

// WithType adds the type_ to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithType(type_ []RunType) ApiListRunsRequest {
	r.type_ = type_
	return r
}

// WithTaskID adds the taskID to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithTaskID(taskID string) ApiListRunsRequest {
	r.taskID = &taskID
	return r
}

// WithSort adds the sort to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithSort(sort RunSortKeys) ApiListRunsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithOrder(order OrderKeys) ApiListRunsRequest {
	r.order = order
	return r
}

// WithStartDate adds the startDate to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithStartDate(startDate string) ApiListRunsRequest {
	r.startDate = &startDate
	return r
}

// WithEndDate adds the endDate to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithEndDate(endDate string) ApiListRunsRequest {
	r.endDate = &endDate
	return r
}

/*
ListRuns calls the API and returns the raw response from it.

	  Retrieve a list of task runs.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListRunsRequest with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param status []RunStatus - Run status for filtering the list of task runs.
	  @param type_ []RunType - Run type for filtering the list of task runs.
	  @param taskID string - Task ID for filtering the list of task runs.
	  @param sort RunSortKeys - Property by which to sort the list of task runs.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	  @param startDate string - Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
	  @param endDate string - Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListRunsWithHTTPInfo(r ApiListRunsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/runs"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.status) {
		conf.queryParams.Set("status", utils.QueryParameterToString(r.status))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		conf.queryParams.Set("type", utils.QueryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.taskID) {
		conf.queryParams.Set("taskID", utils.QueryParameterToString(*r.taskID))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}
	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}
	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListRuns casts the HTTP response body to a defined struct.

Retrieve a list of task runs.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListRunsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []RunStatus - Run status for filtering the list of task runs.
	@param type_ []RunType - Run type for filtering the list of task runs.
	@param taskID string - Task ID for filtering the list of task runs.
	@param sort RunSortKeys - Property by which to sort the list of task runs.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
	@param endDate string - Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used.
	@return RunListResponse
*/
func (c *APIClient) ListRuns(r ApiListRunsRequest, opts ...RequestOption) (*RunListResponse, error) {
	var returnValue *RunListResponse

	res, resBody, err := c.ListRunsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiListSourcesRequest represents the request with all the parameters for the API call.
type ApiListSourcesRequest struct {
	itemsPerPage     *int32
	page             *int32
	type_            []SourceType
	authenticationID []string
	sort             SourceSortKeys
	order            OrderKeys
}

// NewApiListSourcesRequest creates an instance of the ApiListSourcesRequest to be used for the API call.
func (c *APIClient) NewApiListSourcesRequest() ApiListSourcesRequest {
	return ApiListSourcesRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListSourcesRequest and returns the request for chaining.
func (r ApiListSourcesRequest) WithItemsPerPage(itemsPerPage int32) ApiListSourcesRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiListSourcesRequest and returns the request for chaining.
func (r ApiListSourcesRequest) WithPage(page int32) ApiListSourcesRequest {
	r.page = &page
	return r
}

// WithType adds the type_ to the ApiListSourcesRequest and returns the request for chaining.
func (r ApiListSourcesRequest) WithType(type_ []SourceType) ApiListSourcesRequest {
	r.type_ = type_
	return r
}

// WithAuthenticationID adds the authenticationID to the ApiListSourcesRequest and returns the request for chaining.
func (r ApiListSourcesRequest) WithAuthenticationID(authenticationID []string) ApiListSourcesRequest {
	r.authenticationID = authenticationID
	return r
}

// WithSort adds the sort to the ApiListSourcesRequest and returns the request for chaining.
func (r ApiListSourcesRequest) WithSort(sort SourceSortKeys) ApiListSourcesRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiListSourcesRequest and returns the request for chaining.
func (r ApiListSourcesRequest) WithOrder(order OrderKeys) ApiListSourcesRequest {
	r.order = order
	return r
}

/*
ListSources calls the API and returns the raw response from it.

	  Retrieves a list of sources.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListSourcesRequest with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param type_ []SourceType - Source type. Some sources require authentication.
	  @param authenticationID []string - Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication resource.
	  @param sort SourceSortKeys - Property by which to sort the list of sources.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListSourcesWithHTTPInfo(r ApiListSourcesRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.type_) {
		conf.queryParams.Set("type", utils.QueryParameterToString(r.type_))
	}
	if !utils.IsNilOrEmpty(r.authenticationID) {
		conf.queryParams.Set("authenticationID", utils.QueryParameterToString(r.authenticationID))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListSources casts the HTTP response body to a defined struct.

Retrieves a list of sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListSourcesRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []SourceType - Source type. Some sources require authentication.
	@param authenticationID []string - Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication resource.
	@param sort SourceSortKeys - Property by which to sort the list of sources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListSourcesResponse
*/
func (c *APIClient) ListSources(r ApiListSourcesRequest, opts ...RequestOption) (*ListSourcesResponse, error) {
	var returnValue *ListSourcesResponse

	res, resBody, err := c.ListSourcesWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListTasksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["action"]; ok {
		err = json.Unmarshal(v, &r.action)
		if err != nil {
			err = json.Unmarshal(b, &r.action)
			if err != nil {
				return fmt.Errorf("cannot unmarshal action: %w", err)
			}
		}
	}
	if v, ok := req["enabled"]; ok {
		err = json.Unmarshal(v, &r.enabled)
		if err != nil {
			err = json.Unmarshal(b, &r.enabled)
			if err != nil {
				return fmt.Errorf("cannot unmarshal enabled: %w", err)
			}
		}
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}
	if v, ok := req["triggerType"]; ok {
		err = json.Unmarshal(v, &r.triggerType)
		if err != nil {
			err = json.Unmarshal(b, &r.triggerType)
			if err != nil {
				return fmt.Errorf("cannot unmarshal triggerType: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiListTasksRequest represents the request with all the parameters for the API call.
type ApiListTasksRequest struct {
	itemsPerPage  *int32
	page          *int32
	action        []ActionType
	enabled       *bool
	sourceID      []string
	destinationID []string
	triggerType   []TriggerType
	sort          TaskSortKeys
	order         OrderKeys
}

// NewApiListTasksRequest creates an instance of the ApiListTasksRequest to be used for the API call.
func (c *APIClient) NewApiListTasksRequest() ApiListTasksRequest {
	return ApiListTasksRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithItemsPerPage(itemsPerPage int32) ApiListTasksRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithPage(page int32) ApiListTasksRequest {
	r.page = &page
	return r
}

// WithAction adds the action to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithAction(action []ActionType) ApiListTasksRequest {
	r.action = action
	return r
}

// WithEnabled adds the enabled to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithEnabled(enabled bool) ApiListTasksRequest {
	r.enabled = &enabled
	return r
}

// WithSourceID adds the sourceID to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithSourceID(sourceID []string) ApiListTasksRequest {
	r.sourceID = sourceID
	return r
}

// WithDestinationID adds the destinationID to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithDestinationID(destinationID []string) ApiListTasksRequest {
	r.destinationID = destinationID
	return r
}

// WithTriggerType adds the triggerType to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithTriggerType(triggerType []TriggerType) ApiListTasksRequest {
	r.triggerType = triggerType
	return r
}

// WithSort adds the sort to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithSort(sort TaskSortKeys) ApiListTasksRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithOrder(order OrderKeys) ApiListTasksRequest {
	r.order = order
	return r
}

/*
ListTasks calls the API and returns the raw response from it.

	  Retrieves a list of tasks.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListTasksRequest with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param action []ActionType - Actions for filtering the list of tasks.
	  @param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	  @param sourceID []string - Source IDs for filtering the list of tasks.
	  @param destinationID []string - Destination IDs for filtering the list of tasks.
	  @param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	  @param sort TaskSortKeys - Property by which to sort the list of tasks.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListTasksWithHTTPInfo(r ApiListTasksRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.action) {
		conf.queryParams.Set("action", utils.QueryParameterToString(r.action))
	}
	if !utils.IsNilOrEmpty(r.enabled) {
		conf.queryParams.Set("enabled", utils.QueryParameterToString(*r.enabled))
	}
	if !utils.IsNilOrEmpty(r.sourceID) {
		conf.queryParams.Set("sourceID", utils.QueryParameterToString(r.sourceID))
	}
	if !utils.IsNilOrEmpty(r.destinationID) {
		conf.queryParams.Set("destinationID", utils.QueryParameterToString(r.destinationID))
	}
	if !utils.IsNilOrEmpty(r.triggerType) {
		conf.queryParams.Set("triggerType", utils.QueryParameterToString(r.triggerType))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListTasks casts the HTTP response body to a defined struct.

Retrieves a list of tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListTasksRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param action []ActionType - Actions for filtering the list of tasks.
	@param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	@param sourceID []string - Source IDs for filtering the list of tasks.
	@param destinationID []string - Destination IDs for filtering the list of tasks.
	@param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	@param sort TaskSortKeys - Property by which to sort the list of tasks.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTasksResponse
*/
func (c *APIClient) ListTasks(r ApiListTasksRequest, opts ...RequestOption) (*ListTasksResponse, error) {
	var returnValue *ListTasksResponse

	res, resBody, err := c.ListTasksWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListTasksV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["action"]; ok {
		err = json.Unmarshal(v, &r.action)
		if err != nil {
			err = json.Unmarshal(b, &r.action)
			if err != nil {
				return fmt.Errorf("cannot unmarshal action: %w", err)
			}
		}
	}
	if v, ok := req["enabled"]; ok {
		err = json.Unmarshal(v, &r.enabled)
		if err != nil {
			err = json.Unmarshal(b, &r.enabled)
			if err != nil {
				return fmt.Errorf("cannot unmarshal enabled: %w", err)
			}
		}
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}
	if v, ok := req["triggerType"]; ok {
		err = json.Unmarshal(v, &r.triggerType)
		if err != nil {
			err = json.Unmarshal(b, &r.triggerType)
			if err != nil {
				return fmt.Errorf("cannot unmarshal triggerType: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiListTasksV1Request represents the request with all the parameters for the API call.
type ApiListTasksV1Request struct {
	itemsPerPage  *int32
	page          *int32
	action        []ActionType
	enabled       *bool
	sourceID      []string
	destinationID []string
	triggerType   []TriggerType
	sort          TaskSortKeys
	order         OrderKeys
}

// NewApiListTasksV1Request creates an instance of the ApiListTasksV1Request to be used for the API call.
func (c *APIClient) NewApiListTasksV1Request() ApiListTasksV1Request {
	return ApiListTasksV1Request{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithItemsPerPage(itemsPerPage int32) ApiListTasksV1Request {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithPage(page int32) ApiListTasksV1Request {
	r.page = &page
	return r
}

// WithAction adds the action to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithAction(action []ActionType) ApiListTasksV1Request {
	r.action = action
	return r
}

// WithEnabled adds the enabled to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithEnabled(enabled bool) ApiListTasksV1Request {
	r.enabled = &enabled
	return r
}

// WithSourceID adds the sourceID to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithSourceID(sourceID []string) ApiListTasksV1Request {
	r.sourceID = sourceID
	return r
}

// WithDestinationID adds the destinationID to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithDestinationID(destinationID []string) ApiListTasksV1Request {
	r.destinationID = destinationID
	return r
}

// WithTriggerType adds the triggerType to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithTriggerType(triggerType []TriggerType) ApiListTasksV1Request {
	r.triggerType = triggerType
	return r
}

// WithSort adds the sort to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithSort(sort TaskSortKeys) ApiListTasksV1Request {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithOrder(order OrderKeys) ApiListTasksV1Request {
	r.order = order
	return r
}

/*
ListTasksV1 calls the API and returns the raw response from it.

	  Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListTasksV1Request with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param action []ActionType - Actions for filtering the list of tasks.
	  @param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	  @param sourceID []string - Source IDs for filtering the list of tasks.
	  @param destinationID []string - Destination IDs for filtering the list of tasks.
	  @param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	  @param sort TaskSortKeys - Property by which to sort the list of tasks.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListTasksV1WithHTTPInfo(r ApiListTasksV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.action) {
		conf.queryParams.Set("action", utils.QueryParameterToString(r.action))
	}
	if !utils.IsNilOrEmpty(r.enabled) {
		conf.queryParams.Set("enabled", utils.QueryParameterToString(*r.enabled))
	}
	if !utils.IsNilOrEmpty(r.sourceID) {
		conf.queryParams.Set("sourceID", utils.QueryParameterToString(r.sourceID))
	}
	if !utils.IsNilOrEmpty(r.destinationID) {
		conf.queryParams.Set("destinationID", utils.QueryParameterToString(r.destinationID))
	}
	if !utils.IsNilOrEmpty(r.triggerType) {
		conf.queryParams.Set("triggerType", utils.QueryParameterToString(r.triggerType))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListTasksV1 casts the HTTP response body to a defined struct.

Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListTasksV1Request with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param action []ActionType - Actions for filtering the list of tasks.
	@param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	@param sourceID []string - Source IDs for filtering the list of tasks.
	@param destinationID []string - Destination IDs for filtering the list of tasks.
	@param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	@param sort TaskSortKeys - Property by which to sort the list of tasks.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTasksResponseV1
*/
func (c *APIClient) ListTasksV1(r ApiListTasksV1Request, opts ...RequestOption) (*ListTasksResponseV1, error) {
	var returnValue *ListTasksResponseV1

	res, resBody, err := c.ListTasksV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
ListTransformationModels calls the API and returns the raw response from it.

	  Retrieves a list of existing LLM transformation helpers.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListTransformationModelsRequest with parameters below.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListTransformationModelsWithHTTPInfo(opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/models"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListTransformationModels casts the HTTP response body to a defined struct.

Retrieves a list of existing LLM transformation helpers.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListTransformationModelsRequest with parameters below.

	@return TransformationModels
*/
func (c *APIClient) ListTransformationModels(opts ...RequestOption) (*TransformationModels, error) {
	var returnValue *TransformationModels

	res, resBody, err := c.ListTransformationModelsWithHTTPInfo(opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListTransformationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiListTransformationsRequest represents the request with all the parameters for the API call.
type ApiListTransformationsRequest struct {
	itemsPerPage *int32
	page         *int32
	sort         SortKeys
	order        OrderKeys
}

// NewApiListTransformationsRequest creates an instance of the ApiListTransformationsRequest to be used for the API call.
func (c *APIClient) NewApiListTransformationsRequest() ApiListTransformationsRequest {
	return ApiListTransformationsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListTransformationsRequest and returns the request for chaining.
func (r ApiListTransformationsRequest) WithItemsPerPage(itemsPerPage int32) ApiListTransformationsRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}

// WithPage adds the page to the ApiListTransformationsRequest and returns the request for chaining.
func (r ApiListTransformationsRequest) WithPage(page int32) ApiListTransformationsRequest {
	r.page = &page
	return r
}

// WithSort adds the sort to the ApiListTransformationsRequest and returns the request for chaining.
func (r ApiListTransformationsRequest) WithSort(sort SortKeys) ApiListTransformationsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiListTransformationsRequest and returns the request for chaining.
func (r ApiListTransformationsRequest) WithOrder(order OrderKeys) ApiListTransformationsRequest {
	r.order = order
	return r
}

/*
ListTransformations calls the API and returns the raw response from it.

	  Retrieves a list of transformations.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListTransformationsRequest with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param sort SortKeys - Property by which to sort the list.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListTransformationsWithHTTPInfo(r ApiListTransformationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}
	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}
	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}
	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ListTransformations casts the HTTP response body to a defined struct.

Retrieves a list of transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListTransformationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param sort SortKeys - Property by which to sort the list.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTransformationsResponse
*/
func (c *APIClient) ListTransformations(r ApiListTransformationsRequest, opts ...RequestOption) (*ListTransformationsResponse, error) {
	var returnValue *ListTransformationsResponse

	res, resBody, err := c.ListTransformationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPushTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}
	if v, ok := req["pushTaskPayload"]; ok {
		err = json.Unmarshal(v, &r.pushTaskPayload)
		if err != nil {
			err = json.Unmarshal(b, &r.pushTaskPayload)
			if err != nil {
				return fmt.Errorf("cannot unmarshal pushTaskPayload: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.pushTaskPayload)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter pushTaskPayload: %w", err)
		}
	}

	return nil
}

// ApiPushTaskRequest represents the request with all the parameters for the API call.
type ApiPushTaskRequest struct {
	taskID          string
	pushTaskPayload *PushTaskPayload
}

// NewApiPushTaskRequest creates an instance of the ApiPushTaskRequest to be used for the API call.
func (c *APIClient) NewApiPushTaskRequest(taskID string, pushTaskPayload *PushTaskPayload) ApiPushTaskRequest {
	return ApiPushTaskRequest{
		taskID:          taskID,
		pushTaskPayload: pushTaskPayload,
	}
}

/*
PushTask calls the API and returns the raw response from it.

	  Push a `batch` request payload through the Pipeline. You can check the status of task pushes with the observability endpoints.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiPushTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	  @param pushTaskPayload PushTaskPayload - Request body of a Search API `batch` request that will be pushed in the Connectors pipeline.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) PushTaskWithHTTPInfo(r ApiPushTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}/push"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `PushTask`.")
	}

	if r.pushTaskPayload == nil {
		return nil, nil, reportError("Parameter `pushTaskPayload` is required when calling `PushTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.pushTaskPayload
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
PushTask casts the HTTP response body to a defined struct.

Push a `batch` request payload through the Pipeline. You can check the status of task pushes with the observability endpoints.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiPushTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@param pushTaskPayload PushTaskPayload - Request body of a Search API `batch` request that will be pushed in the Connectors pipeline.
	@return RunResponse
*/
func (c *APIClient) PushTask(r ApiPushTaskRequest, opts ...RequestOption) (*RunResponse, error) {
	var returnValue *RunResponse

	res, resBody, err := c.PushTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRunSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}
	if v, ok := req["runSourcePayload"]; ok {
		err = json.Unmarshal(v, &r.runSourcePayload)
		if err != nil {
			err = json.Unmarshal(b, &r.runSourcePayload)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runSourcePayload: %w", err)
			}
		}
	}

	return nil
}

// ApiRunSourceRequest represents the request with all the parameters for the API call.
type ApiRunSourceRequest struct {
	sourceID         string
	runSourcePayload *RunSourcePayload
}

// NewApiRunSourceRequest creates an instance of the ApiRunSourceRequest to be used for the API call.
func (c *APIClient) NewApiRunSourceRequest(sourceID string) ApiRunSourceRequest {
	return ApiRunSourceRequest{
		sourceID: sourceID,
	}
}

// WithRunSourcePayload adds the runSourcePayload to the ApiRunSourceRequest and returns the request for chaining.
func (r ApiRunSourceRequest) WithRunSourcePayload(runSourcePayload *RunSourcePayload) ApiRunSourceRequest {
	r.runSourcePayload = runSourcePayload
	return r
}

/*
RunSource calls the API and returns the raw response from it.

	  Runs all tasks linked to a source, only available for Shopify sources. It will create 1 run per task.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiRunSourceRequest with parameters below.
	  @param sourceID string - Unique identifier of a source.
	  @param runSourcePayload RunSourcePayload -
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) RunSourceWithHTTPInfo(r ApiRunSourceRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(r.sourceID)))

	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `RunSource`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.runSourcePayload) {
		postBody = "{}"
	} else {
		postBody = r.runSourcePayload
	}
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
RunSource casts the HTTP response body to a defined struct.

Runs all tasks linked to a source, only available for Shopify sources. It will create 1 run per task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiRunSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param runSourcePayload RunSourcePayload -
	@return RunSourceResponse
*/
func (c *APIClient) RunSource(r ApiRunSourceRequest, opts ...RequestOption) (*RunSourceResponse, error) {
	var returnValue *RunSourceResponse

	res, resBody, err := c.RunSourceWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRunTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiRunTaskRequest represents the request with all the parameters for the API call.
type ApiRunTaskRequest struct {
	taskID string
}

// NewApiRunTaskRequest creates an instance of the ApiRunTaskRequest to be used for the API call.
func (c *APIClient) NewApiRunTaskRequest(taskID string) ApiRunTaskRequest {
	return ApiRunTaskRequest{
		taskID: taskID,
	}
}

/*
RunTask calls the API and returns the raw response from it.

	  Runs a task. You can check the status of task runs with the observability endpoints.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiRunTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) RunTaskWithHTTPInfo(r ApiRunTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `RunTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
RunTask casts the HTTP response body to a defined struct.

Runs a task. You can check the status of task runs with the observability endpoints.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiRunTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return RunResponse
*/
func (c *APIClient) RunTask(r ApiRunTaskRequest, opts ...RequestOption) (*RunResponse, error) {
	var returnValue *RunResponse

	res, resBody, err := c.RunTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRunTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiRunTaskV1Request represents the request with all the parameters for the API call.
type ApiRunTaskV1Request struct {
	taskID string
}

// NewApiRunTaskV1Request creates an instance of the ApiRunTaskV1Request to be used for the API call.
func (c *APIClient) NewApiRunTaskV1Request(taskID string) ApiRunTaskV1Request {
	return ApiRunTaskV1Request{
		taskID: taskID,
	}
}

/*
RunTaskV1 calls the API and returns the raw response from it.

	  Runs a task using the v1 endpoint, please use `runTask` instead. You can check the status of task runs with the observability endpoints.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiRunTaskV1Request with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) RunTaskV1WithHTTPInfo(r ApiRunTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `RunTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
RunTaskV1 casts the HTTP response body to a defined struct.

Runs a task using the v1 endpoint, please use `runTask` instead. You can check the status of task runs with the observability endpoints.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiRunTaskV1Request with parameters below.

	@param taskID string - Unique identifier of a task.
	@return RunResponse
*/
func (c *APIClient) RunTaskV1(r ApiRunTaskV1Request, opts ...RequestOption) (*RunResponse, error) {
	var returnValue *RunResponse

	res, resBody, err := c.RunTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchAuthenticationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationSearch"]; ok {
		err = json.Unmarshal(v, &r.authenticationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter authenticationSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchAuthenticationsRequest represents the request with all the parameters for the API call.
type ApiSearchAuthenticationsRequest struct {
	authenticationSearch *AuthenticationSearch
}

// NewApiSearchAuthenticationsRequest creates an instance of the ApiSearchAuthenticationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchAuthenticationsRequest(authenticationSearch *AuthenticationSearch) ApiSearchAuthenticationsRequest {
	return ApiSearchAuthenticationsRequest{
		authenticationSearch: authenticationSearch,
	}
}

/*
SearchAuthentications calls the API and returns the raw response from it.

	  Searches for authentication resources.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiSearchAuthenticationsRequest with parameters below.
	  @param authenticationSearch AuthenticationSearch
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchAuthenticationsWithHTTPInfo(r ApiSearchAuthenticationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/authentications/search"

	if r.authenticationSearch == nil {
		return nil, nil, reportError("Parameter `authenticationSearch` is required when calling `SearchAuthentications`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.authenticationSearch
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SearchAuthentications casts the HTTP response body to a defined struct.

Searches for authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchAuthenticationsRequest with parameters below.

	@param authenticationSearch AuthenticationSearch
	@return []Authentication
*/
func (c *APIClient) SearchAuthentications(r ApiSearchAuthenticationsRequest, opts ...RequestOption) ([]Authentication, error) {
	var returnValue []Authentication

	res, resBody, err := c.SearchAuthenticationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchDestinationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationSearch"]; ok {
		err = json.Unmarshal(v, &r.destinationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter destinationSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchDestinationsRequest represents the request with all the parameters for the API call.
type ApiSearchDestinationsRequest struct {
	destinationSearch *DestinationSearch
}

// NewApiSearchDestinationsRequest creates an instance of the ApiSearchDestinationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchDestinationsRequest(destinationSearch *DestinationSearch) ApiSearchDestinationsRequest {
	return ApiSearchDestinationsRequest{
		destinationSearch: destinationSearch,
	}
}

/*
SearchDestinations calls the API and returns the raw response from it.

	  Searches for destinations.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiSearchDestinationsRequest with parameters below.
	  @param destinationSearch DestinationSearch
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchDestinationsWithHTTPInfo(r ApiSearchDestinationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations/search"

	if r.destinationSearch == nil {
		return nil, nil, reportError("Parameter `destinationSearch` is required when calling `SearchDestinations`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.destinationSearch
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SearchDestinations casts the HTTP response body to a defined struct.

Searches for destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchDestinationsRequest with parameters below.

	@param destinationSearch DestinationSearch
	@return []Destination
*/
func (c *APIClient) SearchDestinations(r ApiSearchDestinationsRequest, opts ...RequestOption) ([]Destination, error) {
	var returnValue []Destination

	res, resBody, err := c.SearchDestinationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceSearch"]; ok {
		err = json.Unmarshal(v, &r.sourceSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchSourcesRequest represents the request with all the parameters for the API call.
type ApiSearchSourcesRequest struct {
	sourceSearch *SourceSearch
}

// NewApiSearchSourcesRequest creates an instance of the ApiSearchSourcesRequest to be used for the API call.
func (c *APIClient) NewApiSearchSourcesRequest(sourceSearch *SourceSearch) ApiSearchSourcesRequest {
	return ApiSearchSourcesRequest{
		sourceSearch: sourceSearch,
	}
}

/*
SearchSources calls the API and returns the raw response from it.

	  Searches for sources.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiSearchSourcesRequest with parameters below.
	  @param sourceSearch SourceSearch
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchSourcesWithHTTPInfo(r ApiSearchSourcesRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/search"

	if r.sourceSearch == nil {
		return nil, nil, reportError("Parameter `sourceSearch` is required when calling `SearchSources`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.sourceSearch
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SearchSources casts the HTTP response body to a defined struct.

Searches for sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchSourcesRequest with parameters below.

	@param sourceSearch SourceSearch
	@return []Source
*/
func (c *APIClient) SearchSources(r ApiSearchSourcesRequest, opts ...RequestOption) ([]Source, error) {
	var returnValue []Source

	res, resBody, err := c.SearchSourcesWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchTasksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskSearch"]; ok {
		err = json.Unmarshal(v, &r.taskSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.taskSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchTasksRequest represents the request with all the parameters for the API call.
type ApiSearchTasksRequest struct {
	taskSearch *TaskSearch
}

// NewApiSearchTasksRequest creates an instance of the ApiSearchTasksRequest to be used for the API call.
func (c *APIClient) NewApiSearchTasksRequest(taskSearch *TaskSearch) ApiSearchTasksRequest {
	return ApiSearchTasksRequest{
		taskSearch: taskSearch,
	}
}

/*
SearchTasks calls the API and returns the raw response from it.

	  Searches for tasks.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiSearchTasksRequest with parameters below.
	  @param taskSearch TaskSearch
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchTasksWithHTTPInfo(r ApiSearchTasksRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/search"

	if r.taskSearch == nil {
		return nil, nil, reportError("Parameter `taskSearch` is required when calling `SearchTasks`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskSearch
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SearchTasks casts the HTTP response body to a defined struct.

Searches for tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTasksRequest with parameters below.

	@param taskSearch TaskSearch
	@return []Task
*/
func (c *APIClient) SearchTasks(r ApiSearchTasksRequest, opts ...RequestOption) ([]Task, error) {
	var returnValue []Task

	res, resBody, err := c.SearchTasksWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchTasksV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskSearch"]; ok {
		err = json.Unmarshal(v, &r.taskSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.taskSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchTasksV1Request represents the request with all the parameters for the API call.
type ApiSearchTasksV1Request struct {
	taskSearch *TaskSearch
}

// NewApiSearchTasksV1Request creates an instance of the ApiSearchTasksV1Request to be used for the API call.
func (c *APIClient) NewApiSearchTasksV1Request(taskSearch *TaskSearch) ApiSearchTasksV1Request {
	return ApiSearchTasksV1Request{
		taskSearch: taskSearch,
	}
}

/*
SearchTasksV1 calls the API and returns the raw response from it.

	  Searches for tasks using the v1 endpoint, please use `searchTasks` instead.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiSearchTasksV1Request with parameters below.
	  @param taskSearch TaskSearch
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchTasksV1WithHTTPInfo(r ApiSearchTasksV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/search"

	if r.taskSearch == nil {
		return nil, nil, reportError("Parameter `taskSearch` is required when calling `SearchTasksV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskSearch
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SearchTasksV1 casts the HTTP response body to a defined struct.

Searches for tasks using the v1 endpoint, please use `searchTasks` instead.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTasksV1Request with parameters below.

	@param taskSearch TaskSearch
	@return []TaskV1
*/
func (c *APIClient) SearchTasksV1(r ApiSearchTasksV1Request, opts ...RequestOption) ([]TaskV1, error) {
	var returnValue []TaskV1

	res, resBody, err := c.SearchTasksV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchTransformationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationSearch"]; ok {
		err = json.Unmarshal(v, &r.transformationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchTransformationsRequest represents the request with all the parameters for the API call.
type ApiSearchTransformationsRequest struct {
	transformationSearch *TransformationSearch
}

// NewApiSearchTransformationsRequest creates an instance of the ApiSearchTransformationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchTransformationsRequest(transformationSearch *TransformationSearch) ApiSearchTransformationsRequest {
	return ApiSearchTransformationsRequest{
		transformationSearch: transformationSearch,
	}
}

/*
SearchTransformations calls the API and returns the raw response from it.

	  Searches for transformations.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiSearchTransformationsRequest with parameters below.
	  @param transformationSearch TransformationSearch
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchTransformationsWithHTTPInfo(r ApiSearchTransformationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/search"

	if r.transformationSearch == nil {
		return nil, nil, reportError("Parameter `transformationSearch` is required when calling `SearchTransformations`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.transformationSearch
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
SearchTransformations casts the HTTP response body to a defined struct.

Searches for transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTransformationsRequest with parameters below.

	@param transformationSearch TransformationSearch
	@return []Transformation
*/
func (c *APIClient) SearchTransformations(r ApiSearchTransformationsRequest, opts ...RequestOption) ([]Transformation, error) {
	var returnValue []Transformation

	res, resBody, err := c.SearchTransformationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiTriggerDockerSourceDiscoverRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiTriggerDockerSourceDiscoverRequest represents the request with all the parameters for the API call.
type ApiTriggerDockerSourceDiscoverRequest struct {
	sourceID string
}

// NewApiTriggerDockerSourceDiscoverRequest creates an instance of the ApiTriggerDockerSourceDiscoverRequest to be used for the API call.
func (c *APIClient) NewApiTriggerDockerSourceDiscoverRequest(sourceID string) ApiTriggerDockerSourceDiscoverRequest {
	return ApiTriggerDockerSourceDiscoverRequest{
		sourceID: sourceID,
	}
}

/*
TriggerDockerSourceDiscover calls the API and returns the raw response from it.

	Triggers a stream-listing request for a source.

Triggering stream-listing requests only works with sources with `type: docker` and `imageType: singer`.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiTriggerDockerSourceDiscoverRequest with parameters below.
	  @param sourceID string - Unique identifier of a source.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) TriggerDockerSourceDiscoverWithHTTPInfo(r ApiTriggerDockerSourceDiscoverRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}/discover"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(r.sourceID)))

	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `TriggerDockerSourceDiscover`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
TriggerDockerSourceDiscover casts the HTTP response body to a defined struct.

Triggers a stream-listing request for a source.
Triggering stream-listing requests only works with sources with `type: docker` and `imageType: singer`.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTriggerDockerSourceDiscoverRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return SourceWatchResponse
*/
func (c *APIClient) TriggerDockerSourceDiscover(r ApiTriggerDockerSourceDiscoverRequest, opts ...RequestOption) (*SourceWatchResponse, error) {
	var returnValue *SourceWatchResponse

	res, resBody, err := c.TriggerDockerSourceDiscoverWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiTryTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationTry"]; ok {
		err = json.Unmarshal(v, &r.transformationTry)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationTry)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationTry: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationTry)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationTry: %w", err)
		}
	}

	return nil
}

// ApiTryTransformationRequest represents the request with all the parameters for the API call.
type ApiTryTransformationRequest struct {
	transformationTry *TransformationTry
}

// NewApiTryTransformationRequest creates an instance of the ApiTryTransformationRequest to be used for the API call.
func (c *APIClient) NewApiTryTransformationRequest(transformationTry *TransformationTry) ApiTryTransformationRequest {
	return ApiTryTransformationRequest{
		transformationTry: transformationTry,
	}
}

/*
TryTransformation calls the API and returns the raw response from it.

	  Try a transformation before creating it.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiTryTransformationRequest with parameters below.
	  @param transformationTry TransformationTry
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) TryTransformationWithHTTPInfo(r ApiTryTransformationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/try"

	if r.transformationTry == nil {
		return nil, nil, reportError("Parameter `transformationTry` is required when calling `TryTransformation`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.transformationTry
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
TryTransformation casts the HTTP response body to a defined struct.

Try a transformation before creating it.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTryTransformationRequest with parameters below.

	@param transformationTry TransformationTry
	@return TransformationTryResponse
*/
func (c *APIClient) TryTransformation(r ApiTryTransformationRequest, opts ...RequestOption) (*TransformationTryResponse, error) {
	var returnValue *TransformationTryResponse

	res, resBody, err := c.TryTransformationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiTryTransformationBeforeUpdateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationID"]; ok {
		err = json.Unmarshal(v, &r.transformationID)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationID: %w", err)
			}
		}
	}
	if v, ok := req["transformationTry"]; ok {
		err = json.Unmarshal(v, &r.transformationTry)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationTry)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationTry: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationTry)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationTry: %w", err)
		}
	}

	return nil
}

// ApiTryTransformationBeforeUpdateRequest represents the request with all the parameters for the API call.
type ApiTryTransformationBeforeUpdateRequest struct {
	transformationID  string
	transformationTry *TransformationTry
}

// NewApiTryTransformationBeforeUpdateRequest creates an instance of the ApiTryTransformationBeforeUpdateRequest to be used for the API call.
func (c *APIClient) NewApiTryTransformationBeforeUpdateRequest(transformationID string, transformationTry *TransformationTry) ApiTryTransformationBeforeUpdateRequest {
	return ApiTryTransformationBeforeUpdateRequest{
		transformationID:  transformationID,
		transformationTry: transformationTry,
	}
}

/*
TryTransformationBeforeUpdate calls the API and returns the raw response from it.

	  Try a transformation before updating it.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiTryTransformationBeforeUpdateRequest with parameters below.
	  @param transformationID string - Unique identifier of a transformation.
	  @param transformationTry TransformationTry
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) TryTransformationBeforeUpdateWithHTTPInfo(r ApiTryTransformationBeforeUpdateRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/{transformationID}/try"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(utils.ParameterToString(r.transformationID)))

	if r.transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `TryTransformationBeforeUpdate`.")
	}

	if r.transformationTry == nil {
		return nil, nil, reportError("Parameter `transformationTry` is required when calling `TryTransformationBeforeUpdate`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.transformationTry
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
TryTransformationBeforeUpdate casts the HTTP response body to a defined struct.

Try a transformation before updating it.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTryTransformationBeforeUpdateRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@param transformationTry TransformationTry
	@return TransformationTryResponse
*/
func (c *APIClient) TryTransformationBeforeUpdate(r ApiTryTransformationBeforeUpdateRequest, opts ...RequestOption) (*TransformationTryResponse, error) {
	var returnValue *TransformationTryResponse

	res, resBody, err := c.TryTransformationBeforeUpdateWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}
	if v, ok := req["authenticationUpdate"]; ok {
		err = json.Unmarshal(v, &r.authenticationUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter authenticationUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateAuthenticationRequest represents the request with all the parameters for the API call.
type ApiUpdateAuthenticationRequest struct {
	authenticationID     string
	authenticationUpdate *AuthenticationUpdate
}

// NewApiUpdateAuthenticationRequest creates an instance of the ApiUpdateAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateAuthenticationRequest(authenticationID string, authenticationUpdate *AuthenticationUpdate) ApiUpdateAuthenticationRequest {
	return ApiUpdateAuthenticationRequest{
		authenticationID:     authenticationID,
		authenticationUpdate: authenticationUpdate,
	}
}

/*
UpdateAuthentication calls the API and returns the raw response from it.

	  Updates an authentication resource.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiUpdateAuthenticationRequest with parameters below.
	  @param authenticationID string - Unique identifier of an authentication resource.
	  @param authenticationUpdate AuthenticationUpdate
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) UpdateAuthenticationWithHTTPInfo(r ApiUpdateAuthenticationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(utils.ParameterToString(r.authenticationID)))

	if r.authenticationID == "" {
		return nil, nil, reportError("Parameter `authenticationID` is required when calling `UpdateAuthentication`.")
	}

	if r.authenticationUpdate == nil {
		return nil, nil, reportError("Parameter `authenticationUpdate` is required when calling `UpdateAuthentication`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.authenticationUpdate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateAuthentication casts the HTTP response body to a defined struct.

Updates an authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@param authenticationUpdate AuthenticationUpdate
	@return AuthenticationUpdateResponse
*/
func (c *APIClient) UpdateAuthentication(r ApiUpdateAuthenticationRequest, opts ...RequestOption) (*AuthenticationUpdateResponse, error) {
	var returnValue *AuthenticationUpdateResponse

	res, resBody, err := c.UpdateAuthenticationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}
	if v, ok := req["destinationUpdate"]; ok {
		err = json.Unmarshal(v, &r.destinationUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter destinationUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateDestinationRequest represents the request with all the parameters for the API call.
type ApiUpdateDestinationRequest struct {
	destinationID     string
	destinationUpdate *DestinationUpdate
}

// NewApiUpdateDestinationRequest creates an instance of the ApiUpdateDestinationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateDestinationRequest(destinationID string, destinationUpdate *DestinationUpdate) ApiUpdateDestinationRequest {
	return ApiUpdateDestinationRequest{
		destinationID:     destinationID,
		destinationUpdate: destinationUpdate,
	}
}

/*
UpdateDestination calls the API and returns the raw response from it.

	  Updates the destination by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiUpdateDestinationRequest with parameters below.
	  @param destinationID string - Unique identifier of a destination.
	  @param destinationUpdate DestinationUpdate
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) UpdateDestinationWithHTTPInfo(r ApiUpdateDestinationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(utils.ParameterToString(r.destinationID)))

	if r.destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `UpdateDestination`.")
	}

	if r.destinationUpdate == nil {
		return nil, nil, reportError("Parameter `destinationUpdate` is required when calling `UpdateDestination`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.destinationUpdate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateDestination casts the HTTP response body to a defined struct.

Updates the destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@param destinationUpdate DestinationUpdate
	@return DestinationUpdateResponse
*/
func (c *APIClient) UpdateDestination(r ApiUpdateDestinationRequest, opts ...RequestOption) (*DestinationUpdateResponse, error) {
	var returnValue *DestinationUpdateResponse

	res, resBody, err := c.UpdateDestinationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}
	if v, ok := req["sourceUpdate"]; ok {
		err = json.Unmarshal(v, &r.sourceUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateSourceRequest represents the request with all the parameters for the API call.
type ApiUpdateSourceRequest struct {
	sourceID     string
	sourceUpdate *SourceUpdate
}

// NewApiUpdateSourceRequest creates an instance of the ApiUpdateSourceRequest to be used for the API call.
func (c *APIClient) NewApiUpdateSourceRequest(sourceID string, sourceUpdate *SourceUpdate) ApiUpdateSourceRequest {
	return ApiUpdateSourceRequest{
		sourceID:     sourceID,
		sourceUpdate: sourceUpdate,
	}
}

/*
UpdateSource calls the API and returns the raw response from it.

	  Updates a source by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiUpdateSourceRequest with parameters below.
	  @param sourceID string - Unique identifier of a source.
	  @param sourceUpdate SourceUpdate
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) UpdateSourceWithHTTPInfo(r ApiUpdateSourceRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(r.sourceID)))

	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `UpdateSource`.")
	}

	if r.sourceUpdate == nil {
		return nil, nil, reportError("Parameter `sourceUpdate` is required when calling `UpdateSource`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.sourceUpdate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateSource casts the HTTP response body to a defined struct.

Updates a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param sourceUpdate SourceUpdate
	@return SourceUpdateResponse
*/
func (c *APIClient) UpdateSource(r ApiUpdateSourceRequest, opts ...RequestOption) (*SourceUpdateResponse, error) {
	var returnValue *SourceUpdateResponse

	res, resBody, err := c.UpdateSourceWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}
	if v, ok := req["taskUpdate"]; ok {
		err = json.Unmarshal(v, &r.taskUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateTaskRequest represents the request with all the parameters for the API call.
type ApiUpdateTaskRequest struct {
	taskID     string
	taskUpdate *TaskUpdate
}

// NewApiUpdateTaskRequest creates an instance of the ApiUpdateTaskRequest to be used for the API call.
func (c *APIClient) NewApiUpdateTaskRequest(taskID string, taskUpdate *TaskUpdate) ApiUpdateTaskRequest {
	return ApiUpdateTaskRequest{
		taskID:     taskID,
		taskUpdate: taskUpdate,
	}
}

/*
UpdateTask calls the API and returns the raw response from it.

	  Updates a task by its ID.


	Request can be constructed by NewApiUpdateTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	  @param taskUpdate TaskUpdate
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) UpdateTaskWithHTTPInfo(r ApiUpdateTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `UpdateTask`.")
	}

	if r.taskUpdate == nil {
		return nil, nil, reportError("Parameter `taskUpdate` is required when calling `UpdateTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskUpdate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateTask casts the HTTP response body to a defined struct.

Updates a task by its ID.

Request can be constructed by NewApiUpdateTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@param taskUpdate TaskUpdate
	@return TaskUpdateResponse
*/
func (c *APIClient) UpdateTask(r ApiUpdateTaskRequest, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.UpdateTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}
	if v, ok := req["taskUpdate"]; ok {
		err = json.Unmarshal(v, &r.taskUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateTaskV1Request represents the request with all the parameters for the API call.
type ApiUpdateTaskV1Request struct {
	taskID     string
	taskUpdate *TaskUpdateV1
}

// NewApiUpdateTaskV1Request creates an instance of the ApiUpdateTaskV1Request to be used for the API call.
func (c *APIClient) NewApiUpdateTaskV1Request(taskID string, taskUpdate *TaskUpdateV1) ApiUpdateTaskV1Request {
	return ApiUpdateTaskV1Request{
		taskID:     taskID,
		taskUpdate: taskUpdate,
	}
}

/*
UpdateTaskV1 calls the API and returns the raw response from it.

	  Updates a task by its ID using the v1 endpoint, please use `updateTask` instead.


	Request can be constructed by NewApiUpdateTaskV1Request with parameters below.
	  @param taskID string - Unique identifier of a task.
	  @param taskUpdate TaskUpdateV1
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) UpdateTaskV1WithHTTPInfo(r ApiUpdateTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `UpdateTaskV1`.")
	}

	if r.taskUpdate == nil {
		return nil, nil, reportError("Parameter `taskUpdate` is required when calling `UpdateTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskUpdate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateTaskV1 casts the HTTP response body to a defined struct.

Updates a task by its ID using the v1 endpoint, please use `updateTask` instead.

Request can be constructed by NewApiUpdateTaskV1Request with parameters below.

	@param taskID string - Unique identifier of a task.
	@param taskUpdate TaskUpdateV1
	@return TaskUpdateResponse
*/
func (c *APIClient) UpdateTaskV1(r ApiUpdateTaskV1Request, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.UpdateTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["transformationID"]; ok {
		err = json.Unmarshal(v, &r.transformationID)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationID: %w", err)
			}
		}
	}
	if v, ok := req["transformationCreate"]; ok {
		err = json.Unmarshal(v, &r.transformationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationCreate: %w", err)
		}
	}

	return nil
}

// ApiUpdateTransformationRequest represents the request with all the parameters for the API call.
type ApiUpdateTransformationRequest struct {
	transformationID     string
	transformationCreate *TransformationCreate
}

// NewApiUpdateTransformationRequest creates an instance of the ApiUpdateTransformationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateTransformationRequest(transformationID string, transformationCreate *TransformationCreate) ApiUpdateTransformationRequest {
	return ApiUpdateTransformationRequest{
		transformationID:     transformationID,
		transformationCreate: transformationCreate,
	}
}

/*
UpdateTransformation calls the API and returns the raw response from it.

	  Updates a transformation by its ID.


	Request can be constructed by NewApiUpdateTransformationRequest with parameters below.
	  @param transformationID string - Unique identifier of a transformation.
	  @param transformationCreate TransformationCreate
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) UpdateTransformationWithHTTPInfo(r ApiUpdateTransformationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/{transformationID}"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(utils.ParameterToString(r.transformationID)))

	if r.transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `UpdateTransformation`.")
	}

	if r.transformationCreate == nil {
		return nil, nil, reportError("Parameter `transformationCreate` is required when calling `UpdateTransformation`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.transformationCreate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateTransformation casts the HTTP response body to a defined struct.

Updates a transformation by its ID.

Request can be constructed by NewApiUpdateTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@param transformationCreate TransformationCreate
	@return TransformationUpdateResponse
*/
func (c *APIClient) UpdateTransformation(r ApiUpdateTransformationRequest, opts ...RequestOption) (*TransformationUpdateResponse, error) {
	var returnValue *TransformationUpdateResponse

	res, resBody, err := c.UpdateTransformationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiValidateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceCreate"]; ok {
		err = json.Unmarshal(v, &r.sourceCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceCreate: %w", err)
			}
		}
	}

	return nil
}

// ApiValidateSourceRequest represents the request with all the parameters for the API call.
type ApiValidateSourceRequest struct {
	sourceCreate *SourceCreate
}

// NewApiValidateSourceRequest creates an instance of the ApiValidateSourceRequest to be used for the API call.
func (c *APIClient) NewApiValidateSourceRequest() ApiValidateSourceRequest {
	return ApiValidateSourceRequest{}
}

// WithSourceCreate adds the sourceCreate to the ApiValidateSourceRequest and returns the request for chaining.
func (r ApiValidateSourceRequest) WithSourceCreate(sourceCreate *SourceCreate) ApiValidateSourceRequest {
	r.sourceCreate = sourceCreate
	return r
}

/*
ValidateSource calls the API and returns the raw response from it.

	  Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.


	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiValidateSourceRequest with parameters below.
	  @param sourceCreate SourceCreate -
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ValidateSourceWithHTTPInfo(r ApiValidateSourceRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/validate"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.sourceCreate) {
		postBody = "{}"
	} else {
		postBody = r.sourceCreate
	}
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ValidateSource casts the HTTP response body to a defined struct.

Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiValidateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceWatchResponse
*/
func (c *APIClient) ValidateSource(r ApiValidateSourceRequest, opts ...RequestOption) (*SourceWatchResponse, error) {
	var returnValue *SourceWatchResponse

	res, resBody, err := c.ValidateSourceWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiValidateSourceBeforeUpdateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}
	if v, ok := req["sourceUpdate"]; ok {
		err = json.Unmarshal(v, &r.sourceUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceUpdate: %w", err)
		}
	}

	return nil
}

// ApiValidateSourceBeforeUpdateRequest represents the request with all the parameters for the API call.
type ApiValidateSourceBeforeUpdateRequest struct {
	sourceID     string
	sourceUpdate *SourceUpdate
}

// NewApiValidateSourceBeforeUpdateRequest creates an instance of the ApiValidateSourceBeforeUpdateRequest to be used for the API call.
func (c *APIClient) NewApiValidateSourceBeforeUpdateRequest(sourceID string, sourceUpdate *SourceUpdate) ApiValidateSourceBeforeUpdateRequest {
	return ApiValidateSourceBeforeUpdateRequest{
		sourceID:     sourceID,
		sourceUpdate: sourceUpdate,
	}
}

/*
ValidateSourceBeforeUpdate calls the API and returns the raw response from it.

	  Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.


	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiValidateSourceBeforeUpdateRequest with parameters below.
	  @param sourceID string - Unique identifier of a source.
	  @param sourceUpdate SourceUpdate
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ValidateSourceBeforeUpdateWithHTTPInfo(r ApiValidateSourceBeforeUpdateRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}/validate"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(r.sourceID)))

	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `ValidateSourceBeforeUpdate`.")
	}

	if r.sourceUpdate == nil {
		return nil, nil, reportError("Parameter `sourceUpdate` is required when calling `ValidateSourceBeforeUpdate`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.sourceUpdate
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
ValidateSourceBeforeUpdate casts the HTTP response body to a defined struct.

Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiValidateSourceBeforeUpdateRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param sourceUpdate SourceUpdate
	@return SourceWatchResponse
*/
func (c *APIClient) ValidateSourceBeforeUpdate(r ApiValidateSourceBeforeUpdateRequest, opts ...RequestOption) (*SourceWatchResponse, error) {
	var returnValue *SourceWatchResponse

	res, resBody, err := c.ValidateSourceBeforeUpdateWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
