// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package ingestion

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/call"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       name,
		value:      parameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

func (r *ApiCreateAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["authenticationCreate"]; ok {
		err = json.Unmarshal(v, &r.authenticationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationCreate)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationCreate)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiCreateAuthenticationRequest represents the request with all the parameters for the API call.
type ApiCreateAuthenticationRequest struct {
	authenticationCreate *AuthenticationCreate
}

// NewApiCreateAuthenticationRequest creates an instance of the ApiCreateAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiCreateAuthenticationRequest(authenticationCreate *AuthenticationCreate) ApiCreateAuthenticationRequest {
	return ApiCreateAuthenticationRequest{
		authenticationCreate: authenticationCreate,
	}
}

/*
CreateAuthentication Create a authentication. Wraps CreateAuthenticationWithContext using context.Background.

Create a authentication.

Request can be constructed by NewApiCreateAuthenticationRequest with parameters below.

	@param authenticationCreate AuthenticationCreate -
	@return AuthenticationCreateResponse
*/
func (c *APIClient) CreateAuthentication(r ApiCreateAuthenticationRequest, opts ...Option) (*AuthenticationCreateResponse, error) {
	return c.CreateAuthenticationWithContext(context.Background(), r, opts...)
}

/*
CreateAuthentication Create a authentication.

Create a authentication.

Request can be constructed by NewApiCreateAuthenticationRequest with parameters below.

	@param authenticationCreate AuthenticationCreate -
	@return AuthenticationCreateResponse
*/
func (c *APIClient) CreateAuthenticationWithContext(ctx context.Context, r ApiCreateAuthenticationRequest, opts ...Option) (*AuthenticationCreateResponse, error) {
	var (
		postBody    any
		returnValue *AuthenticationCreateResponse
	)

	requestPath := "/1/authentications"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.authenticationCreate == nil {
		return returnValue, reportError("authenticationCreate is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.authenticationCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["destinationCreate"]; ok {
		err = json.Unmarshal(v, &r.destinationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationCreate)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationCreate)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiCreateDestinationRequest represents the request with all the parameters for the API call.
type ApiCreateDestinationRequest struct {
	destinationCreate *DestinationCreate
}

// NewApiCreateDestinationRequest creates an instance of the ApiCreateDestinationRequest to be used for the API call.
func (c *APIClient) NewApiCreateDestinationRequest(destinationCreate *DestinationCreate) ApiCreateDestinationRequest {
	return ApiCreateDestinationRequest{
		destinationCreate: destinationCreate,
	}
}

/*
CreateDestination Create a destination. Wraps CreateDestinationWithContext using context.Background.

Create a destination.

Request can be constructed by NewApiCreateDestinationRequest with parameters below.

	@param destinationCreate DestinationCreate -
	@return DestinationCreateResponse
*/
func (c *APIClient) CreateDestination(r ApiCreateDestinationRequest, opts ...Option) (*DestinationCreateResponse, error) {
	return c.CreateDestinationWithContext(context.Background(), r, opts...)
}

/*
CreateDestination Create a destination.

Create a destination.

Request can be constructed by NewApiCreateDestinationRequest with parameters below.

	@param destinationCreate DestinationCreate -
	@return DestinationCreateResponse
*/
func (c *APIClient) CreateDestinationWithContext(ctx context.Context, r ApiCreateDestinationRequest, opts ...Option) (*DestinationCreateResponse, error) {
	var (
		postBody    any
		returnValue *DestinationCreateResponse
	)

	requestPath := "/1/destinations"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.destinationCreate == nil {
		return returnValue, reportError("destinationCreate is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.destinationCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["sourceCreate"]; ok {
		err = json.Unmarshal(v, &r.sourceCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceCreate)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceCreate)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiCreateSourceRequest represents the request with all the parameters for the API call.
type ApiCreateSourceRequest struct {
	sourceCreate *SourceCreate
}

// NewApiCreateSourceRequest creates an instance of the ApiCreateSourceRequest to be used for the API call.
func (c *APIClient) NewApiCreateSourceRequest(sourceCreate *SourceCreate) ApiCreateSourceRequest {
	return ApiCreateSourceRequest{
		sourceCreate: sourceCreate,
	}
}

/*
CreateSource Create a source. Wraps CreateSourceWithContext using context.Background.

Create a source.

Request can be constructed by NewApiCreateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceCreateResponse
*/
func (c *APIClient) CreateSource(r ApiCreateSourceRequest, opts ...Option) (*SourceCreateResponse, error) {
	return c.CreateSourceWithContext(context.Background(), r, opts...)
}

/*
CreateSource Create a source.

Create a source.

Request can be constructed by NewApiCreateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceCreateResponse
*/
func (c *APIClient) CreateSourceWithContext(ctx context.Context, r ApiCreateSourceRequest, opts ...Option) (*SourceCreateResponse, error) {
	var (
		postBody    any
		returnValue *SourceCreateResponse
	)

	requestPath := "/1/sources"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceCreate == nil {
		return returnValue, reportError("sourceCreate is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.sourceCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["taskCreate"]; ok {
		err = json.Unmarshal(v, &r.taskCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskCreate)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskCreate)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiCreateTaskRequest represents the request with all the parameters for the API call.
type ApiCreateTaskRequest struct {
	taskCreate *TaskCreate
}

// NewApiCreateTaskRequest creates an instance of the ApiCreateTaskRequest to be used for the API call.
func (c *APIClient) NewApiCreateTaskRequest(taskCreate *TaskCreate) ApiCreateTaskRequest {
	return ApiCreateTaskRequest{
		taskCreate: taskCreate,
	}
}

/*
CreateTask Create a task. Wraps CreateTaskWithContext using context.Background.

Create a task.

Request can be constructed by NewApiCreateTaskRequest with parameters below.

	@param taskCreate TaskCreate -
	@return TaskCreateResponse
*/
func (c *APIClient) CreateTask(r ApiCreateTaskRequest, opts ...Option) (*TaskCreateResponse, error) {
	return c.CreateTaskWithContext(context.Background(), r, opts...)
}

/*
CreateTask Create a task.

Create a task.

Request can be constructed by NewApiCreateTaskRequest with parameters below.

	@param taskCreate TaskCreate -
	@return TaskCreateResponse
*/
func (c *APIClient) CreateTaskWithContext(ctx context.Context, r ApiCreateTaskRequest, opts ...Option) (*TaskCreateResponse, error) {
	var (
		postBody    any
		returnValue *TaskCreateResponse
	)

	requestPath := "/1/tasks"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskCreate == nil {
		return returnValue, reportError("taskCreate is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.taskCreate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDelRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDelRequest represents the request with all the parameters for the API call.
type ApiDelRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiDelRequest creates an instance of the ApiDelRequest to be used for the API call.
func (c *APIClient) NewApiDelRequest(path string) ApiDelRequest {
	return ApiDelRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiDelRequest and returns the request for chaining.
func (r ApiDelRequest) WithParameters(parameters map[string]interface{}) ApiDelRequest {
	r.parameters = parameters
	return r
}

/*
Del Send requests to the Algolia REST API. Wraps DelWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiDelRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) Del(r ApiDelRequest, opts ...Option) (map[string]interface{}, error) {
	return c.DelWithContext(context.Background(), r, opts...)
}

/*
Del Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiDelRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) DelWithContext(ctx context.Context, r ApiDelRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteAuthenticationRequest represents the request with all the parameters for the API call.
type ApiDeleteAuthenticationRequest struct {
	authenticationID string
}

// NewApiDeleteAuthenticationRequest creates an instance of the ApiDeleteAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteAuthenticationRequest(authenticationID string) ApiDeleteAuthenticationRequest {
	return ApiDeleteAuthenticationRequest{
		authenticationID: authenticationID,
	}
}

/*
DeleteAuthentication Delete a authentication. Wraps DeleteAuthenticationWithContext using context.Background.

Soft delete the authentication of the given authenticationID.

Request can be constructed by NewApiDeleteAuthenticationRequest with parameters below.

	@param authenticationID string - The authentication UUID.
	@return DeleteResponse
*/
func (c *APIClient) DeleteAuthentication(r ApiDeleteAuthenticationRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteAuthenticationWithContext(context.Background(), r, opts...)
}

/*
DeleteAuthentication Delete a authentication.

Soft delete the authentication of the given authenticationID.

Request can be constructed by NewApiDeleteAuthenticationRequest with parameters below.

	@param authenticationID string - The authentication UUID.
	@return DeleteResponse
*/
func (c *APIClient) DeleteAuthenticationWithContext(ctx context.Context, r ApiDeleteAuthenticationRequest, opts ...Option) (*DeleteResponse, error) {
	var (
		postBody    any
		returnValue *DeleteResponse
	)

	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.Replace(requestPath, "{"+"authenticationID"+"}", url.PathEscape(parameterToString(r.authenticationID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteDestinationRequest represents the request with all the parameters for the API call.
type ApiDeleteDestinationRequest struct {
	destinationID string
}

// NewApiDeleteDestinationRequest creates an instance of the ApiDeleteDestinationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteDestinationRequest(destinationID string) ApiDeleteDestinationRequest {
	return ApiDeleteDestinationRequest{
		destinationID: destinationID,
	}
}

/*
DeleteDestination Delete a destination. Wraps DeleteDestinationWithContext using context.Background.

Soft delete the destination of the given destinationID.

Request can be constructed by NewApiDeleteDestinationRequest with parameters below.

	@param destinationID string - The destination UUID.
	@return DeleteResponse
*/
func (c *APIClient) DeleteDestination(r ApiDeleteDestinationRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteDestinationWithContext(context.Background(), r, opts...)
}

/*
DeleteDestination Delete a destination.

Soft delete the destination of the given destinationID.

Request can be constructed by NewApiDeleteDestinationRequest with parameters below.

	@param destinationID string - The destination UUID.
	@return DeleteResponse
*/
func (c *APIClient) DeleteDestinationWithContext(ctx context.Context, r ApiDeleteDestinationRequest, opts ...Option) (*DeleteResponse, error) {
	var (
		postBody    any
		returnValue *DeleteResponse
	)

	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.Replace(requestPath, "{"+"destinationID"+"}", url.PathEscape(parameterToString(r.destinationID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteSourceRequest represents the request with all the parameters for the API call.
type ApiDeleteSourceRequest struct {
	sourceID string
}

// NewApiDeleteSourceRequest creates an instance of the ApiDeleteSourceRequest to be used for the API call.
func (c *APIClient) NewApiDeleteSourceRequest(sourceID string) ApiDeleteSourceRequest {
	return ApiDeleteSourceRequest{
		sourceID: sourceID,
	}
}

/*
DeleteSource Delete a source. Wraps DeleteSourceWithContext using context.Background.

Soft delete the source of the given sourceID.

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param sourceID string - The source UUID.
	@return DeleteResponse
*/
func (c *APIClient) DeleteSource(r ApiDeleteSourceRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteSourceWithContext(context.Background(), r, opts...)
}

/*
DeleteSource Delete a source.

Soft delete the source of the given sourceID.

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param sourceID string - The source UUID.
	@return DeleteResponse
*/
func (c *APIClient) DeleteSourceWithContext(ctx context.Context, r ApiDeleteSourceRequest, opts ...Option) (*DeleteResponse, error) {
	var (
		postBody    any
		returnValue *DeleteResponse
	)

	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.Replace(requestPath, "{"+"sourceID"+"}", url.PathEscape(parameterToString(r.sourceID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteTaskRequest represents the request with all the parameters for the API call.
type ApiDeleteTaskRequest struct {
	taskID string
}

// NewApiDeleteTaskRequest creates an instance of the ApiDeleteTaskRequest to be used for the API call.
func (c *APIClient) NewApiDeleteTaskRequest(taskID string) ApiDeleteTaskRequest {
	return ApiDeleteTaskRequest{
		taskID: taskID,
	}
}

/*
DeleteTask Delete a task. Wraps DeleteTaskWithContext using context.Background.

Soft delete the task of the given taskID.

Request can be constructed by NewApiDeleteTaskRequest with parameters below.

	@param taskID string - The task UUID.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTask(r ApiDeleteTaskRequest, opts ...Option) (*DeleteResponse, error) {
	return c.DeleteTaskWithContext(context.Background(), r, opts...)
}

/*
DeleteTask Delete a task.

Soft delete the task of the given taskID.

Request can be constructed by NewApiDeleteTaskRequest with parameters below.

	@param taskID string - The task UUID.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTaskWithContext(ctx context.Context, r ApiDeleteTaskRequest, opts ...Option) (*DeleteResponse, error) {
	var (
		postBody    any
		returnValue *DeleteResponse
	)

	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.Replace(requestPath, "{"+"taskID"+"}", url.PathEscape(parameterToString(r.taskID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDisableTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDisableTaskRequest represents the request with all the parameters for the API call.
type ApiDisableTaskRequest struct {
	taskID string
}

// NewApiDisableTaskRequest creates an instance of the ApiDisableTaskRequest to be used for the API call.
func (c *APIClient) NewApiDisableTaskRequest(taskID string) ApiDisableTaskRequest {
	return ApiDisableTaskRequest{
		taskID: taskID,
	}
}

/*
DisableTask Disable a task. Wraps DisableTaskWithContext using context.Background.

Disable the task of the given taskID.

Request can be constructed by NewApiDisableTaskRequest with parameters below.

	@param taskID string - The task UUID.
	@return TaskUpdateResponse
*/
func (c *APIClient) DisableTask(r ApiDisableTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	return c.DisableTaskWithContext(context.Background(), r, opts...)
}

/*
DisableTask Disable a task.

Disable the task of the given taskID.

Request can be constructed by NewApiDisableTaskRequest with parameters below.

	@param taskID string - The task UUID.
	@return TaskUpdateResponse
*/
func (c *APIClient) DisableTaskWithContext(ctx context.Context, r ApiDisableTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	var (
		postBody    any
		returnValue *TaskUpdateResponse
	)

	requestPath := "/1/tasks/{taskID}/disable"
	requestPath = strings.Replace(requestPath, "{"+"taskID"+"}", url.PathEscape(parameterToString(r.taskID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiEnableTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiEnableTaskRequest represents the request with all the parameters for the API call.
type ApiEnableTaskRequest struct {
	taskID string
}

// NewApiEnableTaskRequest creates an instance of the ApiEnableTaskRequest to be used for the API call.
func (c *APIClient) NewApiEnableTaskRequest(taskID string) ApiEnableTaskRequest {
	return ApiEnableTaskRequest{
		taskID: taskID,
	}
}

/*
EnableTask Enable a task. Wraps EnableTaskWithContext using context.Background.

Enable the task of the given taskID.

Request can be constructed by NewApiEnableTaskRequest with parameters below.

	@param taskID string - The task UUID.
	@return TaskUpdateResponse
*/
func (c *APIClient) EnableTask(r ApiEnableTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	return c.EnableTaskWithContext(context.Background(), r, opts...)
}

/*
EnableTask Enable a task.

Enable the task of the given taskID.

Request can be constructed by NewApiEnableTaskRequest with parameters below.

	@param taskID string - The task UUID.
	@return TaskUpdateResponse
*/
func (c *APIClient) EnableTaskWithContext(ctx context.Context, r ApiEnableTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	var (
		postBody    any
		returnValue *TaskUpdateResponse
	)

	requestPath := "/1/tasks/{taskID}/enable"
	requestPath = strings.Replace(requestPath, "{"+"taskID"+"}", url.PathEscape(parameterToString(r.taskID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetRequest represents the request with all the parameters for the API call.
type ApiGetRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiGetRequest creates an instance of the ApiGetRequest to be used for the API call.
func (c *APIClient) NewApiGetRequest(path string) ApiGetRequest {
	return ApiGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiGetRequest and returns the request for chaining.
func (r ApiGetRequest) WithParameters(parameters map[string]interface{}) ApiGetRequest {
	r.parameters = parameters
	return r
}

/*
Get Send requests to the Algolia REST API. Wraps GetWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiGetRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) Get(r ApiGetRequest, opts ...Option) (map[string]interface{}, error) {
	return c.GetWithContext(context.Background(), r, opts...)
}

/*
Get Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiGetRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) GetWithContext(ctx context.Context, r ApiGetRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetAuthenticationRequest represents the request with all the parameters for the API call.
type ApiGetAuthenticationRequest struct {
	authenticationID string
}

// NewApiGetAuthenticationRequest creates an instance of the ApiGetAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiGetAuthenticationRequest(authenticationID string) ApiGetAuthenticationRequest {
	return ApiGetAuthenticationRequest{
		authenticationID: authenticationID,
	}
}

/*
GetAuthentication Get a authentication. Wraps GetAuthenticationWithContext using context.Background.

Get the authentication of the given authenticationID.

Request can be constructed by NewApiGetAuthenticationRequest with parameters below.

	@param authenticationID string - The authentication UUID.
	@return AuthenticationWithInput
*/
func (c *APIClient) GetAuthentication(r ApiGetAuthenticationRequest, opts ...Option) (*AuthenticationWithInput, error) {
	return c.GetAuthenticationWithContext(context.Background(), r, opts...)
}

/*
GetAuthentication Get a authentication.

Get the authentication of the given authenticationID.

Request can be constructed by NewApiGetAuthenticationRequest with parameters below.

	@param authenticationID string - The authentication UUID.
	@return AuthenticationWithInput
*/
func (c *APIClient) GetAuthenticationWithContext(ctx context.Context, r ApiGetAuthenticationRequest, opts ...Option) (*AuthenticationWithInput, error) {
	var (
		postBody    any
		returnValue *AuthenticationWithInput
	)

	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.Replace(requestPath, "{"+"authenticationID"+"}", url.PathEscape(parameterToString(r.authenticationID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetAuthenticationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["platform"]; ok {
		err = json.Unmarshal(v, &r.platform)
		if err != nil {
			err = json.Unmarshal(b, &r.platform)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetAuthenticationsRequest represents the request with all the parameters for the API call.
type ApiGetAuthenticationsRequest struct {
	itemsPerPage int32
	page         int32
	type_        []AuthenticationType
	platform     []PlatformWithNone
	sort         *AuthenticationSortKeys
	order        *OrderKeys
}

// NewApiGetAuthenticationsRequest creates an instance of the ApiGetAuthenticationsRequest to be used for the API call.
func (c *APIClient) NewApiGetAuthenticationsRequest() ApiGetAuthenticationsRequest {
	return ApiGetAuthenticationsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithItemsPerPage(itemsPerPage int32) ApiGetAuthenticationsRequest {
	r.itemsPerPage = itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithPage(page int32) ApiGetAuthenticationsRequest {
	r.page = page
	return r
}

// WithType_ adds the type_ to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithType_(type_ []AuthenticationType) ApiGetAuthenticationsRequest {
	r.type_ = type_
	return r
}

// WithPlatform adds the platform to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithPlatform(platform []PlatformWithNone) ApiGetAuthenticationsRequest {
	r.platform = platform
	return r
}

// WithSort adds the sort to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithSort(sort *AuthenticationSortKeys) ApiGetAuthenticationsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetAuthenticationsRequest and returns the request for chaining.
func (r ApiGetAuthenticationsRequest) WithOrder(order *OrderKeys) ApiGetAuthenticationsRequest {
	r.order = order
	return r
}

/*
GetAuthentications Get a list of authentications. Wraps GetAuthenticationsWithContext using context.Background.

Get a list of authentications for the given query parameters, with pagination details.

Request can be constructed by NewApiGetAuthenticationsRequest with parameters below.

	@param itemsPerPage int32 - The number of items per page to return.
	@param page int32 - The page number to fetch, starting at 1.
	@param type_ []AuthenticationType - The type of the authentications to retrieve.
	@param platform []PlatformWithNone - The platform of the authentications to retrieve.
	@param sort AuthenticationSortKeys - The key by which the list should be sorted.
	@param order OrderKeys - The order of the returned list.
	@return ListAuthenticationsResponse
*/
func (c *APIClient) GetAuthentications(r ApiGetAuthenticationsRequest, opts ...Option) (*ListAuthenticationsResponse, error) {
	return c.GetAuthenticationsWithContext(context.Background(), r, opts...)
}

/*
GetAuthentications Get a list of authentications.

Get a list of authentications for the given query parameters, with pagination details.

Request can be constructed by NewApiGetAuthenticationsRequest with parameters below.

	@param itemsPerPage int32 - The number of items per page to return.
	@param page int32 - The page number to fetch, starting at 1.
	@param type_ []AuthenticationType - The type of the authentications to retrieve.
	@param platform []PlatformWithNone - The platform of the authentications to retrieve.
	@param sort AuthenticationSortKeys - The key by which the list should be sorted.
	@param order OrderKeys - The order of the returned list.
	@return ListAuthenticationsResponse
*/
func (c *APIClient) GetAuthenticationsWithContext(ctx context.Context, r ApiGetAuthenticationsRequest, opts ...Option) (*ListAuthenticationsResponse, error) {
	var (
		postBody    any
		returnValue *ListAuthenticationsResponse
	)

	requestPath := "/1/authentications"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", parameterToString(r.itemsPerPage))
	}
	if !isNilorEmpty(r.page) {
		queryParams.Set("page", parameterToString(r.page))
	}
	if !isNilorEmpty(r.type_) {
		queryParams.Set("type", parameterToString(r.type_))
	}
	if !isNilorEmpty(r.platform) {
		queryParams.Set("platform", parameterToString(r.platform))
	}
	if !isNilorEmpty(r.sort) {
		queryParams.Set("sort", parameterToString(*r.sort))
	}
	if !isNilorEmpty(r.order) {
		queryParams.Set("order", parameterToString(*r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetDestinationRequest represents the request with all the parameters for the API call.
type ApiGetDestinationRequest struct {
	destinationID string
}

// NewApiGetDestinationRequest creates an instance of the ApiGetDestinationRequest to be used for the API call.
func (c *APIClient) NewApiGetDestinationRequest(destinationID string) ApiGetDestinationRequest {
	return ApiGetDestinationRequest{
		destinationID: destinationID,
	}
}

/*
GetDestination Get a destination. Wraps GetDestinationWithContext using context.Background.

Get the destination of the given destinationID.

Request can be constructed by NewApiGetDestinationRequest with parameters below.

	@param destinationID string - The destination UUID.
	@return Destination
*/
func (c *APIClient) GetDestination(r ApiGetDestinationRequest, opts ...Option) (*Destination, error) {
	return c.GetDestinationWithContext(context.Background(), r, opts...)
}

/*
GetDestination Get a destination.

Get the destination of the given destinationID.

Request can be constructed by NewApiGetDestinationRequest with parameters below.

	@param destinationID string - The destination UUID.
	@return Destination
*/
func (c *APIClient) GetDestinationWithContext(ctx context.Context, r ApiGetDestinationRequest, opts ...Option) (*Destination, error) {
	var (
		postBody    any
		returnValue *Destination
	)

	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.Replace(requestPath, "{"+"destinationID"+"}", url.PathEscape(parameterToString(r.destinationID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetDestinationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetDestinationsRequest represents the request with all the parameters for the API call.
type ApiGetDestinationsRequest struct {
	itemsPerPage     int32
	page             int32
	type_            []DestinationType
	authenticationID []string
	sort             *DestinationSortKeys
	order            *OrderKeys
}

// NewApiGetDestinationsRequest creates an instance of the ApiGetDestinationsRequest to be used for the API call.
func (c *APIClient) NewApiGetDestinationsRequest() ApiGetDestinationsRequest {
	return ApiGetDestinationsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithItemsPerPage(itemsPerPage int32) ApiGetDestinationsRequest {
	r.itemsPerPage = itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithPage(page int32) ApiGetDestinationsRequest {
	r.page = page
	return r
}

// WithType_ adds the type_ to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithType_(type_ []DestinationType) ApiGetDestinationsRequest {
	r.type_ = type_
	return r
}

// WithAuthenticationID adds the authenticationID to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithAuthenticationID(authenticationID []string) ApiGetDestinationsRequest {
	r.authenticationID = authenticationID
	return r
}

// WithSort adds the sort to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithSort(sort *DestinationSortKeys) ApiGetDestinationsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetDestinationsRequest and returns the request for chaining.
func (r ApiGetDestinationsRequest) WithOrder(order *OrderKeys) ApiGetDestinationsRequest {
	r.order = order
	return r
}

/*
GetDestinations Get a list of destinations. Wraps GetDestinationsWithContext using context.Background.

Get a list of destinations for the given query parameters, with pagination details.

Request can be constructed by NewApiGetDestinationsRequest with parameters below.

	@param itemsPerPage int32 - The number of items per page to return.
	@param page int32 - The page number to fetch, starting at 1.
	@param type_ []DestinationType - The type of the destinations to retrive.
	@param authenticationID []string - The authenticationIDs of the destinations to retrive.
	@param sort DestinationSortKeys - The key by which the list should be sorted.
	@param order OrderKeys - The order of the returned list.
	@return ListDestinationsResponse
*/
func (c *APIClient) GetDestinations(r ApiGetDestinationsRequest, opts ...Option) (*ListDestinationsResponse, error) {
	return c.GetDestinationsWithContext(context.Background(), r, opts...)
}

/*
GetDestinations Get a list of destinations.

Get a list of destinations for the given query parameters, with pagination details.

Request can be constructed by NewApiGetDestinationsRequest with parameters below.

	@param itemsPerPage int32 - The number of items per page to return.
	@param page int32 - The page number to fetch, starting at 1.
	@param type_ []DestinationType - The type of the destinations to retrive.
	@param authenticationID []string - The authenticationIDs of the destinations to retrive.
	@param sort DestinationSortKeys - The key by which the list should be sorted.
	@param order OrderKeys - The order of the returned list.
	@return ListDestinationsResponse
*/
func (c *APIClient) GetDestinationsWithContext(ctx context.Context, r ApiGetDestinationsRequest, opts ...Option) (*ListDestinationsResponse, error) {
	var (
		postBody    any
		returnValue *ListDestinationsResponse
	)

	requestPath := "/1/destinations"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", parameterToString(r.itemsPerPage))
	}
	if !isNilorEmpty(r.page) {
		queryParams.Set("page", parameterToString(r.page))
	}
	if !isNilorEmpty(r.type_) {
		queryParams.Set("type", parameterToString(r.type_))
	}
	if !isNilorEmpty(r.authenticationID) {
		queryParams.Set("authenticationID", parameterToString(r.authenticationID))
	}
	if !isNilorEmpty(r.sort) {
		queryParams.Set("sort", parameterToString(*r.sort))
	}
	if !isNilorEmpty(r.order) {
		queryParams.Set("order", parameterToString(*r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetEventRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["eventID"]; ok {
		err = json.Unmarshal(v, &r.eventID)
		if err != nil {
			err = json.Unmarshal(b, &r.eventID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetEventRequest represents the request with all the parameters for the API call.
type ApiGetEventRequest struct {
	runID   string
	eventID string
}

// NewApiGetEventRequest creates an instance of the ApiGetEventRequest to be used for the API call.
func (c *APIClient) NewApiGetEventRequest(runID string, eventID string) ApiGetEventRequest {
	return ApiGetEventRequest{
		runID:   runID,
		eventID: eventID,
	}
}

/*
GetEvent Get an event. Wraps GetEventWithContext using context.Background.

Get a single event for a specific runID.

Request can be constructed by NewApiGetEventRequest with parameters below.

	@param runID string - The run UUID.
	@param eventID string - The event UUID.
	@return Event
*/
func (c *APIClient) GetEvent(r ApiGetEventRequest, opts ...Option) (*Event, error) {
	return c.GetEventWithContext(context.Background(), r, opts...)
}

/*
GetEvent Get an event.

Get a single event for a specific runID.

Request can be constructed by NewApiGetEventRequest with parameters below.

	@param runID string - The run UUID.
	@param eventID string - The event UUID.
	@return Event
*/
func (c *APIClient) GetEventWithContext(ctx context.Context, r ApiGetEventRequest, opts ...Option) (*Event, error) {
	var (
		postBody    any
		returnValue *Event
	)

	requestPath := "/1/runs/{runID}/events/{eventID}"
	requestPath = strings.Replace(requestPath, "{"+"runID"+"}", url.PathEscape(parameterToString(r.runID)), -1)
	requestPath = strings.Replace(requestPath, "{"+"eventID"+"}", url.PathEscape(parameterToString(r.eventID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetEventsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["status"]; ok {
		err = json.Unmarshal(v, &r.status)
		if err != nil {
			err = json.Unmarshal(b, &r.status)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetEventsRequest represents the request with all the parameters for the API call.
type ApiGetEventsRequest struct {
	runID        string
	itemsPerPage int32
	page         int32
	status       []EventStatus
	type_        []EventType
	sort         *EventSortKeys
	order        *OrderKeys
}

// NewApiGetEventsRequest creates an instance of the ApiGetEventsRequest to be used for the API call.
func (c *APIClient) NewApiGetEventsRequest(runID string) ApiGetEventsRequest {
	return ApiGetEventsRequest{
		runID: runID,
	}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithItemsPerPage(itemsPerPage int32) ApiGetEventsRequest {
	r.itemsPerPage = itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithPage(page int32) ApiGetEventsRequest {
	r.page = page
	return r
}

// WithStatus adds the status to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithStatus(status []EventStatus) ApiGetEventsRequest {
	r.status = status
	return r
}

// WithType_ adds the type_ to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithType_(type_ []EventType) ApiGetEventsRequest {
	r.type_ = type_
	return r
}

// WithSort adds the sort to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithSort(sort *EventSortKeys) ApiGetEventsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetEventsRequest and returns the request for chaining.
func (r ApiGetEventsRequest) WithOrder(order *OrderKeys) ApiGetEventsRequest {
	r.order = order
	return r
}

/*
GetEvents Get a list of events. Wraps GetEventsWithContext using context.Background.

Get a list of events associated to the given runID, for the given query parameters.

Request can be constructed by NewApiGetEventsRequest with parameters below.

	@param runID string - The run UUID.
	@param itemsPerPage int32 - The number of items per page to return.
	@param page int32 - The page number to fetch, starting at 1.
	@param status []EventStatus - Filter the status of the events.
	@param type_ []EventType - Filter the type of the events.
	@param sort EventSortKeys - The key by which the list should be sorted.
	@param order OrderKeys - The order of the returned list.
	@return ListEventsResponse
*/
func (c *APIClient) GetEvents(r ApiGetEventsRequest, opts ...Option) (*ListEventsResponse, error) {
	return c.GetEventsWithContext(context.Background(), r, opts...)
}

/*
GetEvents Get a list of events.

Get a list of events associated to the given runID, for the given query parameters.

Request can be constructed by NewApiGetEventsRequest with parameters below.

	@param runID string - The run UUID.
	@param itemsPerPage int32 - The number of items per page to return.
	@param page int32 - The page number to fetch, starting at 1.
	@param status []EventStatus - Filter the status of the events.
	@param type_ []EventType - Filter the type of the events.
	@param sort EventSortKeys - The key by which the list should be sorted.
	@param order OrderKeys - The order of the returned list.
	@return ListEventsResponse
*/
func (c *APIClient) GetEventsWithContext(ctx context.Context, r ApiGetEventsRequest, opts ...Option) (*ListEventsResponse, error) {
	var (
		postBody    any
		returnValue *ListEventsResponse
	)

	requestPath := "/1/runs/{runID}/events"
	requestPath = strings.Replace(requestPath, "{"+"runID"+"}", url.PathEscape(parameterToString(r.runID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", parameterToString(r.itemsPerPage))
	}
	if !isNilorEmpty(r.page) {
		queryParams.Set("page", parameterToString(r.page))
	}
	if !isNilorEmpty(r.status) {
		queryParams.Set("status", parameterToString(r.status))
	}
	if !isNilorEmpty(r.type_) {
		queryParams.Set("type", parameterToString(r.type_))
	}
	if !isNilorEmpty(r.sort) {
		queryParams.Set("sort", parameterToString(*r.sort))
	}
	if !isNilorEmpty(r.order) {
		queryParams.Set("order", parameterToString(*r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRunRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetRunRequest represents the request with all the parameters for the API call.
type ApiGetRunRequest struct {
	runID string
}

// NewApiGetRunRequest creates an instance of the ApiGetRunRequest to be used for the API call.
func (c *APIClient) NewApiGetRunRequest(runID string) ApiGetRunRequest {
	return ApiGetRunRequest{
		runID: runID,
	}
}

/*
GetRun Get a run. Wraps GetRunWithContext using context.Background.

Get a single run for the given ID.

Request can be constructed by NewApiGetRunRequest with parameters below.

	@param runID string - The run UUID.
	@return Run
*/
func (c *APIClient) GetRun(r ApiGetRunRequest, opts ...Option) (*Run, error) {
	return c.GetRunWithContext(context.Background(), r, opts...)
}

/*
GetRun Get a run.

Get a single run for the given ID.

Request can be constructed by NewApiGetRunRequest with parameters below.

	@param runID string - The run UUID.
	@return Run
*/
func (c *APIClient) GetRunWithContext(ctx context.Context, r ApiGetRunRequest, opts ...Option) (*Run, error) {
	var (
		postBody    any
		returnValue *Run
	)

	requestPath := "/1/runs/{runID}"
	requestPath = strings.Replace(requestPath, "{"+"runID"+"}", url.PathEscape(parameterToString(r.runID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRunsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["status"]; ok {
		err = json.Unmarshal(v, &r.status)
		if err != nil {
			err = json.Unmarshal(b, &r.status)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetRunsRequest represents the request with all the parameters for the API call.
type ApiGetRunsRequest struct {
	itemsPerPage int32
	page         int32
	status       []RunStatus
	taskID       string
	sort         *RunSortKeys
	order        *OrderKeys
	startDate    string
	endDate      string
}

// NewApiGetRunsRequest creates an instance of the ApiGetRunsRequest to be used for the API call.
func (c *APIClient) NewApiGetRunsRequest() ApiGetRunsRequest {
	return ApiGetRunsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithItemsPerPage(itemsPerPage int32) ApiGetRunsRequest {
	r.itemsPerPage = itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithPage(page int32) ApiGetRunsRequest {
	r.page = page
	return r
}

// WithStatus adds the status to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithStatus(status []RunStatus) ApiGetRunsRequest {
	r.status = status
	return r
}

// WithTaskID adds the taskID to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithTaskID(taskID string) ApiGetRunsRequest {
	r.taskID = taskID
	return r
}

// WithSort adds the sort to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithSort(sort *RunSortKeys) ApiGetRunsRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithOrder(order *OrderKeys) ApiGetRunsRequest {
	r.order = order
	return r
}

// WithStartDate adds the startDate to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithStartDate(startDate string) ApiGetRunsRequest {
	r.startDate = startDate
	return r
}

// WithEndDate adds the endDate to the ApiGetRunsRequest and returns the request for chaining.
func (r ApiGetRunsRequest) WithEndDate(endDate string) ApiGetRunsRequest {
	r.endDate = endDate
	return r
}

/*
GetRuns Get a list of runs. Wraps GetRunsWithContext using context.Background.

Get a list of runs for the given query parameters, with pagination details.

Request can be constructed by NewApiGetRunsRequest with parameters below.

	@param itemsPerPage int32 - The number of items per page to return.
	@param page int32 - The page number to fetch, starting at 1.
	@param status []RunStatus - Filter the status of the runs.
	@param taskID string - Filter by taskID.
	@param sort RunSortKeys - The key by which the list should be sorted.
	@param order OrderKeys - The order of the returned list.
	@param startDate string - The start date (in RFC3339 format) of the runs fetching window. Defaults to 'now'-7 days if omitted. The timespan between `startDate` and `endDate` must be smaller than 7 days.
	@param endDate string - The end date (in RFC3339 format) of the runs fetching window. Defaults to 'now' days if omitted. The timespan between `startDate` and `endDate` must be smaller than 7 days.
	@return RunListResponse
*/
func (c *APIClient) GetRuns(r ApiGetRunsRequest, opts ...Option) (*RunListResponse, error) {
	return c.GetRunsWithContext(context.Background(), r, opts...)
}

/*
GetRuns Get a list of runs.

Get a list of runs for the given query parameters, with pagination details.

Request can be constructed by NewApiGetRunsRequest with parameters below.

	@param itemsPerPage int32 - The number of items per page to return.
	@param page int32 - The page number to fetch, starting at 1.
	@param status []RunStatus - Filter the status of the runs.
	@param taskID string - Filter by taskID.
	@param sort RunSortKeys - The key by which the list should be sorted.
	@param order OrderKeys - The order of the returned list.
	@param startDate string - The start date (in RFC3339 format) of the runs fetching window. Defaults to 'now'-7 days if omitted. The timespan between `startDate` and `endDate` must be smaller than 7 days.
	@param endDate string - The end date (in RFC3339 format) of the runs fetching window. Defaults to 'now' days if omitted. The timespan between `startDate` and `endDate` must be smaller than 7 days.
	@return RunListResponse
*/
func (c *APIClient) GetRunsWithContext(ctx context.Context, r ApiGetRunsRequest, opts ...Option) (*RunListResponse, error) {
	var (
		postBody    any
		returnValue *RunListResponse
	)

	requestPath := "/1/runs"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", parameterToString(r.itemsPerPage))
	}
	if !isNilorEmpty(r.page) {
		queryParams.Set("page", parameterToString(r.page))
	}
	if !isNilorEmpty(r.status) {
		queryParams.Set("status", parameterToString(r.status))
	}
	if !isNilorEmpty(r.taskID) {
		queryParams.Set("taskID", parameterToString(r.taskID))
	}
	if !isNilorEmpty(r.sort) {
		queryParams.Set("sort", parameterToString(*r.sort))
	}
	if !isNilorEmpty(r.order) {
		queryParams.Set("order", parameterToString(*r.order))
	}
	if !isNilorEmpty(r.startDate) {
		queryParams.Set("startDate", parameterToString(r.startDate))
	}
	if !isNilorEmpty(r.endDate) {
		queryParams.Set("endDate", parameterToString(r.endDate))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetSourceRequest represents the request with all the parameters for the API call.
type ApiGetSourceRequest struct {
	sourceID string
}

// NewApiGetSourceRequest creates an instance of the ApiGetSourceRequest to be used for the API call.
func (c *APIClient) NewApiGetSourceRequest(sourceID string) ApiGetSourceRequest {
	return ApiGetSourceRequest{
		sourceID: sourceID,
	}
}

/*
GetSource Get a source. Wraps GetSourceWithContext using context.Background.

Get the source of the given sourceID.

Request can be constructed by NewApiGetSourceRequest with parameters below.

	@param sourceID string - The source UUID.
	@return Source
*/
func (c *APIClient) GetSource(r ApiGetSourceRequest, opts ...Option) (*Source, error) {
	return c.GetSourceWithContext(context.Background(), r, opts...)
}

/*
GetSource Get a source.

Get the source of the given sourceID.

Request can be constructed by NewApiGetSourceRequest with parameters below.

	@param sourceID string - The source UUID.
	@return Source
*/
func (c *APIClient) GetSourceWithContext(ctx context.Context, r ApiGetSourceRequest, opts ...Option) (*Source, error) {
	var (
		postBody    any
		returnValue *Source
	)

	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.Replace(requestPath, "{"+"sourceID"+"}", url.PathEscape(parameterToString(r.sourceID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetSourcesRequest represents the request with all the parameters for the API call.
type ApiGetSourcesRequest struct {
	itemsPerPage     int32
	page             int32
	type_            []SourceType
	authenticationID []string
	sort             *SourceSortKeys
	order            *OrderKeys
}

// NewApiGetSourcesRequest creates an instance of the ApiGetSourcesRequest to be used for the API call.
func (c *APIClient) NewApiGetSourcesRequest() ApiGetSourcesRequest {
	return ApiGetSourcesRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithItemsPerPage(itemsPerPage int32) ApiGetSourcesRequest {
	r.itemsPerPage = itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithPage(page int32) ApiGetSourcesRequest {
	r.page = page
	return r
}

// WithType_ adds the type_ to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithType_(type_ []SourceType) ApiGetSourcesRequest {
	r.type_ = type_
	return r
}

// WithAuthenticationID adds the authenticationID to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithAuthenticationID(authenticationID []string) ApiGetSourcesRequest {
	r.authenticationID = authenticationID
	return r
}

// WithSort adds the sort to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithSort(sort *SourceSortKeys) ApiGetSourcesRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetSourcesRequest and returns the request for chaining.
func (r ApiGetSourcesRequest) WithOrder(order *OrderKeys) ApiGetSourcesRequest {
	r.order = order
	return r
}

/*
GetSources Get a list of sources. Wraps GetSourcesWithContext using context.Background.

Get a list of sources for the given query parameters, with pagination details.

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@param itemsPerPage int32 - The number of items per page to return.
	@param page int32 - The page number to fetch, starting at 1.
	@param type_ []SourceType - The type of the sources to retrieve.
	@param authenticationID []string - The authenticationIDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication.
	@param sort SourceSortKeys - The key by which the list should be sorted.
	@param order OrderKeys - The order of the returned list.
	@return ListSourcesResponse
*/
func (c *APIClient) GetSources(r ApiGetSourcesRequest, opts ...Option) (*ListSourcesResponse, error) {
	return c.GetSourcesWithContext(context.Background(), r, opts...)
}

/*
GetSources Get a list of sources.

Get a list of sources for the given query parameters, with pagination details.

Request can be constructed by NewApiGetSourcesRequest with parameters below.

	@param itemsPerPage int32 - The number of items per page to return.
	@param page int32 - The page number to fetch, starting at 1.
	@param type_ []SourceType - The type of the sources to retrieve.
	@param authenticationID []string - The authenticationIDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication.
	@param sort SourceSortKeys - The key by which the list should be sorted.
	@param order OrderKeys - The order of the returned list.
	@return ListSourcesResponse
*/
func (c *APIClient) GetSourcesWithContext(ctx context.Context, r ApiGetSourcesRequest, opts ...Option) (*ListSourcesResponse, error) {
	var (
		postBody    any
		returnValue *ListSourcesResponse
	)

	requestPath := "/1/sources"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", parameterToString(r.itemsPerPage))
	}
	if !isNilorEmpty(r.page) {
		queryParams.Set("page", parameterToString(r.page))
	}
	if !isNilorEmpty(r.type_) {
		queryParams.Set("type", parameterToString(r.type_))
	}
	if !isNilorEmpty(r.authenticationID) {
		queryParams.Set("authenticationID", parameterToString(r.authenticationID))
	}
	if !isNilorEmpty(r.sort) {
		queryParams.Set("sort", parameterToString(*r.sort))
	}
	if !isNilorEmpty(r.order) {
		queryParams.Set("order", parameterToString(*r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetTaskRequest represents the request with all the parameters for the API call.
type ApiGetTaskRequest struct {
	taskID string
}

// NewApiGetTaskRequest creates an instance of the ApiGetTaskRequest to be used for the API call.
func (c *APIClient) NewApiGetTaskRequest(taskID string) ApiGetTaskRequest {
	return ApiGetTaskRequest{
		taskID: taskID,
	}
}

/*
GetTask Get a task. Wraps GetTaskWithContext using context.Background.

Get the task of the given taskID.

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param taskID string - The task UUID.
	@return Task
*/
func (c *APIClient) GetTask(r ApiGetTaskRequest, opts ...Option) (*Task, error) {
	return c.GetTaskWithContext(context.Background(), r, opts...)
}

/*
GetTask Get a task.

Get the task of the given taskID.

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param taskID string - The task UUID.
	@return Task
*/
func (c *APIClient) GetTaskWithContext(ctx context.Context, r ApiGetTaskRequest, opts ...Option) (*Task, error) {
	var (
		postBody    any
		returnValue *Task
	)

	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.Replace(requestPath, "{"+"taskID"+"}", url.PathEscape(parameterToString(r.taskID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTasksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["action"]; ok {
		err = json.Unmarshal(v, &r.action)
		if err != nil {
			err = json.Unmarshal(b, &r.action)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["enabled"]; ok {
		err = json.Unmarshal(v, &r.enabled)
		if err != nil {
			err = json.Unmarshal(b, &r.enabled)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["triggerType"]; ok {
		err = json.Unmarshal(v, &r.triggerType)
		if err != nil {
			err = json.Unmarshal(b, &r.triggerType)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetTasksRequest represents the request with all the parameters for the API call.
type ApiGetTasksRequest struct {
	itemsPerPage  int32
	page          int32
	action        []ActionType
	enabled       bool
	sourceID      []string
	destinationID []string
	triggerType   []TriggerType
	sort          *TaskSortKeys
	order         *OrderKeys
}

// NewApiGetTasksRequest creates an instance of the ApiGetTasksRequest to be used for the API call.
func (c *APIClient) NewApiGetTasksRequest() ApiGetTasksRequest {
	return ApiGetTasksRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithItemsPerPage(itemsPerPage int32) ApiGetTasksRequest {
	r.itemsPerPage = itemsPerPage
	return r
}

// WithPage adds the page to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithPage(page int32) ApiGetTasksRequest {
	r.page = page
	return r
}

// WithAction adds the action to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithAction(action []ActionType) ApiGetTasksRequest {
	r.action = action
	return r
}

// WithEnabled adds the enabled to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithEnabled(enabled bool) ApiGetTasksRequest {
	r.enabled = enabled
	return r
}

// WithSourceID adds the sourceID to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithSourceID(sourceID []string) ApiGetTasksRequest {
	r.sourceID = sourceID
	return r
}

// WithDestinationID adds the destinationID to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithDestinationID(destinationID []string) ApiGetTasksRequest {
	r.destinationID = destinationID
	return r
}

// WithTriggerType adds the triggerType to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithTriggerType(triggerType []TriggerType) ApiGetTasksRequest {
	r.triggerType = triggerType
	return r
}

// WithSort adds the sort to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithSort(sort *TaskSortKeys) ApiGetTasksRequest {
	r.sort = sort
	return r
}

// WithOrder adds the order to the ApiGetTasksRequest and returns the request for chaining.
func (r ApiGetTasksRequest) WithOrder(order *OrderKeys) ApiGetTasksRequest {
	r.order = order
	return r
}

/*
GetTasks Get a list of tasks. Wraps GetTasksWithContext using context.Background.

Get a list of tasks for the given query parameters, with pagination details.

Request can be constructed by NewApiGetTasksRequest with parameters below.

	@param itemsPerPage int32 - The number of items per page to return.
	@param page int32 - The page number to fetch, starting at 1.
	@param action []ActionType - The action of the tasks to retrieve.
	@param enabled bool - Whether the task is enabled or not.
	@param sourceID []string - The sourceIDs of the tasks to retrive.
	@param destinationID []string - The destinationIDs of the tasks to retrive.
	@param triggerType []TriggerType - The trigger type of the task.
	@param sort TaskSortKeys - The key by which the list should be sorted.
	@param order OrderKeys - The order of the returned list.
	@return ListTasksResponse
*/
func (c *APIClient) GetTasks(r ApiGetTasksRequest, opts ...Option) (*ListTasksResponse, error) {
	return c.GetTasksWithContext(context.Background(), r, opts...)
}

/*
GetTasks Get a list of tasks.

Get a list of tasks for the given query parameters, with pagination details.

Request can be constructed by NewApiGetTasksRequest with parameters below.

	@param itemsPerPage int32 - The number of items per page to return.
	@param page int32 - The page number to fetch, starting at 1.
	@param action []ActionType - The action of the tasks to retrieve.
	@param enabled bool - Whether the task is enabled or not.
	@param sourceID []string - The sourceIDs of the tasks to retrive.
	@param destinationID []string - The destinationIDs of the tasks to retrive.
	@param triggerType []TriggerType - The trigger type of the task.
	@param sort TaskSortKeys - The key by which the list should be sorted.
	@param order OrderKeys - The order of the returned list.
	@return ListTasksResponse
*/
func (c *APIClient) GetTasksWithContext(ctx context.Context, r ApiGetTasksRequest, opts ...Option) (*ListTasksResponse, error) {
	var (
		postBody    any
		returnValue *ListTasksResponse
	)

	requestPath := "/1/tasks"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.itemsPerPage) {
		queryParams.Set("itemsPerPage", parameterToString(r.itemsPerPage))
	}
	if !isNilorEmpty(r.page) {
		queryParams.Set("page", parameterToString(r.page))
	}
	if !isNilorEmpty(r.action) {
		queryParams.Set("action", parameterToString(r.action))
	}
	if !isNilorEmpty(r.enabled) {
		queryParams.Set("enabled", parameterToString(r.enabled))
	}
	if !isNilorEmpty(r.sourceID) {
		queryParams.Set("sourceID", parameterToString(r.sourceID))
	}
	if !isNilorEmpty(r.destinationID) {
		queryParams.Set("destinationID", parameterToString(r.destinationID))
	}
	if !isNilorEmpty(r.triggerType) {
		queryParams.Set("triggerType", parameterToString(r.triggerType))
	}
	if !isNilorEmpty(r.sort) {
		queryParams.Set("sort", parameterToString(*r.sort))
	}
	if !isNilorEmpty(r.order) {
		queryParams.Set("order", parameterToString(*r.order))
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiPostRequest represents the request with all the parameters for the API call.
type ApiPostRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiPostRequest creates an instance of the ApiPostRequest to be used for the API call.
func (c *APIClient) NewApiPostRequest(path string) ApiPostRequest {
	return ApiPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiPostRequest and returns the request for chaining.
func (r ApiPostRequest) WithParameters(parameters map[string]interface{}) ApiPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiPostRequest and returns the request for chaining.
func (r ApiPostRequest) WithBody(body map[string]interface{}) ApiPostRequest {
	r.body = body
	return r
}

/*
Post Send requests to the Algolia REST API. Wraps PostWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPostRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@param body map[string]interface{} - The parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) Post(r ApiPostRequest, opts ...Option) (map[string]interface{}, error) {
	return c.PostWithContext(context.Background(), r, opts...)
}

/*
Post Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPostRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@param body map[string]interface{} - The parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) PostWithContext(ctx context.Context, r ApiPostRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiPutRequest represents the request with all the parameters for the API call.
type ApiPutRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiPutRequest creates an instance of the ApiPutRequest to be used for the API call.
func (c *APIClient) NewApiPutRequest(path string) ApiPutRequest {
	return ApiPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiPutRequest and returns the request for chaining.
func (r ApiPutRequest) WithParameters(parameters map[string]interface{}) ApiPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiPutRequest and returns the request for chaining.
func (r ApiPutRequest) WithBody(body map[string]interface{}) ApiPutRequest {
	r.body = body
	return r
}

/*
Put Send requests to the Algolia REST API. Wraps PutWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPutRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@param body map[string]interface{} - The parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) Put(r ApiPutRequest, opts ...Option) (map[string]interface{}, error) {
	return c.PutWithContext(context.Background(), r, opts...)
}

/*
Put Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiPutRequest with parameters below.

	@param path string - The path of the API endpoint to target, anything after the /1 needs to be specified.
	@param parameters map[string]interface{} - Query parameters to be applied to the current query.
	@param body map[string]interface{} - The parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) PutWithContext(ctx context.Context, r ApiPutRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(parameterToString(r.path)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	if !isNilorEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if isNilorEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 402 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 403 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
			return returnValue, newErr
		}
		if res.StatusCode == 404 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRunTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiRunTaskRequest represents the request with all the parameters for the API call.
type ApiRunTaskRequest struct {
	taskID string
}

// NewApiRunTaskRequest creates an instance of the ApiRunTaskRequest to be used for the API call.
func (c *APIClient) NewApiRunTaskRequest(taskID string) ApiRunTaskRequest {
	return ApiRunTaskRequest{
		taskID: taskID,
	}
}

/*
RunTask Run a task. Wraps RunTaskWithContext using context.Background.

Run the task of the given taskID.

Request can be constructed by NewApiRunTaskRequest with parameters below.

	@param taskID string - The task UUID.
	@return RunResponse
*/
func (c *APIClient) RunTask(r ApiRunTaskRequest, opts ...Option) (*RunResponse, error) {
	return c.RunTaskWithContext(context.Background(), r, opts...)
}

/*
RunTask Run a task.

Run the task of the given taskID.

Request can be constructed by NewApiRunTaskRequest with parameters below.

	@param taskID string - The task UUID.
	@return RunResponse
*/
func (c *APIClient) RunTaskWithContext(ctx context.Context, r ApiRunTaskRequest, opts ...Option) (*RunResponse, error) {
	var (
		postBody    any
		returnValue *RunResponse
	)

	requestPath := "/1/tasks/{taskID}/run"
	requestPath = strings.Replace(requestPath, "{"+"taskID"+"}", url.PathEscape(parameterToString(r.taskID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchAuthenticationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["authenticationSearch"]; ok {
		err = json.Unmarshal(v, &r.authenticationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationSearch)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationSearch)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSearchAuthenticationsRequest represents the request with all the parameters for the API call.
type ApiSearchAuthenticationsRequest struct {
	authenticationSearch *AuthenticationSearch
}

// NewApiSearchAuthenticationsRequest creates an instance of the ApiSearchAuthenticationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchAuthenticationsRequest(authenticationSearch *AuthenticationSearch) ApiSearchAuthenticationsRequest {
	return ApiSearchAuthenticationsRequest{
		authenticationSearch: authenticationSearch,
	}
}

/*
SearchAuthentications Search among authentications. Wraps SearchAuthenticationsWithContext using context.Background.

Search among authentications with a defined set of parameters.

Request can be constructed by NewApiSearchAuthenticationsRequest with parameters below.

	@param authenticationSearch AuthenticationSearch
	@return []Authentication
*/
func (c *APIClient) SearchAuthentications(r ApiSearchAuthenticationsRequest, opts ...Option) ([]Authentication, error) {
	return c.SearchAuthenticationsWithContext(context.Background(), r, opts...)
}

/*
SearchAuthentications Search among authentications.

Search among authentications with a defined set of parameters.

Request can be constructed by NewApiSearchAuthenticationsRequest with parameters below.

	@param authenticationSearch AuthenticationSearch
	@return []Authentication
*/
func (c *APIClient) SearchAuthenticationsWithContext(ctx context.Context, r ApiSearchAuthenticationsRequest, opts ...Option) ([]Authentication, error) {
	var (
		postBody    any
		returnValue []Authentication
	)

	requestPath := "/1/authentications/search"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.authenticationSearch == nil {
		return returnValue, reportError("authenticationSearch is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.authenticationSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchDestinationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["destinationSearch"]; ok {
		err = json.Unmarshal(v, &r.destinationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationSearch)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationSearch)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSearchDestinationsRequest represents the request with all the parameters for the API call.
type ApiSearchDestinationsRequest struct {
	destinationSearch *DestinationSearch
}

// NewApiSearchDestinationsRequest creates an instance of the ApiSearchDestinationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchDestinationsRequest(destinationSearch *DestinationSearch) ApiSearchDestinationsRequest {
	return ApiSearchDestinationsRequest{
		destinationSearch: destinationSearch,
	}
}

/*
SearchDestinations Search among destinations. Wraps SearchDestinationsWithContext using context.Background.

Search among destinations with a defined set of parameters.

Request can be constructed by NewApiSearchDestinationsRequest with parameters below.

	@param destinationSearch DestinationSearch
	@return []Destination
*/
func (c *APIClient) SearchDestinations(r ApiSearchDestinationsRequest, opts ...Option) ([]Destination, error) {
	return c.SearchDestinationsWithContext(context.Background(), r, opts...)
}

/*
SearchDestinations Search among destinations.

Search among destinations with a defined set of parameters.

Request can be constructed by NewApiSearchDestinationsRequest with parameters below.

	@param destinationSearch DestinationSearch
	@return []Destination
*/
func (c *APIClient) SearchDestinationsWithContext(ctx context.Context, r ApiSearchDestinationsRequest, opts ...Option) ([]Destination, error) {
	var (
		postBody    any
		returnValue []Destination
	)

	requestPath := "/1/destinations/search"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.destinationSearch == nil {
		return returnValue, reportError("destinationSearch is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.destinationSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["sourceSearch"]; ok {
		err = json.Unmarshal(v, &r.sourceSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceSearch)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceSearch)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSearchSourcesRequest represents the request with all the parameters for the API call.
type ApiSearchSourcesRequest struct {
	sourceSearch *SourceSearch
}

// NewApiSearchSourcesRequest creates an instance of the ApiSearchSourcesRequest to be used for the API call.
func (c *APIClient) NewApiSearchSourcesRequest(sourceSearch *SourceSearch) ApiSearchSourcesRequest {
	return ApiSearchSourcesRequest{
		sourceSearch: sourceSearch,
	}
}

/*
SearchSources Search among sources. Wraps SearchSourcesWithContext using context.Background.

Search among sources with a defined set of parameters.

Request can be constructed by NewApiSearchSourcesRequest with parameters below.

	@param sourceSearch SourceSearch
	@return []Source
*/
func (c *APIClient) SearchSources(r ApiSearchSourcesRequest, opts ...Option) ([]Source, error) {
	return c.SearchSourcesWithContext(context.Background(), r, opts...)
}

/*
SearchSources Search among sources.

Search among sources with a defined set of parameters.

Request can be constructed by NewApiSearchSourcesRequest with parameters below.

	@param sourceSearch SourceSearch
	@return []Source
*/
func (c *APIClient) SearchSourcesWithContext(ctx context.Context, r ApiSearchSourcesRequest, opts ...Option) ([]Source, error) {
	var (
		postBody    any
		returnValue []Source
	)

	requestPath := "/1/sources/search"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceSearch == nil {
		return returnValue, reportError("sourceSearch is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.sourceSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchTasksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["taskSearch"]; ok {
		err = json.Unmarshal(v, &r.taskSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.taskSearch)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskSearch)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiSearchTasksRequest represents the request with all the parameters for the API call.
type ApiSearchTasksRequest struct {
	taskSearch *TaskSearch
}

// NewApiSearchTasksRequest creates an instance of the ApiSearchTasksRequest to be used for the API call.
func (c *APIClient) NewApiSearchTasksRequest(taskSearch *TaskSearch) ApiSearchTasksRequest {
	return ApiSearchTasksRequest{
		taskSearch: taskSearch,
	}
}

/*
SearchTasks Search among tasks. Wraps SearchTasksWithContext using context.Background.

Search among tasks with a defined set of parameters.

Request can be constructed by NewApiSearchTasksRequest with parameters below.

	@param taskSearch TaskSearch
	@return []Task
*/
func (c *APIClient) SearchTasks(r ApiSearchTasksRequest, opts ...Option) ([]Task, error) {
	return c.SearchTasksWithContext(context.Background(), r, opts...)
}

/*
SearchTasks Search among tasks.

Search among tasks with a defined set of parameters.

Request can be constructed by NewApiSearchTasksRequest with parameters below.

	@param taskSearch TaskSearch
	@return []Task
*/
func (c *APIClient) SearchTasksWithContext(ctx context.Context, r ApiSearchTasksRequest, opts ...Option) ([]Task, error) {
	var (
		postBody    any
		returnValue []Task
	)

	requestPath := "/1/tasks/search"

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskSearch == nil {
		return returnValue, reportError("taskSearch is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.taskSearch
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["authenticationUpdate"]; ok {
		err = json.Unmarshal(v, &r.authenticationUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationUpdate)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationUpdate)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiUpdateAuthenticationRequest represents the request with all the parameters for the API call.
type ApiUpdateAuthenticationRequest struct {
	authenticationID     string
	authenticationUpdate *AuthenticationUpdate
}

// NewApiUpdateAuthenticationRequest creates an instance of the ApiUpdateAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateAuthenticationRequest(authenticationID string, authenticationUpdate *AuthenticationUpdate) ApiUpdateAuthenticationRequest {
	return ApiUpdateAuthenticationRequest{
		authenticationID:     authenticationID,
		authenticationUpdate: authenticationUpdate,
	}
}

/*
UpdateAuthentication Update a authentication. Wraps UpdateAuthenticationWithContext using context.Background.

Update the authentication of the given authenticationID.

Request can be constructed by NewApiUpdateAuthenticationRequest with parameters below.

	@param authenticationID string - The authentication UUID.
	@param authenticationUpdate AuthenticationUpdate
	@return AuthenticationUpdateResponse
*/
func (c *APIClient) UpdateAuthentication(r ApiUpdateAuthenticationRequest, opts ...Option) (*AuthenticationUpdateResponse, error) {
	return c.UpdateAuthenticationWithContext(context.Background(), r, opts...)
}

/*
UpdateAuthentication Update a authentication.

Update the authentication of the given authenticationID.

Request can be constructed by NewApiUpdateAuthenticationRequest with parameters below.

	@param authenticationID string - The authentication UUID.
	@param authenticationUpdate AuthenticationUpdate
	@return AuthenticationUpdateResponse
*/
func (c *APIClient) UpdateAuthenticationWithContext(ctx context.Context, r ApiUpdateAuthenticationRequest, opts ...Option) (*AuthenticationUpdateResponse, error) {
	var (
		postBody    any
		returnValue *AuthenticationUpdateResponse
	)

	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.Replace(requestPath, "{"+"authenticationID"+"}", url.PathEscape(parameterToString(r.authenticationID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.authenticationUpdate == nil {
		return returnValue, reportError("authenticationUpdate is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.authenticationUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["destinationUpdate"]; ok {
		err = json.Unmarshal(v, &r.destinationUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationUpdate)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationUpdate)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiUpdateDestinationRequest represents the request with all the parameters for the API call.
type ApiUpdateDestinationRequest struct {
	destinationID     string
	destinationUpdate *DestinationUpdate
}

// NewApiUpdateDestinationRequest creates an instance of the ApiUpdateDestinationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateDestinationRequest(destinationID string, destinationUpdate *DestinationUpdate) ApiUpdateDestinationRequest {
	return ApiUpdateDestinationRequest{
		destinationID:     destinationID,
		destinationUpdate: destinationUpdate,
	}
}

/*
UpdateDestination Update a destination. Wraps UpdateDestinationWithContext using context.Background.

Update the destination of the given destinationID.

Request can be constructed by NewApiUpdateDestinationRequest with parameters below.

	@param destinationID string - The destination UUID.
	@param destinationUpdate DestinationUpdate
	@return DestinationUpdateResponse
*/
func (c *APIClient) UpdateDestination(r ApiUpdateDestinationRequest, opts ...Option) (*DestinationUpdateResponse, error) {
	return c.UpdateDestinationWithContext(context.Background(), r, opts...)
}

/*
UpdateDestination Update a destination.

Update the destination of the given destinationID.

Request can be constructed by NewApiUpdateDestinationRequest with parameters below.

	@param destinationID string - The destination UUID.
	@param destinationUpdate DestinationUpdate
	@return DestinationUpdateResponse
*/
func (c *APIClient) UpdateDestinationWithContext(ctx context.Context, r ApiUpdateDestinationRequest, opts ...Option) (*DestinationUpdateResponse, error) {
	var (
		postBody    any
		returnValue *DestinationUpdateResponse
	)

	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.Replace(requestPath, "{"+"destinationID"+"}", url.PathEscape(parameterToString(r.destinationID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.destinationUpdate == nil {
		return returnValue, reportError("destinationUpdate is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.destinationUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["sourceUpdate"]; ok {
		err = json.Unmarshal(v, &r.sourceUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceUpdate)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceUpdate)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiUpdateSourceRequest represents the request with all the parameters for the API call.
type ApiUpdateSourceRequest struct {
	sourceID     string
	sourceUpdate *SourceUpdate
}

// NewApiUpdateSourceRequest creates an instance of the ApiUpdateSourceRequest to be used for the API call.
func (c *APIClient) NewApiUpdateSourceRequest(sourceID string, sourceUpdate *SourceUpdate) ApiUpdateSourceRequest {
	return ApiUpdateSourceRequest{
		sourceID:     sourceID,
		sourceUpdate: sourceUpdate,
	}
}

/*
UpdateSource Update a source. Wraps UpdateSourceWithContext using context.Background.

Update the source of the given sourceID.

Request can be constructed by NewApiUpdateSourceRequest with parameters below.

	@param sourceID string - The source UUID.
	@param sourceUpdate SourceUpdate
	@return SourceUpdateResponse
*/
func (c *APIClient) UpdateSource(r ApiUpdateSourceRequest, opts ...Option) (*SourceUpdateResponse, error) {
	return c.UpdateSourceWithContext(context.Background(), r, opts...)
}

/*
UpdateSource Update a source.

Update the source of the given sourceID.

Request can be constructed by NewApiUpdateSourceRequest with parameters below.

	@param sourceID string - The source UUID.
	@param sourceUpdate SourceUpdate
	@return SourceUpdateResponse
*/
func (c *APIClient) UpdateSourceWithContext(ctx context.Context, r ApiUpdateSourceRequest, opts ...Option) (*SourceUpdateResponse, error) {
	var (
		postBody    any
		returnValue *SourceUpdateResponse
	)

	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.Replace(requestPath, "{"+"sourceID"+"}", url.PathEscape(parameterToString(r.sourceID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.sourceUpdate == nil {
		return returnValue, reportError("sourceUpdate is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.sourceUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["taskUpdate"]; ok {
		err = json.Unmarshal(v, &r.taskUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskUpdate)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskUpdate)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiUpdateTaskRequest represents the request with all the parameters for the API call.
type ApiUpdateTaskRequest struct {
	taskID     string
	taskUpdate *TaskUpdate
}

// NewApiUpdateTaskRequest creates an instance of the ApiUpdateTaskRequest to be used for the API call.
func (c *APIClient) NewApiUpdateTaskRequest(taskID string, taskUpdate *TaskUpdate) ApiUpdateTaskRequest {
	return ApiUpdateTaskRequest{
		taskID:     taskID,
		taskUpdate: taskUpdate,
	}
}

/*
UpdateTask Update a task. Wraps UpdateTaskWithContext using context.Background.

Update the task of the given taskID.

Request can be constructed by NewApiUpdateTaskRequest with parameters below.

	@param taskID string - The task UUID.
	@param taskUpdate TaskUpdate
	@return TaskUpdateResponse
*/
func (c *APIClient) UpdateTask(r ApiUpdateTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	return c.UpdateTaskWithContext(context.Background(), r, opts...)
}

/*
UpdateTask Update a task.

Update the task of the given taskID.

Request can be constructed by NewApiUpdateTaskRequest with parameters below.

	@param taskID string - The task UUID.
	@param taskUpdate TaskUpdate
	@return TaskUpdateResponse
*/
func (c *APIClient) UpdateTaskWithContext(ctx context.Context, r ApiUpdateTaskRequest, opts ...Option) (*TaskUpdateResponse, error) {
	var (
		postBody    any
		returnValue *TaskUpdateResponse
	)

	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.Replace(requestPath, "{"+"taskID"+"}", url.PathEscape(parameterToString(r.taskID)), -1)

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.taskUpdate == nil {
		return returnValue, reportError("taskUpdate is required and must be specified")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.taskUpdate
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPatch, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, call.Write)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}
		if res.StatusCode == 400 {
			var v ErrorBase
			err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
			if err != nil {
				newErr.Message = err.Error()
				return returnValue, newErr
			}
		}
		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
