// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package ingestion

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/errs"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/transport"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type config struct {
	// -- Request options for API calls
	context      context.Context
	queryParams  url.Values
	headerParams map[string]string
	timeouts     transport.RequestConfiguration

	// -- ChunkedPush options
	waitForTasks bool
	batchSize    int

	// -- Iterable options
	maxRetries int
	timeout    func(int) time.Duration
	aggregator func(any, error)
}

type RequestOption interface {
	apply(*config)
}

type requestOption func(*config)

func (r requestOption) apply(c *config) {
	r(c)
}

func WithContext(ctx context.Context) requestOption {
	return requestOption(func(c *config) {
		c.context = ctx
	})
}

func WithHeaderParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.headerParams[key] = utils.ParameterToString(value)
	})
}

func WithQueryParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.queryParams.Set(utils.QueryParameterToString(key), utils.QueryParameterToString(value))
	})
}

func WithReadTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ReadTimeout = &timeout
	})
}

func WithWriteTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.WriteTimeout = &timeout
	})
}

func WithConnectTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ConnectTimeout = &timeout
	})
}

func (r *ApiCreateAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["authenticationCreate"]; ok {
		err = json.Unmarshal(v, &r.authenticationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter authenticationCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateAuthenticationRequest represents the request with all the parameters for the API call.
type ApiCreateAuthenticationRequest struct {
	authenticationCreate *AuthenticationCreate
}

// NewApiCreateAuthenticationRequest creates an instance of the ApiCreateAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiCreateAuthenticationRequest(authenticationCreate *AuthenticationCreate) ApiCreateAuthenticationRequest {
	return ApiCreateAuthenticationRequest{
		authenticationCreate: authenticationCreate,
	}
}

/*
CreateAuthentication calls the API and returns the raw response from it.

	  Creates a new authentication resource.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiCreateAuthenticationRequest with parameters below.
	  @param authenticationCreate AuthenticationCreate -
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CreateAuthenticationWithHTTPInfo(r ApiCreateAuthenticationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/authentications"

	if r.authenticationCreate == nil {
		return nil, nil, reportError("Parameter `authenticationCreate` is required when calling `CreateAuthentication`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.authenticationCreate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CreateAuthentication casts the HTTP response body to a defined struct.

Creates a new authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateAuthenticationRequest with parameters below.

	@param authenticationCreate AuthenticationCreate -
	@return AuthenticationCreateResponse
*/
func (c *APIClient) CreateAuthentication(r ApiCreateAuthenticationRequest, opts ...RequestOption) (*AuthenticationCreateResponse, error) {
	var returnValue *AuthenticationCreateResponse

	res, resBody, err := c.CreateAuthenticationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["destinationCreate"]; ok {
		err = json.Unmarshal(v, &r.destinationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter destinationCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateDestinationRequest represents the request with all the parameters for the API call.
type ApiCreateDestinationRequest struct {
	destinationCreate *DestinationCreate
}

// NewApiCreateDestinationRequest creates an instance of the ApiCreateDestinationRequest to be used for the API call.
func (c *APIClient) NewApiCreateDestinationRequest(destinationCreate *DestinationCreate) ApiCreateDestinationRequest {
	return ApiCreateDestinationRequest{
		destinationCreate: destinationCreate,
	}
}

/*
CreateDestination calls the API and returns the raw response from it.

	  Creates a new destination.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiCreateDestinationRequest with parameters below.
	  @param destinationCreate DestinationCreate -
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CreateDestinationWithHTTPInfo(r ApiCreateDestinationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations"

	if r.destinationCreate == nil {
		return nil, nil, reportError("Parameter `destinationCreate` is required when calling `CreateDestination`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.destinationCreate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CreateDestination casts the HTTP response body to a defined struct.

Creates a new destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateDestinationRequest with parameters below.

	@param destinationCreate DestinationCreate -
	@return DestinationCreateResponse
*/
func (c *APIClient) CreateDestination(r ApiCreateDestinationRequest, opts ...RequestOption) (*DestinationCreateResponse, error) {
	var returnValue *DestinationCreateResponse

	res, resBody, err := c.CreateDestinationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["sourceCreate"]; ok {
		err = json.Unmarshal(v, &r.sourceCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateSourceRequest represents the request with all the parameters for the API call.
type ApiCreateSourceRequest struct {
	sourceCreate *SourceCreate
}

// NewApiCreateSourceRequest creates an instance of the ApiCreateSourceRequest to be used for the API call.
func (c *APIClient) NewApiCreateSourceRequest(sourceCreate *SourceCreate) ApiCreateSourceRequest {
	return ApiCreateSourceRequest{
		sourceCreate: sourceCreate,
	}
}

/*
CreateSource calls the API and returns the raw response from it.

	  Creates a new source.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiCreateSourceRequest with parameters below.
	  @param sourceCreate SourceCreate -
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CreateSourceWithHTTPInfo(r ApiCreateSourceRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources"

	if r.sourceCreate == nil {
		return nil, nil, reportError("Parameter `sourceCreate` is required when calling `CreateSource`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.sourceCreate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CreateSource casts the HTTP response body to a defined struct.

Creates a new source.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiCreateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return SourceCreateResponse
*/
func (c *APIClient) CreateSource(r ApiCreateSourceRequest, opts ...RequestOption) (*SourceCreateResponse, error) {
	var returnValue *SourceCreateResponse

	res, resBody, err := c.CreateSourceWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskCreate"]; ok {
		err = json.Unmarshal(v, &r.taskCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateTaskRequest represents the request with all the parameters for the API call.
type ApiCreateTaskRequest struct {
	taskCreate *TaskCreate
}

// NewApiCreateTaskRequest creates an instance of the ApiCreateTaskRequest to be used for the API call.
func (c *APIClient) NewApiCreateTaskRequest(taskCreate *TaskCreate) ApiCreateTaskRequest {
	return ApiCreateTaskRequest{
		taskCreate: taskCreate,
	}
}

/*
CreateTask calls the API and returns the raw response from it.

	  Creates a new task.


	Request can be constructed by NewApiCreateTaskRequest with parameters below.
	  @param taskCreate TaskCreate - Request body for creating a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CreateTaskWithHTTPInfo(r ApiCreateTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks"

	if r.taskCreate == nil {
		return nil, nil, reportError("Parameter `taskCreate` is required when calling `CreateTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskCreate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CreateTask casts the HTTP response body to a defined struct.

Creates a new task.

Request can be constructed by NewApiCreateTaskRequest with parameters below.

	@param taskCreate TaskCreate - Request body for creating a task.
	@return TaskCreateResponse
*/
func (c *APIClient) CreateTask(r ApiCreateTaskRequest, opts ...RequestOption) (*TaskCreateResponse, error) {
	var returnValue *TaskCreateResponse

	res, resBody, err := c.CreateTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskCreate"]; ok {
		err = json.Unmarshal(v, &r.taskCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateTaskV1Request represents the request with all the parameters for the API call.
type ApiCreateTaskV1Request struct {
	taskCreate *TaskCreateV1
}

// Deprecated
// NewApiCreateTaskV1Request creates an instance of the ApiCreateTaskV1Request to be used for the API call.
func (c *APIClient) NewApiCreateTaskV1Request(taskCreate *TaskCreateV1) ApiCreateTaskV1Request {
	return ApiCreateTaskV1Request{
		taskCreate: taskCreate,
	}
}

/*
CreateTaskV1 calls the API and returns the raw response from it.

	  Creates a new task using the v1 endpoint, please use `createTask` instead.


	Request can be constructed by NewApiCreateTaskV1Request with parameters below.
	  @param taskCreate TaskCreateV1 - Request body for creating a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails

	  Deprecated
*/
func (c *APIClient) CreateTaskV1WithHTTPInfo(r ApiCreateTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks"

	if r.taskCreate == nil {
		return nil, nil, reportError("Parameter `taskCreate` is required when calling `CreateTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskCreate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CreateTaskV1 casts the HTTP response body to a defined struct.

Creates a new task using the v1 endpoint, please use `createTask` instead.

Request can be constructed by NewApiCreateTaskV1Request with parameters below.

	@param taskCreate TaskCreateV1 - Request body for creating a task.
	@return TaskCreateResponse

Deprecated.
*/
func (c *APIClient) CreateTaskV1(r ApiCreateTaskV1Request, opts ...RequestOption) (*TaskCreateResponse, error) {
	var returnValue *TaskCreateResponse

	res, resBody, err := c.CreateTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCreateTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["transformationCreate"]; ok {
		err = json.Unmarshal(v, &r.transformationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationCreate: %w", err)
		}
	}

	return nil
}

// ApiCreateTransformationRequest represents the request with all the parameters for the API call.
type ApiCreateTransformationRequest struct {
	transformationCreate *TransformationCreate
}

// NewApiCreateTransformationRequest creates an instance of the ApiCreateTransformationRequest to be used for the API call.
func (c *APIClient) NewApiCreateTransformationRequest(transformationCreate *TransformationCreate) ApiCreateTransformationRequest {
	return ApiCreateTransformationRequest{
		transformationCreate: transformationCreate,
	}
}

/*
CreateTransformation calls the API and returns the raw response from it.

	  Creates a new transformation.


	Request can be constructed by NewApiCreateTransformationRequest with parameters below.
	  @param transformationCreate TransformationCreate - Request body for creating a transformation.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CreateTransformationWithHTTPInfo(r ApiCreateTransformationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations"

	if r.transformationCreate == nil {
		return nil, nil, reportError("Parameter `transformationCreate` is required when calling `CreateTransformation`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.transformationCreate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CreateTransformation casts the HTTP response body to a defined struct.

Creates a new transformation.

Request can be constructed by NewApiCreateTransformationRequest with parameters below.

	@param transformationCreate TransformationCreate - Request body for creating a transformation.
	@return TransformationCreateResponse
*/
func (c *APIClient) CreateTransformation(r ApiCreateTransformationRequest, opts ...RequestOption) (*TransformationCreateResponse, error) {
	var returnValue *TransformationCreateResponse

	res, resBody, err := c.CreateTransformationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomDeleteRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}

	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomDeleteRequest represents the request with all the parameters for the API call.
type ApiCustomDeleteRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomDeleteRequest creates an instance of the ApiCustomDeleteRequest to be used for the API call.
func (c *APIClient) NewApiCustomDeleteRequest(path string) ApiCustomDeleteRequest {
	return ApiCustomDeleteRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomDeleteRequest and returns the request for chaining.
func (r ApiCustomDeleteRequest) WithParameters(parameters map[string]any) ApiCustomDeleteRequest {
	r.parameters = parameters

	return r
}

/*
CustomDelete calls the API and returns the raw response from it.

	  This method lets you send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomDeleteRequest with parameters below.
	  @param path string - Path of the endpoint, for example `1/newFeature`.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomDeleteWithHTTPInfo(r ApiCustomDeleteRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CustomDelete casts the HTTP response body to a defined struct.

This method lets you send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, for example `1/newFeature`.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomDelete(r ApiCustomDeleteRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}

	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomGetRequest represents the request with all the parameters for the API call.
type ApiCustomGetRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomGetRequest creates an instance of the ApiCustomGetRequest to be used for the API call.
func (c *APIClient) NewApiCustomGetRequest(path string) ApiCustomGetRequest {
	return ApiCustomGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomGetRequest and returns the request for chaining.
func (r ApiCustomGetRequest) WithParameters(parameters map[string]any) ApiCustomGetRequest {
	r.parameters = parameters

	return r
}

/*
CustomGet calls the API and returns the raw response from it.

	  This method lets you send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomGetRequest with parameters below.
	  @param path string - Path of the endpoint, for example `1/newFeature`.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomGetWithHTTPInfo(r ApiCustomGetRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CustomGet casts the HTTP response body to a defined struct.

This method lets you send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, for example `1/newFeature`.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomGet(r ApiCustomGetRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}

	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPostRequest represents the request with all the parameters for the API call.
type ApiCustomPostRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPostRequest creates an instance of the ApiCustomPostRequest to be used for the API call.
func (c *APIClient) NewApiCustomPostRequest(path string) ApiCustomPostRequest {
	return ApiCustomPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithParameters(parameters map[string]any) ApiCustomPostRequest {
	r.parameters = parameters

	return r
}

// WithBody adds the body to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithBody(body map[string]any) ApiCustomPostRequest {
	r.body = body

	return r
}

/*
CustomPost calls the API and returns the raw response from it.

	  This method lets you send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomPostRequest with parameters below.
	  @param path string - Path of the endpoint, for example `1/newFeature`.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	  @param body map[string]any - Parameters to send with the custom request.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomPostWithHTTPInfo(r ApiCustomPostRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CustomPost casts the HTTP response body to a defined struct.

This method lets you send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, for example `1/newFeature`.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPost(r ApiCustomPostRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}

	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPutRequest represents the request with all the parameters for the API call.
type ApiCustomPutRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPutRequest creates an instance of the ApiCustomPutRequest to be used for the API call.
func (c *APIClient) NewApiCustomPutRequest(path string) ApiCustomPutRequest {
	return ApiCustomPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithParameters(parameters map[string]any) ApiCustomPutRequest {
	r.parameters = parameters

	return r
}

// WithBody adds the body to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithBody(body map[string]any) ApiCustomPutRequest {
	r.body = body

	return r
}

/*
CustomPut calls the API and returns the raw response from it.

	  This method lets you send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomPutRequest with parameters below.
	  @param path string - Path of the endpoint, for example `1/newFeature`.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	  @param body map[string]any - Parameters to send with the custom request.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomPutWithHTTPInfo(r ApiCustomPutRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CustomPut casts the HTTP response body to a defined struct.

This method lets you send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, for example `1/newFeature`.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPut(r ApiCustomPutRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteAuthenticationRequest represents the request with all the parameters for the API call.
type ApiDeleteAuthenticationRequest struct {
	authenticationID string
}

// NewApiDeleteAuthenticationRequest creates an instance of the ApiDeleteAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteAuthenticationRequest(authenticationID string) ApiDeleteAuthenticationRequest {
	return ApiDeleteAuthenticationRequest{
		authenticationID: authenticationID,
	}
}

/*
DeleteAuthentication calls the API and returns the raw response from it.

	  Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiDeleteAuthenticationRequest with parameters below.
	  @param authenticationID string - Unique identifier of an authentication resource.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteAuthenticationWithHTTPInfo(r ApiDeleteAuthenticationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(utils.ParameterToString(r.authenticationID)))

	if r.authenticationID == "" {
		return nil, nil, reportError("Parameter `authenticationID` is required when calling `DeleteAuthentication`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
DeleteAuthentication casts the HTTP response body to a defined struct.

Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return DeleteResponse
*/
func (c *APIClient) DeleteAuthentication(r ApiDeleteAuthenticationRequest, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteAuthenticationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteDestinationRequest represents the request with all the parameters for the API call.
type ApiDeleteDestinationRequest struct {
	destinationID string
}

// NewApiDeleteDestinationRequest creates an instance of the ApiDeleteDestinationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteDestinationRequest(destinationID string) ApiDeleteDestinationRequest {
	return ApiDeleteDestinationRequest{
		destinationID: destinationID,
	}
}

/*
DeleteDestination calls the API and returns the raw response from it.

	  Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiDeleteDestinationRequest with parameters below.
	  @param destinationID string - Unique identifier of a destination.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteDestinationWithHTTPInfo(r ApiDeleteDestinationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(utils.ParameterToString(r.destinationID)))

	if r.destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `DeleteDestination`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
DeleteDestination casts the HTTP response body to a defined struct.

Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return DeleteResponse
*/
func (c *APIClient) DeleteDestination(r ApiDeleteDestinationRequest, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteDestinationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteSourceRequest represents the request with all the parameters for the API call.
type ApiDeleteSourceRequest struct {
	sourceID string
}

// NewApiDeleteSourceRequest creates an instance of the ApiDeleteSourceRequest to be used for the API call.
func (c *APIClient) NewApiDeleteSourceRequest(sourceID string) ApiDeleteSourceRequest {
	return ApiDeleteSourceRequest{
		sourceID: sourceID,
	}
}

/*
DeleteSource calls the API and returns the raw response from it.

	  Deletes a source by its ID. You can't delete sources that are referenced in tasks.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiDeleteSourceRequest with parameters below.
	  @param sourceID string - Unique identifier of a source.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteSourceWithHTTPInfo(r ApiDeleteSourceRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(r.sourceID)))

	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `DeleteSource`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
DeleteSource casts the HTTP response body to a defined struct.

Deletes a source by its ID. You can't delete sources that are referenced in tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDeleteSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return DeleteResponse
*/
func (c *APIClient) DeleteSource(r ApiDeleteSourceRequest, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteSourceWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteTaskRequest represents the request with all the parameters for the API call.
type ApiDeleteTaskRequest struct {
	taskID string
}

// NewApiDeleteTaskRequest creates an instance of the ApiDeleteTaskRequest to be used for the API call.
func (c *APIClient) NewApiDeleteTaskRequest(taskID string) ApiDeleteTaskRequest {
	return ApiDeleteTaskRequest{
		taskID: taskID,
	}
}

/*
DeleteTask calls the API and returns the raw response from it.

	  Deletes a task by its ID.


	Request can be constructed by NewApiDeleteTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteTaskWithHTTPInfo(r ApiDeleteTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DeleteTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
DeleteTask casts the HTTP response body to a defined struct.

Deletes a task by its ID.

Request can be constructed by NewApiDeleteTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTask(r ApiDeleteTaskRequest, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteTaskV1Request represents the request with all the parameters for the API call.
type ApiDeleteTaskV1Request struct {
	taskID string
}

// Deprecated
// NewApiDeleteTaskV1Request creates an instance of the ApiDeleteTaskV1Request to be used for the API call.
func (c *APIClient) NewApiDeleteTaskV1Request(taskID string) ApiDeleteTaskV1Request {
	return ApiDeleteTaskV1Request{
		taskID: taskID,
	}
}

/*
DeleteTaskV1 calls the API and returns the raw response from it.

	  Deletes a task by its ID using the v1 endpoint, please use `deleteTask` instead.


	Request can be constructed by NewApiDeleteTaskV1Request with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails

	  Deprecated
*/
func (c *APIClient) DeleteTaskV1WithHTTPInfo(r ApiDeleteTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DeleteTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
DeleteTaskV1 casts the HTTP response body to a defined struct.

Deletes a task by its ID using the v1 endpoint, please use `deleteTask` instead.

Request can be constructed by NewApiDeleteTaskV1Request with parameters below.

	@param taskID string - Unique identifier of a task.
	@return DeleteResponse

Deprecated.
*/
func (c *APIClient) DeleteTaskV1(r ApiDeleteTaskV1Request, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["transformationID"]; ok {
		err = json.Unmarshal(v, &r.transformationID)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteTransformationRequest represents the request with all the parameters for the API call.
type ApiDeleteTransformationRequest struct {
	transformationID string
}

// NewApiDeleteTransformationRequest creates an instance of the ApiDeleteTransformationRequest to be used for the API call.
func (c *APIClient) NewApiDeleteTransformationRequest(transformationID string) ApiDeleteTransformationRequest {
	return ApiDeleteTransformationRequest{
		transformationID: transformationID,
	}
}

/*
DeleteTransformation calls the API and returns the raw response from it.

	  Deletes a transformation by its ID.


	Request can be constructed by NewApiDeleteTransformationRequest with parameters below.
	  @param transformationID string - Unique identifier of a transformation.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteTransformationWithHTTPInfo(r ApiDeleteTransformationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/{transformationID}"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(utils.ParameterToString(r.transformationID)))

	if r.transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `DeleteTransformation`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
DeleteTransformation casts the HTTP response body to a defined struct.

Deletes a transformation by its ID.

Request can be constructed by NewApiDeleteTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@return DeleteResponse
*/
func (c *APIClient) DeleteTransformation(r ApiDeleteTransformationRequest, opts ...RequestOption) (*DeleteResponse, error) {
	var returnValue *DeleteResponse

	res, resBody, err := c.DeleteTransformationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDisableTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiDisableTaskRequest represents the request with all the parameters for the API call.
type ApiDisableTaskRequest struct {
	taskID string
}

// NewApiDisableTaskRequest creates an instance of the ApiDisableTaskRequest to be used for the API call.
func (c *APIClient) NewApiDisableTaskRequest(taskID string) ApiDisableTaskRequest {
	return ApiDisableTaskRequest{
		taskID: taskID,
	}
}

/*
DisableTask calls the API and returns the raw response from it.

	  Disables a task.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiDisableTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DisableTaskWithHTTPInfo(r ApiDisableTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}/disable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DisableTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
DisableTask casts the HTTP response body to a defined struct.

Disables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDisableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) DisableTask(r ApiDisableTaskRequest, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.DisableTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDisableTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiDisableTaskV1Request represents the request with all the parameters for the API call.
type ApiDisableTaskV1Request struct {
	taskID string
}

// Deprecated
// NewApiDisableTaskV1Request creates an instance of the ApiDisableTaskV1Request to be used for the API call.
func (c *APIClient) NewApiDisableTaskV1Request(taskID string) ApiDisableTaskV1Request {
	return ApiDisableTaskV1Request{
		taskID: taskID,
	}
}

/*
DisableTaskV1 calls the API and returns the raw response from it.

	  Disables a task using the v1 endpoint, please use `disableTask` instead.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiDisableTaskV1Request with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails

	  Deprecated
*/
func (c *APIClient) DisableTaskV1WithHTTPInfo(r ApiDisableTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}/disable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `DisableTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
DisableTaskV1 casts the HTTP response body to a defined struct.

Disables a task using the v1 endpoint, please use `disableTask` instead.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiDisableTaskV1Request with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse

Deprecated.
*/
func (c *APIClient) DisableTaskV1(r ApiDisableTaskV1Request, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.DisableTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiEnableTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiEnableTaskRequest represents the request with all the parameters for the API call.
type ApiEnableTaskRequest struct {
	taskID string
}

// NewApiEnableTaskRequest creates an instance of the ApiEnableTaskRequest to be used for the API call.
func (c *APIClient) NewApiEnableTaskRequest(taskID string) ApiEnableTaskRequest {
	return ApiEnableTaskRequest{
		taskID: taskID,
	}
}

/*
EnableTask calls the API and returns the raw response from it.

	  Enables a task.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiEnableTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) EnableTaskWithHTTPInfo(r ApiEnableTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}/enable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `EnableTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
EnableTask casts the HTTP response body to a defined struct.

Enables a task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiEnableTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse
*/
func (c *APIClient) EnableTask(r ApiEnableTaskRequest, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.EnableTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiEnableTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiEnableTaskV1Request represents the request with all the parameters for the API call.
type ApiEnableTaskV1Request struct {
	taskID string
}

// Deprecated
// NewApiEnableTaskV1Request creates an instance of the ApiEnableTaskV1Request to be used for the API call.
func (c *APIClient) NewApiEnableTaskV1Request(taskID string) ApiEnableTaskV1Request {
	return ApiEnableTaskV1Request{
		taskID: taskID,
	}
}

/*
EnableTaskV1 calls the API and returns the raw response from it.

	  Enables a task using the v1 endpoint, please use `enableTask` instead.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiEnableTaskV1Request with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails

	  Deprecated
*/
func (c *APIClient) EnableTaskV1WithHTTPInfo(r ApiEnableTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}/enable"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `EnableTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
EnableTaskV1 casts the HTTP response body to a defined struct.

Enables a task using the v1 endpoint, please use `enableTask` instead.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiEnableTaskV1Request with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskUpdateResponse

Deprecated.
*/
func (c *APIClient) EnableTaskV1(r ApiEnableTaskV1Request, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.EnableTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetAuthenticationRequest represents the request with all the parameters for the API call.
type ApiGetAuthenticationRequest struct {
	authenticationID string
}

// NewApiGetAuthenticationRequest creates an instance of the ApiGetAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiGetAuthenticationRequest(authenticationID string) ApiGetAuthenticationRequest {
	return ApiGetAuthenticationRequest{
		authenticationID: authenticationID,
	}
}

/*
GetAuthentication calls the API and returns the raw response from it.

	  Retrieves an authentication resource by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetAuthenticationRequest with parameters below.
	  @param authenticationID string - Unique identifier of an authentication resource.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetAuthenticationWithHTTPInfo(r ApiGetAuthenticationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(utils.ParameterToString(r.authenticationID)))

	if r.authenticationID == "" {
		return nil, nil, reportError("Parameter `authenticationID` is required when calling `GetAuthentication`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetAuthentication casts the HTTP response body to a defined struct.

Retrieves an authentication resource by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@return Authentication
*/
func (c *APIClient) GetAuthentication(r ApiGetAuthenticationRequest, opts ...RequestOption) (*Authentication, error) {
	var returnValue *Authentication

	res, resBody, err := c.GetAuthenticationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetDestinationRequest represents the request with all the parameters for the API call.
type ApiGetDestinationRequest struct {
	destinationID string
}

// NewApiGetDestinationRequest creates an instance of the ApiGetDestinationRequest to be used for the API call.
func (c *APIClient) NewApiGetDestinationRequest(destinationID string) ApiGetDestinationRequest {
	return ApiGetDestinationRequest{
		destinationID: destinationID,
	}
}

/*
GetDestination calls the API and returns the raw response from it.

	  Retrieves a destination by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetDestinationRequest with parameters below.
	  @param destinationID string - Unique identifier of a destination.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetDestinationWithHTTPInfo(r ApiGetDestinationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(utils.ParameterToString(r.destinationID)))

	if r.destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `GetDestination`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetDestination casts the HTTP response body to a defined struct.

Retrieves a destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@return Destination
*/
func (c *APIClient) GetDestination(r ApiGetDestinationRequest, opts ...RequestOption) (*Destination, error) {
	var returnValue *Destination

	res, resBody, err := c.GetDestinationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetEventRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runID: %w", err)
			}
		}
	}

	if v, ok := req["eventID"]; ok {
		err = json.Unmarshal(v, &r.eventID)
		if err != nil {
			err = json.Unmarshal(b, &r.eventID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal eventID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetEventRequest represents the request with all the parameters for the API call.
type ApiGetEventRequest struct {
	runID   string
	eventID string
}

// NewApiGetEventRequest creates an instance of the ApiGetEventRequest to be used for the API call.
func (c *APIClient) NewApiGetEventRequest(runID string, eventID string) ApiGetEventRequest {
	return ApiGetEventRequest{
		runID:   runID,
		eventID: eventID,
	}
}

/*
GetEvent calls the API and returns the raw response from it.

	  Retrieves a single task run event by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetEventRequest with parameters below.
	  @param runID string - Unique identifier of a task run.
	  @param eventID string - Unique identifier of an event.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetEventWithHTTPInfo(r ApiGetEventRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/runs/{runID}/events/{eventID}"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(utils.ParameterToString(r.runID)))
	requestPath = strings.ReplaceAll(requestPath, "{eventID}", url.PathEscape(utils.ParameterToString(r.eventID)))

	if r.runID == "" {
		return nil, nil, reportError("Parameter `runID` is required when calling `GetEvent`.")
	}

	if r.eventID == "" {
		return nil, nil, reportError("Parameter `eventID` is required when calling `GetEvent`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetEvent casts the HTTP response body to a defined struct.

Retrieves a single task run event by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetEventRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param eventID string - Unique identifier of an event.
	@return Event
*/
func (c *APIClient) GetEvent(r ApiGetEventRequest, opts ...RequestOption) (*Event, error) {
	var returnValue *Event

	res, resBody, err := c.GetEventWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRunRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetRunRequest represents the request with all the parameters for the API call.
type ApiGetRunRequest struct {
	runID string
}

// NewApiGetRunRequest creates an instance of the ApiGetRunRequest to be used for the API call.
func (c *APIClient) NewApiGetRunRequest(runID string) ApiGetRunRequest {
	return ApiGetRunRequest{
		runID: runID,
	}
}

/*
GetRun calls the API and returns the raw response from it.

	  Retrieve a single task run by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetRunRequest with parameters below.
	  @param runID string - Unique identifier of a task run.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetRunWithHTTPInfo(r ApiGetRunRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/runs/{runID}"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(utils.ParameterToString(r.runID)))

	if r.runID == "" {
		return nil, nil, reportError("Parameter `runID` is required when calling `GetRun`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetRun casts the HTTP response body to a defined struct.

Retrieve a single task run by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetRunRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@return Run
*/
func (c *APIClient) GetRun(r ApiGetRunRequest, opts ...RequestOption) (*Run, error) {
	var returnValue *Run

	res, resBody, err := c.GetRunWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetSourceRequest represents the request with all the parameters for the API call.
type ApiGetSourceRequest struct {
	sourceID string
}

// NewApiGetSourceRequest creates an instance of the ApiGetSourceRequest to be used for the API call.
func (c *APIClient) NewApiGetSourceRequest(sourceID string) ApiGetSourceRequest {
	return ApiGetSourceRequest{
		sourceID: sourceID,
	}
}

/*
GetSource calls the API and returns the raw response from it.

	  Retrieve a source by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetSourceRequest with parameters below.
	  @param sourceID string - Unique identifier of a source.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetSourceWithHTTPInfo(r ApiGetSourceRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(r.sourceID)))

	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `GetSource`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetSource casts the HTTP response body to a defined struct.

Retrieve a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return Source
*/
func (c *APIClient) GetSource(r ApiGetSourceRequest, opts ...RequestOption) (*Source, error) {
	var returnValue *Source

	res, resBody, err := c.GetSourceWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTaskRequest represents the request with all the parameters for the API call.
type ApiGetTaskRequest struct {
	taskID string
}

// NewApiGetTaskRequest creates an instance of the ApiGetTaskRequest to be used for the API call.
func (c *APIClient) NewApiGetTaskRequest(taskID string) ApiGetTaskRequest {
	return ApiGetTaskRequest{
		taskID: taskID,
	}
}

/*
GetTask calls the API and returns the raw response from it.

	  Retrieves a task by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTaskWithHTTPInfo(r ApiGetTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `GetTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetTask casts the HTTP response body to a defined struct.

Retrieves a task by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@return Task
*/
func (c *APIClient) GetTask(r ApiGetTaskRequest, opts ...RequestOption) (*Task, error) {
	var returnValue *Task

	res, resBody, err := c.GetTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTaskV1Request represents the request with all the parameters for the API call.
type ApiGetTaskV1Request struct {
	taskID string
}

// Deprecated
// NewApiGetTaskV1Request creates an instance of the ApiGetTaskV1Request to be used for the API call.
func (c *APIClient) NewApiGetTaskV1Request(taskID string) ApiGetTaskV1Request {
	return ApiGetTaskV1Request{
		taskID: taskID,
	}
}

/*
GetTaskV1 calls the API and returns the raw response from it.

	  Retrieves a task by its ID using the v1 endpoint, please use `getTask` instead.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetTaskV1Request with parameters below.
	  @param taskID string - Unique identifier of a task.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails

	  Deprecated
*/
func (c *APIClient) GetTaskV1WithHTTPInfo(r ApiGetTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `GetTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetTaskV1 casts the HTTP response body to a defined struct.

Retrieves a task by its ID using the v1 endpoint, please use `getTask` instead.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTaskV1Request with parameters below.

	@param taskID string - Unique identifier of a task.
	@return TaskV1

Deprecated.
*/
func (c *APIClient) GetTaskV1(r ApiGetTaskV1Request, opts ...RequestOption) (*TaskV1, error) {
	var returnValue *TaskV1

	res, resBody, err := c.GetTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["transformationID"]; ok {
		err = json.Unmarshal(v, &r.transformationID)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetTransformationRequest represents the request with all the parameters for the API call.
type ApiGetTransformationRequest struct {
	transformationID string
}

// NewApiGetTransformationRequest creates an instance of the ApiGetTransformationRequest to be used for the API call.
func (c *APIClient) NewApiGetTransformationRequest(transformationID string) ApiGetTransformationRequest {
	return ApiGetTransformationRequest{
		transformationID: transformationID,
	}
}

/*
GetTransformation calls the API and returns the raw response from it.

	  Retrieves a transformation by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiGetTransformationRequest with parameters below.
	  @param transformationID string - Unique identifier of a transformation.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetTransformationWithHTTPInfo(r ApiGetTransformationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/{transformationID}"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(utils.ParameterToString(r.transformationID)))

	if r.transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `GetTransformation`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetTransformation casts the HTTP response body to a defined struct.

Retrieves a transformation by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiGetTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@return Transformation
*/
func (c *APIClient) GetTransformation(r ApiGetTransformationRequest, opts ...RequestOption) (*Transformation, error) {
	var returnValue *Transformation

	res, resBody, err := c.GetTransformationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListAuthenticationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}

	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}

	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}

	if v, ok := req["platform"]; ok {
		err = json.Unmarshal(v, &r.platform)
		if err != nil {
			err = json.Unmarshal(b, &r.platform)
			if err != nil {
				return fmt.Errorf("cannot unmarshal platform: %w", err)
			}
		}
	}

	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}

	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiListAuthenticationsRequest represents the request with all the parameters for the API call.
type ApiListAuthenticationsRequest struct {
	itemsPerPage *int32
	page         *int32
	type_        []AuthenticationType
	platform     []PlatformWithNone
	sort         AuthenticationSortKeys
	order        OrderKeys
}

// NewApiListAuthenticationsRequest creates an instance of the ApiListAuthenticationsRequest to be used for the API call.
func (c *APIClient) NewApiListAuthenticationsRequest() ApiListAuthenticationsRequest {
	return ApiListAuthenticationsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListAuthenticationsRequest and returns the request for chaining.
func (r ApiListAuthenticationsRequest) WithItemsPerPage(itemsPerPage int32) ApiListAuthenticationsRequest {
	r.itemsPerPage = &itemsPerPage

	return r
}

// WithPage adds the page to the ApiListAuthenticationsRequest and returns the request for chaining.
func (r ApiListAuthenticationsRequest) WithPage(page int32) ApiListAuthenticationsRequest {
	r.page = &page

	return r
}

// WithType adds the type_ to the ApiListAuthenticationsRequest and returns the request for chaining.
func (r ApiListAuthenticationsRequest) WithType(type_ []AuthenticationType) ApiListAuthenticationsRequest {
	r.type_ = type_

	return r
}

// WithPlatform adds the platform to the ApiListAuthenticationsRequest and returns the request for chaining.
func (r ApiListAuthenticationsRequest) WithPlatform(platform []PlatformWithNone) ApiListAuthenticationsRequest {
	r.platform = platform

	return r
}

// WithSort adds the sort to the ApiListAuthenticationsRequest and returns the request for chaining.
func (r ApiListAuthenticationsRequest) WithSort(sort AuthenticationSortKeys) ApiListAuthenticationsRequest {
	r.sort = sort

	return r
}

// WithOrder adds the order to the ApiListAuthenticationsRequest and returns the request for chaining.
func (r ApiListAuthenticationsRequest) WithOrder(order OrderKeys) ApiListAuthenticationsRequest {
	r.order = order

	return r
}

/*
ListAuthentications calls the API and returns the raw response from it.

	  Retrieves a list of all authentication resources.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListAuthenticationsRequest with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param type_ []AuthenticationType - Type of authentication resource to retrieve.
	  @param platform []PlatformWithNone - Ecommerce platform for which to retrieve authentications.
	  @param sort AuthenticationSortKeys - Property by which to sort the list of authentications.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListAuthenticationsWithHTTPInfo(r ApiListAuthenticationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/authentications"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}

	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}

	if !utils.IsNilOrEmpty(r.type_) {
		conf.queryParams.Set("type", utils.QueryParameterToString(r.type_))
	}

	if !utils.IsNilOrEmpty(r.platform) {
		conf.queryParams.Set("platform", utils.QueryParameterToString(r.platform))
	}

	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}

	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
ListAuthentications casts the HTTP response body to a defined struct.

Retrieves a list of all authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListAuthenticationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []AuthenticationType - Type of authentication resource to retrieve.
	@param platform []PlatformWithNone - Ecommerce platform for which to retrieve authentications.
	@param sort AuthenticationSortKeys - Property by which to sort the list of authentications.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListAuthenticationsResponse
*/
func (c *APIClient) ListAuthentications(r ApiListAuthenticationsRequest, opts ...RequestOption) (*ListAuthenticationsResponse, error) {
	var returnValue *ListAuthenticationsResponse

	res, resBody, err := c.ListAuthenticationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListDestinationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}

	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}

	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}

	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}

	if v, ok := req["transformationID"]; ok {
		err = json.Unmarshal(v, &r.transformationID)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationID: %w", err)
			}
		}
	}

	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}

	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiListDestinationsRequest represents the request with all the parameters for the API call.
type ApiListDestinationsRequest struct {
	itemsPerPage     *int32
	page             *int32
	type_            []DestinationType
	authenticationID []string
	transformationID *string
	sort             DestinationSortKeys
	order            OrderKeys
}

// NewApiListDestinationsRequest creates an instance of the ApiListDestinationsRequest to be used for the API call.
func (c *APIClient) NewApiListDestinationsRequest() ApiListDestinationsRequest {
	return ApiListDestinationsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithItemsPerPage(itemsPerPage int32) ApiListDestinationsRequest {
	r.itemsPerPage = &itemsPerPage

	return r
}

// WithPage adds the page to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithPage(page int32) ApiListDestinationsRequest {
	r.page = &page

	return r
}

// WithType adds the type_ to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithType(type_ []DestinationType) ApiListDestinationsRequest {
	r.type_ = type_

	return r
}

// WithAuthenticationID adds the authenticationID to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithAuthenticationID(authenticationID []string) ApiListDestinationsRequest {
	r.authenticationID = authenticationID

	return r
}

// WithTransformationID adds the transformationID to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithTransformationID(transformationID string) ApiListDestinationsRequest {
	r.transformationID = &transformationID

	return r
}

// WithSort adds the sort to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithSort(sort DestinationSortKeys) ApiListDestinationsRequest {
	r.sort = sort

	return r
}

// WithOrder adds the order to the ApiListDestinationsRequest and returns the request for chaining.
func (r ApiListDestinationsRequest) WithOrder(order OrderKeys) ApiListDestinationsRequest {
	r.order = order

	return r
}

/*
ListDestinations calls the API and returns the raw response from it.

	  Retrieves a list of destinations.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListDestinationsRequest with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param type_ []DestinationType - Destination type.
	  @param authenticationID []string - Authentication ID used by destinations.
	  @param transformationID string - Get the list of destinations used by a transformation.
	  @param sort DestinationSortKeys - Property by which to sort the destinations.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListDestinationsWithHTTPInfo(r ApiListDestinationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}

	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}

	if !utils.IsNilOrEmpty(r.type_) {
		conf.queryParams.Set("type", utils.QueryParameterToString(r.type_))
	}

	if !utils.IsNilOrEmpty(r.authenticationID) {
		conf.queryParams.Set("authenticationID", utils.QueryParameterToString(r.authenticationID))
	}

	if !utils.IsNilOrEmpty(r.transformationID) {
		conf.queryParams.Set("transformationID", utils.QueryParameterToString(*r.transformationID))
	}

	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}

	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
ListDestinations casts the HTTP response body to a defined struct.

Retrieves a list of destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListDestinationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []DestinationType - Destination type.
	@param authenticationID []string - Authentication ID used by destinations.
	@param transformationID string - Get the list of destinations used by a transformation.
	@param sort DestinationSortKeys - Property by which to sort the destinations.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListDestinationsResponse
*/
func (c *APIClient) ListDestinations(r ApiListDestinationsRequest, opts ...RequestOption) (*ListDestinationsResponse, error) {
	var returnValue *ListDestinationsResponse

	res, resBody, err := c.ListDestinationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListEventsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["runID"]; ok {
		err = json.Unmarshal(v, &r.runID)
		if err != nil {
			err = json.Unmarshal(b, &r.runID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runID: %w", err)
			}
		}
	}

	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}

	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}

	if v, ok := req["status"]; ok {
		err = json.Unmarshal(v, &r.status)
		if err != nil {
			err = json.Unmarshal(b, &r.status)
			if err != nil {
				return fmt.Errorf("cannot unmarshal status: %w", err)
			}
		}
	}

	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}

	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}

	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}

	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}

	return nil
}

// ApiListEventsRequest represents the request with all the parameters for the API call.
type ApiListEventsRequest struct {
	runID        string
	itemsPerPage *int32
	page         *int32
	status       []EventStatus
	type_        []EventType
	sort         EventSortKeys
	order        OrderKeys
	startDate    *string
	endDate      *string
}

// NewApiListEventsRequest creates an instance of the ApiListEventsRequest to be used for the API call.
func (c *APIClient) NewApiListEventsRequest(runID string) ApiListEventsRequest {
	return ApiListEventsRequest{
		runID: runID,
	}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithItemsPerPage(itemsPerPage int32) ApiListEventsRequest {
	r.itemsPerPage = &itemsPerPage

	return r
}

// WithPage adds the page to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithPage(page int32) ApiListEventsRequest {
	r.page = &page

	return r
}

// WithStatus adds the status to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithStatus(status []EventStatus) ApiListEventsRequest {
	r.status = status

	return r
}

// WithType adds the type_ to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithType(type_ []EventType) ApiListEventsRequest {
	r.type_ = type_

	return r
}

// WithSort adds the sort to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithSort(sort EventSortKeys) ApiListEventsRequest {
	r.sort = sort

	return r
}

// WithOrder adds the order to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithOrder(order OrderKeys) ApiListEventsRequest {
	r.order = order

	return r
}

// WithStartDate adds the startDate to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithStartDate(startDate string) ApiListEventsRequest {
	r.startDate = &startDate

	return r
}

// WithEndDate adds the endDate to the ApiListEventsRequest and returns the request for chaining.
func (r ApiListEventsRequest) WithEndDate(endDate string) ApiListEventsRequest {
	r.endDate = &endDate

	return r
}

/*
ListEvents calls the API and returns the raw response from it.

	  Retrieves a list of events for a task run, identified by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListEventsRequest with parameters below.
	  @param runID string - Unique identifier of a task run.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param status []EventStatus - Event status for filtering the list of task runs.
	  @param type_ []EventType - Event type for filtering the list of task runs.
	  @param sort EventSortKeys - Property by which to sort the list of task run events.
	  @param order OrderKeys - Sort order of the response, ascending or descending.


	  @param startDate string - Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
	  @param endDate string - Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListEventsWithHTTPInfo(r ApiListEventsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/runs/{runID}/events"
	requestPath = strings.ReplaceAll(requestPath, "{runID}", url.PathEscape(utils.ParameterToString(r.runID)))

	if r.runID == "" {
		return nil, nil, reportError("Parameter `runID` is required when calling `ListEvents`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}

	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}

	if !utils.IsNilOrEmpty(r.status) {
		conf.queryParams.Set("status", utils.QueryParameterToString(r.status))
	}

	if !utils.IsNilOrEmpty(r.type_) {
		conf.queryParams.Set("type", utils.QueryParameterToString(r.type_))
	}

	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}

	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}

	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
ListEvents casts the HTTP response body to a defined struct.

Retrieves a list of events for a task run, identified by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListEventsRequest with parameters below.

	@param runID string - Unique identifier of a task run.
	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []EventStatus - Event status for filtering the list of task runs.
	@param type_ []EventType - Event type for filtering the list of task runs.
	@param sort EventSortKeys - Property by which to sort the list of task run events.
	@param order OrderKeys - Sort order of the response, ascending or descending.


	@param startDate string - Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
	@param endDate string - Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used.
	@return ListEventsResponse
*/
func (c *APIClient) ListEvents(r ApiListEventsRequest, opts ...RequestOption) (*ListEventsResponse, error) {
	var returnValue *ListEventsResponse

	res, resBody, err := c.ListEventsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListRunsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}

	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}

	if v, ok := req["status"]; ok {
		err = json.Unmarshal(v, &r.status)
		if err != nil {
			err = json.Unmarshal(b, &r.status)
			if err != nil {
				return fmt.Errorf("cannot unmarshal status: %w", err)
			}
		}
	}

	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}

	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	if v, ok := req["startDate"]; ok {
		err = json.Unmarshal(v, &r.startDate)
		if err != nil {
			err = json.Unmarshal(b, &r.startDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal startDate: %w", err)
			}
		}
	}

	if v, ok := req["endDate"]; ok {
		err = json.Unmarshal(v, &r.endDate)
		if err != nil {
			err = json.Unmarshal(b, &r.endDate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal endDate: %w", err)
			}
		}
	}

	return nil
}

// ApiListRunsRequest represents the request with all the parameters for the API call.
type ApiListRunsRequest struct {
	itemsPerPage *int32
	page         *int32
	status       []RunStatus
	type_        []RunType
	taskID       *string
	sort         RunSortKeys
	order        OrderKeys
	startDate    *string
	endDate      *string
}

// NewApiListRunsRequest creates an instance of the ApiListRunsRequest to be used for the API call.
func (c *APIClient) NewApiListRunsRequest() ApiListRunsRequest {
	return ApiListRunsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithItemsPerPage(itemsPerPage int32) ApiListRunsRequest {
	r.itemsPerPage = &itemsPerPage

	return r
}

// WithPage adds the page to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithPage(page int32) ApiListRunsRequest {
	r.page = &page

	return r
}

// WithStatus adds the status to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithStatus(status []RunStatus) ApiListRunsRequest {
	r.status = status

	return r
}

// WithType adds the type_ to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithType(type_ []RunType) ApiListRunsRequest {
	r.type_ = type_

	return r
}

// WithTaskID adds the taskID to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithTaskID(taskID string) ApiListRunsRequest {
	r.taskID = &taskID

	return r
}

// WithSort adds the sort to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithSort(sort RunSortKeys) ApiListRunsRequest {
	r.sort = sort

	return r
}

// WithOrder adds the order to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithOrder(order OrderKeys) ApiListRunsRequest {
	r.order = order

	return r
}

// WithStartDate adds the startDate to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithStartDate(startDate string) ApiListRunsRequest {
	r.startDate = &startDate

	return r
}

// WithEndDate adds the endDate to the ApiListRunsRequest and returns the request for chaining.
func (r ApiListRunsRequest) WithEndDate(endDate string) ApiListRunsRequest {
	r.endDate = &endDate

	return r
}

/*
ListRuns calls the API and returns the raw response from it.

	  Retrieve a list of task runs.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListRunsRequest with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param status []RunStatus - Run status for filtering the list of task runs.
	  @param type_ []RunType - Run type for filtering the list of task runs.
	  @param taskID string - Task ID for filtering the list of task runs.
	  @param sort RunSortKeys - Property by which to sort the list of task runs.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	  @param startDate string - Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
	  @param endDate string - Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListRunsWithHTTPInfo(r ApiListRunsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/runs"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}

	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}

	if !utils.IsNilOrEmpty(r.status) {
		conf.queryParams.Set("status", utils.QueryParameterToString(r.status))
	}

	if !utils.IsNilOrEmpty(r.type_) {
		conf.queryParams.Set("type", utils.QueryParameterToString(r.type_))
	}

	if !utils.IsNilOrEmpty(r.taskID) {
		conf.queryParams.Set("taskID", utils.QueryParameterToString(*r.taskID))
	}

	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}

	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	if !utils.IsNilOrEmpty(r.startDate) {
		conf.queryParams.Set("startDate", utils.QueryParameterToString(*r.startDate))
	}

	if !utils.IsNilOrEmpty(r.endDate) {
		conf.queryParams.Set("endDate", utils.QueryParameterToString(*r.endDate))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
ListRuns casts the HTTP response body to a defined struct.

Retrieve a list of task runs.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListRunsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param status []RunStatus - Run status for filtering the list of task runs.
	@param type_ []RunType - Run type for filtering the list of task runs.
	@param taskID string - Task ID for filtering the list of task runs.
	@param sort RunSortKeys - Property by which to sort the list of task runs.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param startDate string - Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
	@param endDate string - Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used.
	@return RunListResponse
*/
func (c *APIClient) ListRuns(r ApiListRunsRequest, opts ...RequestOption) (*RunListResponse, error) {
	var returnValue *RunListResponse

	res, resBody, err := c.ListRunsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}

	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}

	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}

	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}

	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}

	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiListSourcesRequest represents the request with all the parameters for the API call.
type ApiListSourcesRequest struct {
	itemsPerPage     *int32
	page             *int32
	type_            []SourceType
	authenticationID []string
	sort             SourceSortKeys
	order            OrderKeys
}

// NewApiListSourcesRequest creates an instance of the ApiListSourcesRequest to be used for the API call.
func (c *APIClient) NewApiListSourcesRequest() ApiListSourcesRequest {
	return ApiListSourcesRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListSourcesRequest and returns the request for chaining.
func (r ApiListSourcesRequest) WithItemsPerPage(itemsPerPage int32) ApiListSourcesRequest {
	r.itemsPerPage = &itemsPerPage

	return r
}

// WithPage adds the page to the ApiListSourcesRequest and returns the request for chaining.
func (r ApiListSourcesRequest) WithPage(page int32) ApiListSourcesRequest {
	r.page = &page

	return r
}

// WithType adds the type_ to the ApiListSourcesRequest and returns the request for chaining.
func (r ApiListSourcesRequest) WithType(type_ []SourceType) ApiListSourcesRequest {
	r.type_ = type_

	return r
}

// WithAuthenticationID adds the authenticationID to the ApiListSourcesRequest and returns the request for chaining.
func (r ApiListSourcesRequest) WithAuthenticationID(authenticationID []string) ApiListSourcesRequest {
	r.authenticationID = authenticationID

	return r
}

// WithSort adds the sort to the ApiListSourcesRequest and returns the request for chaining.
func (r ApiListSourcesRequest) WithSort(sort SourceSortKeys) ApiListSourcesRequest {
	r.sort = sort

	return r
}

// WithOrder adds the order to the ApiListSourcesRequest and returns the request for chaining.
func (r ApiListSourcesRequest) WithOrder(order OrderKeys) ApiListSourcesRequest {
	r.order = order

	return r
}

/*
ListSources calls the API and returns the raw response from it.

	  Retrieves a list of sources.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListSourcesRequest with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param type_ []SourceType - Source type. Some sources require authentication.
	  @param authenticationID []string - Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication.
	  @param sort SourceSortKeys - Property by which to sort the list of sources.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListSourcesWithHTTPInfo(r ApiListSourcesRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}

	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}

	if !utils.IsNilOrEmpty(r.type_) {
		conf.queryParams.Set("type", utils.QueryParameterToString(r.type_))
	}

	if !utils.IsNilOrEmpty(r.authenticationID) {
		conf.queryParams.Set("authenticationID", utils.QueryParameterToString(r.authenticationID))
	}

	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}

	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
ListSources casts the HTTP response body to a defined struct.

Retrieves a list of sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListSourcesRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param type_ []SourceType - Source type. Some sources require authentication.
	@param authenticationID []string - Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication.
	@param sort SourceSortKeys - Property by which to sort the list of sources.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListSourcesResponse
*/
func (c *APIClient) ListSources(r ApiListSourcesRequest, opts ...RequestOption) (*ListSourcesResponse, error) {
	var returnValue *ListSourcesResponse

	res, resBody, err := c.ListSourcesWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListTasksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}

	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}

	if v, ok := req["action"]; ok {
		err = json.Unmarshal(v, &r.action)
		if err != nil {
			err = json.Unmarshal(b, &r.action)
			if err != nil {
				return fmt.Errorf("cannot unmarshal action: %w", err)
			}
		}
	}

	if v, ok := req["enabled"]; ok {
		err = json.Unmarshal(v, &r.enabled)
		if err != nil {
			err = json.Unmarshal(b, &r.enabled)
			if err != nil {
				return fmt.Errorf("cannot unmarshal enabled: %w", err)
			}
		}
	}

	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	if v, ok := req["sourceType"]; ok {
		err = json.Unmarshal(v, &r.sourceType)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceType)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceType: %w", err)
			}
		}
	}

	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}

	if v, ok := req["triggerType"]; ok {
		err = json.Unmarshal(v, &r.triggerType)
		if err != nil {
			err = json.Unmarshal(b, &r.triggerType)
			if err != nil {
				return fmt.Errorf("cannot unmarshal triggerType: %w", err)
			}
		}
	}

	if v, ok := req["withEmailNotifications"]; ok {
		err = json.Unmarshal(v, &r.withEmailNotifications)
		if err != nil {
			err = json.Unmarshal(b, &r.withEmailNotifications)
			if err != nil {
				return fmt.Errorf("cannot unmarshal withEmailNotifications: %w", err)
			}
		}
	}

	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}

	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiListTasksRequest represents the request with all the parameters for the API call.
type ApiListTasksRequest struct {
	itemsPerPage           *int32
	page                   *int32
	action                 []ActionType
	enabled                *bool
	sourceID               []string
	sourceType             []SourceType
	destinationID          []string
	triggerType            []TriggerType
	withEmailNotifications *bool
	sort                   TaskSortKeys
	order                  OrderKeys
}

// NewApiListTasksRequest creates an instance of the ApiListTasksRequest to be used for the API call.
func (c *APIClient) NewApiListTasksRequest() ApiListTasksRequest {
	return ApiListTasksRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithItemsPerPage(itemsPerPage int32) ApiListTasksRequest {
	r.itemsPerPage = &itemsPerPage

	return r
}

// WithPage adds the page to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithPage(page int32) ApiListTasksRequest {
	r.page = &page

	return r
}

// WithAction adds the action to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithAction(action []ActionType) ApiListTasksRequest {
	r.action = action

	return r
}

// WithEnabled adds the enabled to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithEnabled(enabled bool) ApiListTasksRequest {
	r.enabled = &enabled

	return r
}

// WithSourceID adds the sourceID to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithSourceID(sourceID []string) ApiListTasksRequest {
	r.sourceID = sourceID

	return r
}

// WithSourceType adds the sourceType to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithSourceType(sourceType []SourceType) ApiListTasksRequest {
	r.sourceType = sourceType

	return r
}

// WithDestinationID adds the destinationID to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithDestinationID(destinationID []string) ApiListTasksRequest {
	r.destinationID = destinationID

	return r
}

// WithTriggerType adds the triggerType to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithTriggerType(triggerType []TriggerType) ApiListTasksRequest {
	r.triggerType = triggerType

	return r
}

// WithWithEmailNotifications adds the withEmailNotifications to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithWithEmailNotifications(withEmailNotifications bool) ApiListTasksRequest {
	r.withEmailNotifications = &withEmailNotifications

	return r
}

// WithSort adds the sort to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithSort(sort TaskSortKeys) ApiListTasksRequest {
	r.sort = sort

	return r
}

// WithOrder adds the order to the ApiListTasksRequest and returns the request for chaining.
func (r ApiListTasksRequest) WithOrder(order OrderKeys) ApiListTasksRequest {
	r.order = order

	return r
}

/*
ListTasks calls the API and returns the raw response from it.

	  Retrieves a list of tasks.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListTasksRequest with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param action []ActionType - Actions for filtering the list of tasks.
	  @param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	  @param sourceID []string - Source IDs for filtering the list of tasks.
	  @param sourceType []SourceType - Filters the tasks with the specified source type.
	  @param destinationID []string - Destination IDs for filtering the list of tasks.
	  @param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	  @param withEmailNotifications bool - If specified, the response only includes tasks with notifications.email.enabled set to this value.
	  @param sort TaskSortKeys - Property by which to sort the list of tasks.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListTasksWithHTTPInfo(r ApiListTasksRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}

	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}

	if !utils.IsNilOrEmpty(r.action) {
		conf.queryParams.Set("action", utils.QueryParameterToString(r.action))
	}

	if !utils.IsNilOrEmpty(r.enabled) {
		conf.queryParams.Set("enabled", utils.QueryParameterToString(*r.enabled))
	}

	if !utils.IsNilOrEmpty(r.sourceID) {
		conf.queryParams.Set("sourceID", utils.QueryParameterToString(r.sourceID))
	}

	if !utils.IsNilOrEmpty(r.sourceType) {
		conf.queryParams.Set("sourceType", utils.QueryParameterToString(r.sourceType))
	}

	if !utils.IsNilOrEmpty(r.destinationID) {
		conf.queryParams.Set("destinationID", utils.QueryParameterToString(r.destinationID))
	}

	if !utils.IsNilOrEmpty(r.triggerType) {
		conf.queryParams.Set("triggerType", utils.QueryParameterToString(r.triggerType))
	}

	if !utils.IsNilOrEmpty(r.withEmailNotifications) {
		conf.queryParams.Set("withEmailNotifications", utils.QueryParameterToString(*r.withEmailNotifications))
	}

	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}

	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
ListTasks casts the HTTP response body to a defined struct.

Retrieves a list of tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListTasksRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param action []ActionType - Actions for filtering the list of tasks.
	@param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	@param sourceID []string - Source IDs for filtering the list of tasks.
	@param sourceType []SourceType - Filters the tasks with the specified source type.
	@param destinationID []string - Destination IDs for filtering the list of tasks.
	@param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	@param withEmailNotifications bool - If specified, the response only includes tasks with notifications.email.enabled set to this value.
	@param sort TaskSortKeys - Property by which to sort the list of tasks.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTasksResponse
*/
func (c *APIClient) ListTasks(r ApiListTasksRequest, opts ...RequestOption) (*ListTasksResponse, error) {
	var returnValue *ListTasksResponse

	res, resBody, err := c.ListTasksWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListTasksV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}

	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}

	if v, ok := req["action"]; ok {
		err = json.Unmarshal(v, &r.action)
		if err != nil {
			err = json.Unmarshal(b, &r.action)
			if err != nil {
				return fmt.Errorf("cannot unmarshal action: %w", err)
			}
		}
	}

	if v, ok := req["enabled"]; ok {
		err = json.Unmarshal(v, &r.enabled)
		if err != nil {
			err = json.Unmarshal(b, &r.enabled)
			if err != nil {
				return fmt.Errorf("cannot unmarshal enabled: %w", err)
			}
		}
	}

	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}

	if v, ok := req["triggerType"]; ok {
		err = json.Unmarshal(v, &r.triggerType)
		if err != nil {
			err = json.Unmarshal(b, &r.triggerType)
			if err != nil {
				return fmt.Errorf("cannot unmarshal triggerType: %w", err)
			}
		}
	}

	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}

	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	return nil
}

// ApiListTasksV1Request represents the request with all the parameters for the API call.
type ApiListTasksV1Request struct {
	itemsPerPage  *int32
	page          *int32
	action        []ActionType
	enabled       *bool
	sourceID      []string
	destinationID []string
	triggerType   []TriggerType
	sort          TaskSortKeys
	order         OrderKeys
}

// Deprecated
// NewApiListTasksV1Request creates an instance of the ApiListTasksV1Request to be used for the API call.
func (c *APIClient) NewApiListTasksV1Request() ApiListTasksV1Request {
	return ApiListTasksV1Request{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithItemsPerPage(itemsPerPage int32) ApiListTasksV1Request {
	r.itemsPerPage = &itemsPerPage

	return r
}

// WithPage adds the page to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithPage(page int32) ApiListTasksV1Request {
	r.page = &page

	return r
}

// WithAction adds the action to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithAction(action []ActionType) ApiListTasksV1Request {
	r.action = action

	return r
}

// WithEnabled adds the enabled to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithEnabled(enabled bool) ApiListTasksV1Request {
	r.enabled = &enabled

	return r
}

// WithSourceID adds the sourceID to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithSourceID(sourceID []string) ApiListTasksV1Request {
	r.sourceID = sourceID

	return r
}

// WithDestinationID adds the destinationID to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithDestinationID(destinationID []string) ApiListTasksV1Request {
	r.destinationID = destinationID

	return r
}

// WithTriggerType adds the triggerType to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithTriggerType(triggerType []TriggerType) ApiListTasksV1Request {
	r.triggerType = triggerType

	return r
}

// WithSort adds the sort to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithSort(sort TaskSortKeys) ApiListTasksV1Request {
	r.sort = sort

	return r
}

// WithOrder adds the order to the ApiListTasksV1Request and returns the request for chaining.
func (r ApiListTasksV1Request) WithOrder(order OrderKeys) ApiListTasksV1Request {
	r.order = order

	return r
}

/*
ListTasksV1 calls the API and returns the raw response from it.

	  Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListTasksV1Request with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param action []ActionType - Actions for filtering the list of tasks.
	  @param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	  @param sourceID []string - Source IDs for filtering the list of tasks.
	  @param destinationID []string - Destination IDs for filtering the list of tasks.
	  @param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	  @param sort TaskSortKeys - Property by which to sort the list of tasks.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails

	  Deprecated
*/
func (c *APIClient) ListTasksV1WithHTTPInfo(r ApiListTasksV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}

	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}

	if !utils.IsNilOrEmpty(r.action) {
		conf.queryParams.Set("action", utils.QueryParameterToString(r.action))
	}

	if !utils.IsNilOrEmpty(r.enabled) {
		conf.queryParams.Set("enabled", utils.QueryParameterToString(*r.enabled))
	}

	if !utils.IsNilOrEmpty(r.sourceID) {
		conf.queryParams.Set("sourceID", utils.QueryParameterToString(r.sourceID))
	}

	if !utils.IsNilOrEmpty(r.destinationID) {
		conf.queryParams.Set("destinationID", utils.QueryParameterToString(r.destinationID))
	}

	if !utils.IsNilOrEmpty(r.triggerType) {
		conf.queryParams.Set("triggerType", utils.QueryParameterToString(r.triggerType))
	}

	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}

	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
ListTasksV1 casts the HTTP response body to a defined struct.

Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListTasksV1Request with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param action []ActionType - Actions for filtering the list of tasks.
	@param enabled bool - Whether to filter the list of tasks by the `enabled` status.
	@param sourceID []string - Source IDs for filtering the list of tasks.
	@param destinationID []string - Destination IDs for filtering the list of tasks.
	@param triggerType []TriggerType - Type of task trigger for filtering the list of tasks.
	@param sort TaskSortKeys - Property by which to sort the list of tasks.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@return ListTasksResponseV1

Deprecated.
*/
func (c *APIClient) ListTasksV1(r ApiListTasksV1Request, opts ...RequestOption) (*ListTasksResponseV1, error) {
	var returnValue *ListTasksResponseV1

	res, resBody, err := c.ListTasksV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiListTransformationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["itemsPerPage"]; ok {
		err = json.Unmarshal(v, &r.itemsPerPage)
		if err != nil {
			err = json.Unmarshal(b, &r.itemsPerPage)
			if err != nil {
				return fmt.Errorf("cannot unmarshal itemsPerPage: %w", err)
			}
		}
	}

	if v, ok := req["page"]; ok {
		err = json.Unmarshal(v, &r.page)
		if err != nil {
			err = json.Unmarshal(b, &r.page)
			if err != nil {
				return fmt.Errorf("cannot unmarshal page: %w", err)
			}
		}
	}

	if v, ok := req["sort"]; ok {
		err = json.Unmarshal(v, &r.sort)
		if err != nil {
			err = json.Unmarshal(b, &r.sort)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sort: %w", err)
			}
		}
	}

	if v, ok := req["order"]; ok {
		err = json.Unmarshal(v, &r.order)
		if err != nil {
			err = json.Unmarshal(b, &r.order)
			if err != nil {
				return fmt.Errorf("cannot unmarshal order: %w", err)
			}
		}
	}

	if v, ok := req["type"]; ok {
		err = json.Unmarshal(v, &r.type_)
		if err != nil {
			err = json.Unmarshal(b, &r.type_)
			if err != nil {
				return fmt.Errorf("cannot unmarshal type_: %w", err)
			}
		}
	}

	return nil
}

// ApiListTransformationsRequest represents the request with all the parameters for the API call.
type ApiListTransformationsRequest struct {
	itemsPerPage *int32
	page         *int32
	sort         TransformationSortKeys
	order        OrderKeys
	type_        TransformationType
}

// NewApiListTransformationsRequest creates an instance of the ApiListTransformationsRequest to be used for the API call.
func (c *APIClient) NewApiListTransformationsRequest() ApiListTransformationsRequest {
	return ApiListTransformationsRequest{}
}

// WithItemsPerPage adds the itemsPerPage to the ApiListTransformationsRequest and returns the request for chaining.
func (r ApiListTransformationsRequest) WithItemsPerPage(itemsPerPage int32) ApiListTransformationsRequest {
	r.itemsPerPage = &itemsPerPage

	return r
}

// WithPage adds the page to the ApiListTransformationsRequest and returns the request for chaining.
func (r ApiListTransformationsRequest) WithPage(page int32) ApiListTransformationsRequest {
	r.page = &page

	return r
}

// WithSort adds the sort to the ApiListTransformationsRequest and returns the request for chaining.
func (r ApiListTransformationsRequest) WithSort(sort TransformationSortKeys) ApiListTransformationsRequest {
	r.sort = sort

	return r
}

// WithOrder adds the order to the ApiListTransformationsRequest and returns the request for chaining.
func (r ApiListTransformationsRequest) WithOrder(order OrderKeys) ApiListTransformationsRequest {
	r.order = order

	return r
}

// WithType adds the type_ to the ApiListTransformationsRequest and returns the request for chaining.
func (r ApiListTransformationsRequest) WithType(type_ TransformationType) ApiListTransformationsRequest {
	r.type_ = type_

	return r
}

/*
ListTransformations calls the API and returns the raw response from it.

	  Retrieves a list of transformations.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiListTransformationsRequest with parameters below.
	  @param itemsPerPage int32 - Number of items per page.
	  @param page int32 - Page number of the paginated API response.
	  @param sort TransformationSortKeys - Property by which to sort the list of transformations.
	  @param order OrderKeys - Sort order of the response, ascending or descending.
	  @param type_ TransformationType - Whether to filter the list of transformations by the type of transformation.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ListTransformationsWithHTTPInfo(r ApiListTransformationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.itemsPerPage) {
		conf.queryParams.Set("itemsPerPage", utils.QueryParameterToString(*r.itemsPerPage))
	}

	if !utils.IsNilOrEmpty(r.page) {
		conf.queryParams.Set("page", utils.QueryParameterToString(*r.page))
	}

	if !utils.IsNilOrEmpty(r.sort) {
		conf.queryParams.Set("sort", utils.QueryParameterToString(r.sort))
	}

	if !utils.IsNilOrEmpty(r.order) {
		conf.queryParams.Set("order", utils.QueryParameterToString(r.order))
	}

	if !utils.IsNilOrEmpty(r.type_) {
		conf.queryParams.Set("type", utils.QueryParameterToString(r.type_))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
ListTransformations casts the HTTP response body to a defined struct.

Retrieves a list of transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiListTransformationsRequest with parameters below.

	@param itemsPerPage int32 - Number of items per page.
	@param page int32 - Page number of the paginated API response.
	@param sort TransformationSortKeys - Property by which to sort the list of transformations.
	@param order OrderKeys - Sort order of the response, ascending or descending.
	@param type_ TransformationType - Whether to filter the list of transformations by the type of transformation.
	@return ListTransformationsResponse
*/
func (c *APIClient) ListTransformations(r ApiListTransformationsRequest, opts ...RequestOption) (*ListTransformationsResponse, error) {
	var returnValue *ListTransformationsResponse

	res, resBody, err := c.ListTransformationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPushRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	if v, ok := req["pushTaskPayload"]; ok {
		err = json.Unmarshal(v, &r.pushTaskPayload)
		if err != nil {
			err = json.Unmarshal(b, &r.pushTaskPayload)
			if err != nil {
				return fmt.Errorf("cannot unmarshal pushTaskPayload: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.pushTaskPayload)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter pushTaskPayload: %w", err)
		}
	}

	if v, ok := req["watch"]; ok {
		err = json.Unmarshal(v, &r.watch)
		if err != nil {
			err = json.Unmarshal(b, &r.watch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal watch: %w", err)
			}
		}
	}

	if v, ok := req["referenceIndexName"]; ok {
		err = json.Unmarshal(v, &r.referenceIndexName)
		if err != nil {
			err = json.Unmarshal(b, &r.referenceIndexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal referenceIndexName: %w", err)
			}
		}
	}

	return nil
}

// ApiPushRequest represents the request with all the parameters for the API call.
type ApiPushRequest struct {
	indexName          string
	pushTaskPayload    *PushTaskPayload
	watch              *bool
	referenceIndexName *string
}

// NewApiPushRequest creates an instance of the ApiPushRequest to be used for the API call.
func (c *APIClient) NewApiPushRequest(indexName string, pushTaskPayload *PushTaskPayload) ApiPushRequest {
	return ApiPushRequest{
		indexName:       indexName,
		pushTaskPayload: pushTaskPayload,
	}
}

// WithWatch adds the watch to the ApiPushRequest and returns the request for chaining.
func (r ApiPushRequest) WithWatch(watch bool) ApiPushRequest {
	r.watch = &watch

	return r
}

// WithReferenceIndexName adds the referenceIndexName to the ApiPushRequest and returns the request for chaining.
func (r ApiPushRequest) WithReferenceIndexName(referenceIndexName string) ApiPushRequest {
	r.referenceIndexName = &referenceIndexName

	return r
}

/*
Push calls the API and returns the raw response from it.

	Pushes records through the Pipeline, directly to an index. You can make the call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the observability endpoints and/or debugger dashboard to see the status of your task.

If you want to leverage the [pre-indexing data transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data), this is the recommended way of ingesting your records.
This method is similar to `pushTask`, but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error will be returned.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiPushRequest with parameters below.
	  @param indexName string - Name of the index on which to perform the operation.
	  @param pushTaskPayload PushTaskPayload


	@param watch bool - When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding.


	  @param referenceIndexName string - This is required when targeting an index that does not have a push connector setup (e.g. a tmp index), but you wish to attach another index's transformation to it (e.g. the source index name).
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) PushWithHTTPInfo(r ApiPushRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/push/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(r.indexName)))

	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `Push`.")
	}

	if r.pushTaskPayload == nil {
		return nil, nil, reportError("Parameter `pushTaskPayload` is required when calling `Push`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
		timeouts: transport.RequestConfiguration{
			ReadTimeout:    utils.ToPtr(180000 * time.Millisecond),
			WriteTimeout:   utils.ToPtr(180000 * time.Millisecond),
			ConnectTimeout: utils.ToPtr(180000 * time.Millisecond),
		},
	}

	if !utils.IsNilOrEmpty(r.watch) {
		conf.queryParams.Set("watch", utils.QueryParameterToString(*r.watch))
	}

	if !utils.IsNilOrEmpty(r.referenceIndexName) {
		conf.queryParams.Set("referenceIndexName", utils.QueryParameterToString(*r.referenceIndexName))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.pushTaskPayload

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
Push casts the HTTP response body to a defined struct.

Pushes records through the Pipeline, directly to an index. You can make the call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the observability endpoints and/or debugger dashboard to see the status of your task.
If you want to leverage the [pre-indexing data transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data), this is the recommended way of ingesting your records.
This method is similar to `pushTask`, but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error will be returned.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiPushRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param pushTaskPayload PushTaskPayload


	@param watch bool - When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding.


	@param referenceIndexName string - This is required when targeting an index that does not have a push connector setup (e.g. a tmp index), but you wish to attach another index's transformation to it (e.g. the source index name).
	@return WatchResponse
*/
func (c *APIClient) Push(r ApiPushRequest, opts ...RequestOption) (*WatchResponse, error) {
	var returnValue *WatchResponse

	res, resBody, err := c.PushWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiPushTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	if v, ok := req["pushTaskPayload"]; ok {
		err = json.Unmarshal(v, &r.pushTaskPayload)
		if err != nil {
			err = json.Unmarshal(b, &r.pushTaskPayload)
			if err != nil {
				return fmt.Errorf("cannot unmarshal pushTaskPayload: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.pushTaskPayload)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter pushTaskPayload: %w", err)
		}
	}

	if v, ok := req["watch"]; ok {
		err = json.Unmarshal(v, &r.watch)
		if err != nil {
			err = json.Unmarshal(b, &r.watch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal watch: %w", err)
			}
		}
	}

	return nil
}

// ApiPushTaskRequest represents the request with all the parameters for the API call.
type ApiPushTaskRequest struct {
	taskID          string
	pushTaskPayload *PushTaskPayload
	watch           *bool
}

// NewApiPushTaskRequest creates an instance of the ApiPushTaskRequest to be used for the API call.
func (c *APIClient) NewApiPushTaskRequest(taskID string, pushTaskPayload *PushTaskPayload) ApiPushTaskRequest {
	return ApiPushTaskRequest{
		taskID:          taskID,
		pushTaskPayload: pushTaskPayload,
	}
}

// WithWatch adds the watch to the ApiPushTaskRequest and returns the request for chaining.
func (r ApiPushTaskRequest) WithWatch(watch bool) ApiPushTaskRequest {
	r.watch = &watch

	return r
}

/*
PushTask calls the API and returns the raw response from it.

	Pushes records through the pipeline, directly to an index. You can make the call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the observability endpoints or the debugger dashboard to see the status of your task.

If you want to transform your data before indexing, this is the recommended way of ingesting your records.
This method is similar to `push`, but requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target the same `indexName`.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiPushTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	  @param pushTaskPayload PushTaskPayload


	  @param watch bool - When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) PushTaskWithHTTPInfo(r ApiPushTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}/push"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `PushTask`.")
	}

	if r.pushTaskPayload == nil {
		return nil, nil, reportError("Parameter `pushTaskPayload` is required when calling `PushTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
		timeouts: transport.RequestConfiguration{
			ReadTimeout:    utils.ToPtr(180000 * time.Millisecond),
			WriteTimeout:   utils.ToPtr(180000 * time.Millisecond),
			ConnectTimeout: utils.ToPtr(180000 * time.Millisecond),
		},
	}

	if !utils.IsNilOrEmpty(r.watch) {
		conf.queryParams.Set("watch", utils.QueryParameterToString(*r.watch))
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.pushTaskPayload

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
PushTask casts the HTTP response body to a defined struct.

Pushes records through the pipeline, directly to an index. You can make the call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the observability endpoints or the debugger dashboard to see the status of your task.
If you want to transform your data before indexing, this is the recommended way of ingesting your records.
This method is similar to `push`, but requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target the same `indexName`.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiPushTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@param pushTaskPayload PushTaskPayload


	@param watch bool - When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding.
	@return WatchResponse
*/
func (c *APIClient) PushTask(r ApiPushTaskRequest, opts ...RequestOption) (*WatchResponse, error) {
	var returnValue *WatchResponse

	res, resBody, err := c.PushTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiReplaceTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	if v, ok := req["taskReplace"]; ok {
		err = json.Unmarshal(v, &r.taskReplace)
		if err != nil {
			err = json.Unmarshal(b, &r.taskReplace)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskReplace: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskReplace)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskReplace: %w", err)
		}
	}

	return nil
}

// ApiReplaceTaskRequest represents the request with all the parameters for the API call.
type ApiReplaceTaskRequest struct {
	taskID      string
	taskReplace *TaskReplace
}

// NewApiReplaceTaskRequest creates an instance of the ApiReplaceTaskRequest to be used for the API call.
func (c *APIClient) NewApiReplaceTaskRequest(taskID string, taskReplace *TaskReplace) ApiReplaceTaskRequest {
	return ApiReplaceTaskRequest{
		taskID:      taskID,
		taskReplace: taskReplace,
	}
}

/*
ReplaceTask calls the API and returns the raw response from it.

	  Fully updates a task by its ID, use partialUpdateTask if you only want to update a subset of fields.


	Request can be constructed by NewApiReplaceTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	  @param taskReplace TaskReplace
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ReplaceTaskWithHTTPInfo(r ApiReplaceTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `ReplaceTask`.")
	}

	if r.taskReplace == nil {
		return nil, nil, reportError("Parameter `taskReplace` is required when calling `ReplaceTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskReplace

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
ReplaceTask casts the HTTP response body to a defined struct.

Fully updates a task by its ID, use partialUpdateTask if you only want to update a subset of fields.

Request can be constructed by NewApiReplaceTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@param taskReplace TaskReplace
	@return TaskUpdateResponse
*/
func (c *APIClient) ReplaceTask(r ApiReplaceTaskRequest, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.ReplaceTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRunSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	if v, ok := req["runSourcePayload"]; ok {
		err = json.Unmarshal(v, &r.runSourcePayload)
		if err != nil {
			err = json.Unmarshal(b, &r.runSourcePayload)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runSourcePayload: %w", err)
			}
		}
	}

	return nil
}

// ApiRunSourceRequest represents the request with all the parameters for the API call.
type ApiRunSourceRequest struct {
	sourceID         string
	runSourcePayload *RunSourcePayload
}

// NewApiRunSourceRequest creates an instance of the ApiRunSourceRequest to be used for the API call.
func (c *APIClient) NewApiRunSourceRequest(sourceID string) ApiRunSourceRequest {
	return ApiRunSourceRequest{
		sourceID: sourceID,
	}
}

// WithRunSourcePayload adds the runSourcePayload to the ApiRunSourceRequest and returns the request for chaining.
func (r ApiRunSourceRequest) WithRunSourcePayload(runSourcePayload *RunSourcePayload) ApiRunSourceRequest {
	r.runSourcePayload = runSourcePayload

	return r
}

/*
RunSource calls the API and returns the raw response from it.

	  Runs all tasks linked to a source, only available for Shopify, BigCommerce and commercetools sources. Creates one run per task.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiRunSourceRequest with parameters below.
	  @param sourceID string - Unique identifier of a source.
	  @param runSourcePayload RunSourcePayload -
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) RunSourceWithHTTPInfo(r ApiRunSourceRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(r.sourceID)))

	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `RunSource`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.runSourcePayload) {
		postBody = "{}"
	} else {
		postBody = r.runSourcePayload
	}

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
RunSource casts the HTTP response body to a defined struct.

Runs all tasks linked to a source, only available for Shopify, BigCommerce and commercetools sources. Creates one run per task.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiRunSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param runSourcePayload RunSourcePayload -
	@return RunSourceResponse
*/
func (c *APIClient) RunSource(r ApiRunSourceRequest, opts ...RequestOption) (*RunSourceResponse, error) {
	var returnValue *RunSourceResponse

	res, resBody, err := c.RunSourceWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRunTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	if v, ok := req["runTaskPayload"]; ok {
		err = json.Unmarshal(v, &r.runTaskPayload)
		if err != nil {
			err = json.Unmarshal(b, &r.runTaskPayload)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runTaskPayload: %w", err)
			}
		}
	}

	return nil
}

// ApiRunTaskRequest represents the request with all the parameters for the API call.
type ApiRunTaskRequest struct {
	taskID         string
	runTaskPayload *RunTaskPayload
}

// NewApiRunTaskRequest creates an instance of the ApiRunTaskRequest to be used for the API call.
func (c *APIClient) NewApiRunTaskRequest(taskID string) ApiRunTaskRequest {
	return ApiRunTaskRequest{
		taskID: taskID,
	}
}

// WithRunTaskPayload adds the runTaskPayload to the ApiRunTaskRequest and returns the request for chaining.
func (r ApiRunTaskRequest) WithRunTaskPayload(runTaskPayload *RunTaskPayload) ApiRunTaskRequest {
	r.runTaskPayload = runTaskPayload

	return r
}

/*
RunTask calls the API and returns the raw response from it.

	  Runs a task. You can check the status of task runs with the observability endpoints.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiRunTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	  @param runTaskPayload RunTaskPayload -
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) RunTaskWithHTTPInfo(r ApiRunTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `RunTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.runTaskPayload) {
		postBody = "{}"
	} else {
		postBody = r.runTaskPayload
	}

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
RunTask casts the HTTP response body to a defined struct.

Runs a task. You can check the status of task runs with the observability endpoints.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiRunTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@param runTaskPayload RunTaskPayload -
	@return RunResponse
*/
func (c *APIClient) RunTask(r ApiRunTaskRequest, opts ...RequestOption) (*RunResponse, error) {
	var returnValue *RunResponse

	res, resBody, err := c.RunTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiRunTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	if v, ok := req["runTaskPayload"]; ok {
		err = json.Unmarshal(v, &r.runTaskPayload)
		if err != nil {
			err = json.Unmarshal(b, &r.runTaskPayload)
			if err != nil {
				return fmt.Errorf("cannot unmarshal runTaskPayload: %w", err)
			}
		}
	}

	return nil
}

// ApiRunTaskV1Request represents the request with all the parameters for the API call.
type ApiRunTaskV1Request struct {
	taskID         string
	runTaskPayload *RunTaskPayload
}

// Deprecated
// NewApiRunTaskV1Request creates an instance of the ApiRunTaskV1Request to be used for the API call.
func (c *APIClient) NewApiRunTaskV1Request(taskID string) ApiRunTaskV1Request {
	return ApiRunTaskV1Request{
		taskID: taskID,
	}
}

// WithRunTaskPayload adds the runTaskPayload to the ApiRunTaskV1Request and returns the request for chaining.
func (r ApiRunTaskV1Request) WithRunTaskPayload(runTaskPayload *RunTaskPayload) ApiRunTaskV1Request {
	r.runTaskPayload = runTaskPayload

	return r
}

/*
RunTaskV1 calls the API and returns the raw response from it.

	  Runs a task using the v1 endpoint, please use `runTask` instead. You can check the status of task runs with the observability endpoints.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiRunTaskV1Request with parameters below.
	  @param taskID string - Unique identifier of a task.
	  @param runTaskPayload RunTaskPayload -
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails

	  Deprecated
*/
func (c *APIClient) RunTaskV1WithHTTPInfo(r ApiRunTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `RunTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.runTaskPayload) {
		postBody = "{}"
	} else {
		postBody = r.runTaskPayload
	}

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
RunTaskV1 casts the HTTP response body to a defined struct.

Runs a task using the v1 endpoint, please use `runTask` instead. You can check the status of task runs with the observability endpoints.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiRunTaskV1Request with parameters below.

	@param taskID string - Unique identifier of a task.
	@param runTaskPayload RunTaskPayload -
	@return RunResponse

Deprecated.
*/
func (c *APIClient) RunTaskV1(r ApiRunTaskV1Request, opts ...RequestOption) (*RunResponse, error) {
	var returnValue *RunResponse

	res, resBody, err := c.RunTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchAuthenticationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["authenticationSearch"]; ok {
		err = json.Unmarshal(v, &r.authenticationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter authenticationSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchAuthenticationsRequest represents the request with all the parameters for the API call.
type ApiSearchAuthenticationsRequest struct {
	authenticationSearch *AuthenticationSearch
}

// NewApiSearchAuthenticationsRequest creates an instance of the ApiSearchAuthenticationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchAuthenticationsRequest(authenticationSearch *AuthenticationSearch) ApiSearchAuthenticationsRequest {
	return ApiSearchAuthenticationsRequest{
		authenticationSearch: authenticationSearch,
	}
}

/*
SearchAuthentications calls the API and returns the raw response from it.

	  Searches for authentication resources.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiSearchAuthenticationsRequest with parameters below.
	  @param authenticationSearch AuthenticationSearch
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchAuthenticationsWithHTTPInfo(r ApiSearchAuthenticationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/authentications/search"

	if r.authenticationSearch == nil {
		return nil, nil, reportError("Parameter `authenticationSearch` is required when calling `SearchAuthentications`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.authenticationSearch

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
SearchAuthentications casts the HTTP response body to a defined struct.

Searches for authentication resources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchAuthenticationsRequest with parameters below.

	@param authenticationSearch AuthenticationSearch
	@return []Authentication
*/
func (c *APIClient) SearchAuthentications(r ApiSearchAuthenticationsRequest, opts ...RequestOption) ([]Authentication, error) {
	var returnValue []Authentication

	res, resBody, err := c.SearchAuthenticationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchDestinationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["destinationSearch"]; ok {
		err = json.Unmarshal(v, &r.destinationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter destinationSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchDestinationsRequest represents the request with all the parameters for the API call.
type ApiSearchDestinationsRequest struct {
	destinationSearch *DestinationSearch
}

// NewApiSearchDestinationsRequest creates an instance of the ApiSearchDestinationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchDestinationsRequest(destinationSearch *DestinationSearch) ApiSearchDestinationsRequest {
	return ApiSearchDestinationsRequest{
		destinationSearch: destinationSearch,
	}
}

/*
SearchDestinations calls the API and returns the raw response from it.

	  Searches for destinations.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiSearchDestinationsRequest with parameters below.
	  @param destinationSearch DestinationSearch
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchDestinationsWithHTTPInfo(r ApiSearchDestinationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations/search"

	if r.destinationSearch == nil {
		return nil, nil, reportError("Parameter `destinationSearch` is required when calling `SearchDestinations`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.destinationSearch

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
SearchDestinations casts the HTTP response body to a defined struct.

Searches for destinations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchDestinationsRequest with parameters below.

	@param destinationSearch DestinationSearch
	@return []Destination
*/
func (c *APIClient) SearchDestinations(r ApiSearchDestinationsRequest, opts ...RequestOption) ([]Destination, error) {
	var returnValue []Destination

	res, resBody, err := c.SearchDestinationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchSourcesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["sourceSearch"]; ok {
		err = json.Unmarshal(v, &r.sourceSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchSourcesRequest represents the request with all the parameters for the API call.
type ApiSearchSourcesRequest struct {
	sourceSearch *SourceSearch
}

// NewApiSearchSourcesRequest creates an instance of the ApiSearchSourcesRequest to be used for the API call.
func (c *APIClient) NewApiSearchSourcesRequest(sourceSearch *SourceSearch) ApiSearchSourcesRequest {
	return ApiSearchSourcesRequest{
		sourceSearch: sourceSearch,
	}
}

/*
SearchSources calls the API and returns the raw response from it.

	  Searches for sources.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiSearchSourcesRequest with parameters below.
	  @param sourceSearch SourceSearch
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchSourcesWithHTTPInfo(r ApiSearchSourcesRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/search"

	if r.sourceSearch == nil {
		return nil, nil, reportError("Parameter `sourceSearch` is required when calling `SearchSources`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.sourceSearch

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
SearchSources casts the HTTP response body to a defined struct.

Searches for sources.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchSourcesRequest with parameters below.

	@param sourceSearch SourceSearch
	@return []Source
*/
func (c *APIClient) SearchSources(r ApiSearchSourcesRequest, opts ...RequestOption) ([]Source, error) {
	var returnValue []Source

	res, resBody, err := c.SearchSourcesWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchTasksRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskSearch"]; ok {
		err = json.Unmarshal(v, &r.taskSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.taskSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchTasksRequest represents the request with all the parameters for the API call.
type ApiSearchTasksRequest struct {
	taskSearch *TaskSearch
}

// NewApiSearchTasksRequest creates an instance of the ApiSearchTasksRequest to be used for the API call.
func (c *APIClient) NewApiSearchTasksRequest(taskSearch *TaskSearch) ApiSearchTasksRequest {
	return ApiSearchTasksRequest{
		taskSearch: taskSearch,
	}
}

/*
SearchTasks calls the API and returns the raw response from it.

	  Searches for tasks.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiSearchTasksRequest with parameters below.
	  @param taskSearch TaskSearch
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchTasksWithHTTPInfo(r ApiSearchTasksRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/search"

	if r.taskSearch == nil {
		return nil, nil, reportError("Parameter `taskSearch` is required when calling `SearchTasks`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskSearch

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
SearchTasks casts the HTTP response body to a defined struct.

Searches for tasks.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTasksRequest with parameters below.

	@param taskSearch TaskSearch
	@return []Task
*/
func (c *APIClient) SearchTasks(r ApiSearchTasksRequest, opts ...RequestOption) ([]Task, error) {
	var returnValue []Task

	res, resBody, err := c.SearchTasksWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchTasksV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskSearch"]; ok {
		err = json.Unmarshal(v, &r.taskSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.taskSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchTasksV1Request represents the request with all the parameters for the API call.
type ApiSearchTasksV1Request struct {
	taskSearch *TaskSearch
}

// Deprecated
// NewApiSearchTasksV1Request creates an instance of the ApiSearchTasksV1Request to be used for the API call.
func (c *APIClient) NewApiSearchTasksV1Request(taskSearch *TaskSearch) ApiSearchTasksV1Request {
	return ApiSearchTasksV1Request{
		taskSearch: taskSearch,
	}
}

/*
SearchTasksV1 calls the API and returns the raw response from it.

	  Searches for tasks using the v1 endpoint, please use `searchTasks` instead.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiSearchTasksV1Request with parameters below.
	  @param taskSearch TaskSearch
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails

	  Deprecated
*/
func (c *APIClient) SearchTasksV1WithHTTPInfo(r ApiSearchTasksV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/search"

	if r.taskSearch == nil {
		return nil, nil, reportError("Parameter `taskSearch` is required when calling `SearchTasksV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskSearch

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
SearchTasksV1 casts the HTTP response body to a defined struct.

Searches for tasks using the v1 endpoint, please use `searchTasks` instead.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTasksV1Request with parameters below.

	@param taskSearch TaskSearch
	@return []TaskV1

Deprecated.
*/
func (c *APIClient) SearchTasksV1(r ApiSearchTasksV1Request, opts ...RequestOption) ([]TaskV1, error) {
	var returnValue []TaskV1

	res, resBody, err := c.SearchTasksV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchTransformationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["transformationSearch"]; ok {
		err = json.Unmarshal(v, &r.transformationSearch)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationSearch)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationSearch: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationSearch)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationSearch: %w", err)
		}
	}

	return nil
}

// ApiSearchTransformationsRequest represents the request with all the parameters for the API call.
type ApiSearchTransformationsRequest struct {
	transformationSearch *TransformationSearch
}

// NewApiSearchTransformationsRequest creates an instance of the ApiSearchTransformationsRequest to be used for the API call.
func (c *APIClient) NewApiSearchTransformationsRequest(transformationSearch *TransformationSearch) ApiSearchTransformationsRequest {
	return ApiSearchTransformationsRequest{
		transformationSearch: transformationSearch,
	}
}

/*
SearchTransformations calls the API and returns the raw response from it.

	  Searches for transformations.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiSearchTransformationsRequest with parameters below.
	  @param transformationSearch TransformationSearch
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchTransformationsWithHTTPInfo(r ApiSearchTransformationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/search"

	if r.transformationSearch == nil {
		return nil, nil, reportError("Parameter `transformationSearch` is required when calling `SearchTransformations`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.transformationSearch

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
SearchTransformations casts the HTTP response body to a defined struct.

Searches for transformations.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiSearchTransformationsRequest with parameters below.

	@param transformationSearch TransformationSearch
	@return []Transformation
*/
func (c *APIClient) SearchTransformations(r ApiSearchTransformationsRequest, opts ...RequestOption) ([]Transformation, error) {
	var returnValue []Transformation

	res, resBody, err := c.SearchTransformationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiTriggerDockerSourceDiscoverRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	return nil
}

// ApiTriggerDockerSourceDiscoverRequest represents the request with all the parameters for the API call.
type ApiTriggerDockerSourceDiscoverRequest struct {
	sourceID string
}

// NewApiTriggerDockerSourceDiscoverRequest creates an instance of the ApiTriggerDockerSourceDiscoverRequest to be used for the API call.
func (c *APIClient) NewApiTriggerDockerSourceDiscoverRequest(sourceID string) ApiTriggerDockerSourceDiscoverRequest {
	return ApiTriggerDockerSourceDiscoverRequest{
		sourceID: sourceID,
	}
}

/*
TriggerDockerSourceDiscover calls the API and returns the raw response from it.

	Triggers a stream-listing request for a source.

Triggering stream-listing requests only works with sources with `type: docker` and `imageType: airbyte`.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiTriggerDockerSourceDiscoverRequest with parameters below.
	  @param sourceID string - Unique identifier of a source.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) TriggerDockerSourceDiscoverWithHTTPInfo(
	r ApiTriggerDockerSourceDiscoverRequest,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}/discover"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(r.sourceID)))

	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `TriggerDockerSourceDiscover`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
		timeouts: transport.RequestConfiguration{
			ReadTimeout:    utils.ToPtr(180000 * time.Millisecond),
			WriteTimeout:   utils.ToPtr(180000 * time.Millisecond),
			ConnectTimeout: utils.ToPtr(180000 * time.Millisecond),
		},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
TriggerDockerSourceDiscover casts the HTTP response body to a defined struct.

Triggers a stream-listing request for a source.
Triggering stream-listing requests only works with sources with `type: docker` and `imageType: airbyte`.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTriggerDockerSourceDiscoverRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@return WatchResponse
*/
func (c *APIClient) TriggerDockerSourceDiscover(r ApiTriggerDockerSourceDiscoverRequest, opts ...RequestOption) (*WatchResponse, error) {
	var returnValue *WatchResponse

	res, resBody, err := c.TriggerDockerSourceDiscoverWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiTryTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["transformationTry"]; ok {
		err = json.Unmarshal(v, &r.transformationTry)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationTry)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationTry: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationTry)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationTry: %w", err)
		}
	}

	return nil
}

// ApiTryTransformationRequest represents the request with all the parameters for the API call.
type ApiTryTransformationRequest struct {
	transformationTry *TransformationTry
}

// NewApiTryTransformationRequest creates an instance of the ApiTryTransformationRequest to be used for the API call.
func (c *APIClient) NewApiTryTransformationRequest(transformationTry *TransformationTry) ApiTryTransformationRequest {
	return ApiTryTransformationRequest{
		transformationTry: transformationTry,
	}
}

/*
TryTransformation calls the API and returns the raw response from it.

	  Try a transformation before creating it.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiTryTransformationRequest with parameters below.
	  @param transformationTry TransformationTry
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) TryTransformationWithHTTPInfo(r ApiTryTransformationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/try"

	if r.transformationTry == nil {
		return nil, nil, reportError("Parameter `transformationTry` is required when calling `TryTransformation`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.transformationTry

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
TryTransformation casts the HTTP response body to a defined struct.

Try a transformation before creating it.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTryTransformationRequest with parameters below.

	@param transformationTry TransformationTry
	@return TransformationTryResponse
*/
func (c *APIClient) TryTransformation(r ApiTryTransformationRequest, opts ...RequestOption) (*TransformationTryResponse, error) {
	var returnValue *TransformationTryResponse

	res, resBody, err := c.TryTransformationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiTryTransformationBeforeUpdateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["transformationID"]; ok {
		err = json.Unmarshal(v, &r.transformationID)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationID: %w", err)
			}
		}
	}

	if v, ok := req["transformationTry"]; ok {
		err = json.Unmarshal(v, &r.transformationTry)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationTry)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationTry: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationTry)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationTry: %w", err)
		}
	}

	return nil
}

// ApiTryTransformationBeforeUpdateRequest represents the request with all the parameters for the API call.
type ApiTryTransformationBeforeUpdateRequest struct {
	transformationID  string
	transformationTry *TransformationTry
}

// NewApiTryTransformationBeforeUpdateRequest creates an instance of the ApiTryTransformationBeforeUpdateRequest to be used for the API call.
func (c *APIClient) NewApiTryTransformationBeforeUpdateRequest(
	transformationID string,
	transformationTry *TransformationTry,
) ApiTryTransformationBeforeUpdateRequest {
	return ApiTryTransformationBeforeUpdateRequest{
		transformationID:  transformationID,
		transformationTry: transformationTry,
	}
}

/*
TryTransformationBeforeUpdate calls the API and returns the raw response from it.

	  Try a transformation before updating it.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiTryTransformationBeforeUpdateRequest with parameters below.
	  @param transformationID string - Unique identifier of a transformation.
	  @param transformationTry TransformationTry
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) TryTransformationBeforeUpdateWithHTTPInfo(
	r ApiTryTransformationBeforeUpdateRequest,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/{transformationID}/try"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(utils.ParameterToString(r.transformationID)))

	if r.transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `TryTransformationBeforeUpdate`.")
	}

	if r.transformationTry == nil {
		return nil, nil, reportError("Parameter `transformationTry` is required when calling `TryTransformationBeforeUpdate`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.transformationTry

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
TryTransformationBeforeUpdate casts the HTTP response body to a defined struct.

Try a transformation before updating it.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiTryTransformationBeforeUpdateRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@param transformationTry TransformationTry
	@return TransformationTryResponse
*/
func (c *APIClient) TryTransformationBeforeUpdate(
	r ApiTryTransformationBeforeUpdateRequest,
	opts ...RequestOption,
) (*TransformationTryResponse, error) {
	var returnValue *TransformationTryResponse

	res, resBody, err := c.TryTransformationBeforeUpdateWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateAuthenticationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["authenticationID"]; ok {
		err = json.Unmarshal(v, &r.authenticationID)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationID: %w", err)
			}
		}
	}

	if v, ok := req["authenticationUpdate"]; ok {
		err = json.Unmarshal(v, &r.authenticationUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.authenticationUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal authenticationUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.authenticationUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter authenticationUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateAuthenticationRequest represents the request with all the parameters for the API call.
type ApiUpdateAuthenticationRequest struct {
	authenticationID     string
	authenticationUpdate *AuthenticationUpdate
}

// NewApiUpdateAuthenticationRequest creates an instance of the ApiUpdateAuthenticationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateAuthenticationRequest(
	authenticationID string,
	authenticationUpdate *AuthenticationUpdate,
) ApiUpdateAuthenticationRequest {
	return ApiUpdateAuthenticationRequest{
		authenticationID:     authenticationID,
		authenticationUpdate: authenticationUpdate,
	}
}

/*
UpdateAuthentication calls the API and returns the raw response from it.

	  Updates an authentication resource.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiUpdateAuthenticationRequest with parameters below.
	  @param authenticationID string - Unique identifier of an authentication resource.
	  @param authenticationUpdate AuthenticationUpdate
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) UpdateAuthenticationWithHTTPInfo(r ApiUpdateAuthenticationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/authentications/{authenticationID}"
	requestPath = strings.ReplaceAll(requestPath, "{authenticationID}", url.PathEscape(utils.ParameterToString(r.authenticationID)))

	if r.authenticationID == "" {
		return nil, nil, reportError("Parameter `authenticationID` is required when calling `UpdateAuthentication`.")
	}

	if r.authenticationUpdate == nil {
		return nil, nil, reportError("Parameter `authenticationUpdate` is required when calling `UpdateAuthentication`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.authenticationUpdate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
UpdateAuthentication casts the HTTP response body to a defined struct.

Updates an authentication resource.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateAuthenticationRequest with parameters below.

	@param authenticationID string - Unique identifier of an authentication resource.
	@param authenticationUpdate AuthenticationUpdate
	@return AuthenticationUpdateResponse
*/
func (c *APIClient) UpdateAuthentication(r ApiUpdateAuthenticationRequest, opts ...RequestOption) (*AuthenticationUpdateResponse, error) {
	var returnValue *AuthenticationUpdateResponse

	res, resBody, err := c.UpdateAuthenticationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateDestinationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["destinationID"]; ok {
		err = json.Unmarshal(v, &r.destinationID)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationID: %w", err)
			}
		}
	}

	if v, ok := req["destinationUpdate"]; ok {
		err = json.Unmarshal(v, &r.destinationUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.destinationUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal destinationUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.destinationUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter destinationUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateDestinationRequest represents the request with all the parameters for the API call.
type ApiUpdateDestinationRequest struct {
	destinationID     string
	destinationUpdate *DestinationUpdate
}

// NewApiUpdateDestinationRequest creates an instance of the ApiUpdateDestinationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateDestinationRequest(destinationID string, destinationUpdate *DestinationUpdate) ApiUpdateDestinationRequest {
	return ApiUpdateDestinationRequest{
		destinationID:     destinationID,
		destinationUpdate: destinationUpdate,
	}
}

/*
UpdateDestination calls the API and returns the raw response from it.

	  Updates the destination by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiUpdateDestinationRequest with parameters below.
	  @param destinationID string - Unique identifier of a destination.
	  @param destinationUpdate DestinationUpdate
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) UpdateDestinationWithHTTPInfo(r ApiUpdateDestinationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/destinations/{destinationID}"
	requestPath = strings.ReplaceAll(requestPath, "{destinationID}", url.PathEscape(utils.ParameterToString(r.destinationID)))

	if r.destinationID == "" {
		return nil, nil, reportError("Parameter `destinationID` is required when calling `UpdateDestination`.")
	}

	if r.destinationUpdate == nil {
		return nil, nil, reportError("Parameter `destinationUpdate` is required when calling `UpdateDestination`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.destinationUpdate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
UpdateDestination casts the HTTP response body to a defined struct.

Updates the destination by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateDestinationRequest with parameters below.

	@param destinationID string - Unique identifier of a destination.
	@param destinationUpdate DestinationUpdate
	@return DestinationUpdateResponse
*/
func (c *APIClient) UpdateDestination(r ApiUpdateDestinationRequest, opts ...RequestOption) (*DestinationUpdateResponse, error) {
	var returnValue *DestinationUpdateResponse

	res, resBody, err := c.UpdateDestinationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	if v, ok := req["sourceUpdate"]; ok {
		err = json.Unmarshal(v, &r.sourceUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateSourceRequest represents the request with all the parameters for the API call.
type ApiUpdateSourceRequest struct {
	sourceID     string
	sourceUpdate *SourceUpdate
}

// NewApiUpdateSourceRequest creates an instance of the ApiUpdateSourceRequest to be used for the API call.
func (c *APIClient) NewApiUpdateSourceRequest(sourceID string, sourceUpdate *SourceUpdate) ApiUpdateSourceRequest {
	return ApiUpdateSourceRequest{
		sourceID:     sourceID,
		sourceUpdate: sourceUpdate,
	}
}

/*
UpdateSource calls the API and returns the raw response from it.

	  Updates a source by its ID.

	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiUpdateSourceRequest with parameters below.
	  @param sourceID string - Unique identifier of a source.
	  @param sourceUpdate SourceUpdate
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) UpdateSourceWithHTTPInfo(r ApiUpdateSourceRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(r.sourceID)))

	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `UpdateSource`.")
	}

	if r.sourceUpdate == nil {
		return nil, nil, reportError("Parameter `sourceUpdate` is required when calling `UpdateSource`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.sourceUpdate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
UpdateSource casts the HTTP response body to a defined struct.

Updates a source by its ID.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiUpdateSourceRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param sourceUpdate SourceUpdate
	@return SourceUpdateResponse
*/
func (c *APIClient) UpdateSource(r ApiUpdateSourceRequest, opts ...RequestOption) (*SourceUpdateResponse, error) {
	var returnValue *SourceUpdateResponse

	res, resBody, err := c.UpdateSourceWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateTaskRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	if v, ok := req["taskUpdate"]; ok {
		err = json.Unmarshal(v, &r.taskUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateTaskRequest represents the request with all the parameters for the API call.
type ApiUpdateTaskRequest struct {
	taskID     string
	taskUpdate *TaskUpdate
}

// NewApiUpdateTaskRequest creates an instance of the ApiUpdateTaskRequest to be used for the API call.
func (c *APIClient) NewApiUpdateTaskRequest(taskID string, taskUpdate *TaskUpdate) ApiUpdateTaskRequest {
	return ApiUpdateTaskRequest{
		taskID:     taskID,
		taskUpdate: taskUpdate,
	}
}

/*
UpdateTask calls the API and returns the raw response from it.

	  Partially updates a task by its ID.


	Request can be constructed by NewApiUpdateTaskRequest with parameters below.
	  @param taskID string - Unique identifier of a task.
	  @param taskUpdate TaskUpdate
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) UpdateTaskWithHTTPInfo(r ApiUpdateTaskRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/2/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `UpdateTask`.")
	}

	if r.taskUpdate == nil {
		return nil, nil, reportError("Parameter `taskUpdate` is required when calling `UpdateTask`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskUpdate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
UpdateTask casts the HTTP response body to a defined struct.

Partially updates a task by its ID.

Request can be constructed by NewApiUpdateTaskRequest with parameters below.

	@param taskID string - Unique identifier of a task.
	@param taskUpdate TaskUpdate
	@return TaskUpdateResponse
*/
func (c *APIClient) UpdateTask(r ApiUpdateTaskRequest, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.UpdateTaskWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateTaskV1Request) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	if v, ok := req["taskUpdate"]; ok {
		err = json.Unmarshal(v, &r.taskUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.taskUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.taskUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter taskUpdate: %w", err)
		}
	}

	return nil
}

// ApiUpdateTaskV1Request represents the request with all the parameters for the API call.
type ApiUpdateTaskV1Request struct {
	taskID     string
	taskUpdate *TaskUpdateV1
}

// Deprecated
// NewApiUpdateTaskV1Request creates an instance of the ApiUpdateTaskV1Request to be used for the API call.
func (c *APIClient) NewApiUpdateTaskV1Request(taskID string, taskUpdate *TaskUpdateV1) ApiUpdateTaskV1Request {
	return ApiUpdateTaskV1Request{
		taskID:     taskID,
		taskUpdate: taskUpdate,
	}
}

/*
UpdateTaskV1 calls the API and returns the raw response from it.

	  Updates a task by its ID using the v1 endpoint, please use `updateTask` instead.


	Request can be constructed by NewApiUpdateTaskV1Request with parameters below.
	  @param taskID string - Unique identifier of a task.
	  @param taskUpdate TaskUpdateV1
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails

	  Deprecated
*/
func (c *APIClient) UpdateTaskV1WithHTTPInfo(r ApiUpdateTaskV1Request, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/tasks/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.taskID == "" {
		return nil, nil, reportError("Parameter `taskID` is required when calling `UpdateTaskV1`.")
	}

	if r.taskUpdate == nil {
		return nil, nil, reportError("Parameter `taskUpdate` is required when calling `UpdateTaskV1`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.taskUpdate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPatch, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
UpdateTaskV1 casts the HTTP response body to a defined struct.

Updates a task by its ID using the v1 endpoint, please use `updateTask` instead.

Request can be constructed by NewApiUpdateTaskV1Request with parameters below.

	@param taskID string - Unique identifier of a task.
	@param taskUpdate TaskUpdateV1
	@return TaskUpdateResponse

Deprecated.
*/
func (c *APIClient) UpdateTaskV1(r ApiUpdateTaskV1Request, opts ...RequestOption) (*TaskUpdateResponse, error) {
	var returnValue *TaskUpdateResponse

	res, resBody, err := c.UpdateTaskV1WithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateTransformationRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["transformationID"]; ok {
		err = json.Unmarshal(v, &r.transformationID)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationID: %w", err)
			}
		}
	}

	if v, ok := req["transformationCreate"]; ok {
		err = json.Unmarshal(v, &r.transformationCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.transformationCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal transformationCreate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.transformationCreate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter transformationCreate: %w", err)
		}
	}

	return nil
}

// ApiUpdateTransformationRequest represents the request with all the parameters for the API call.
type ApiUpdateTransformationRequest struct {
	transformationID     string
	transformationCreate *TransformationCreate
}

// NewApiUpdateTransformationRequest creates an instance of the ApiUpdateTransformationRequest to be used for the API call.
func (c *APIClient) NewApiUpdateTransformationRequest(
	transformationID string,
	transformationCreate *TransformationCreate,
) ApiUpdateTransformationRequest {
	return ApiUpdateTransformationRequest{
		transformationID:     transformationID,
		transformationCreate: transformationCreate,
	}
}

/*
UpdateTransformation calls the API and returns the raw response from it.

	  Updates a transformation by its ID.


	Request can be constructed by NewApiUpdateTransformationRequest with parameters below.
	  @param transformationID string - Unique identifier of a transformation.
	  @param transformationCreate TransformationCreate
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) UpdateTransformationWithHTTPInfo(r ApiUpdateTransformationRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/transformations/{transformationID}"
	requestPath = strings.ReplaceAll(requestPath, "{transformationID}", url.PathEscape(utils.ParameterToString(r.transformationID)))

	if r.transformationID == "" {
		return nil, nil, reportError("Parameter `transformationID` is required when calling `UpdateTransformation`.")
	}

	if r.transformationCreate == nil {
		return nil, nil, reportError("Parameter `transformationCreate` is required when calling `UpdateTransformation`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.transformationCreate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
UpdateTransformation casts the HTTP response body to a defined struct.

Updates a transformation by its ID.

Request can be constructed by NewApiUpdateTransformationRequest with parameters below.

	@param transformationID string - Unique identifier of a transformation.
	@param transformationCreate TransformationCreate
	@return TransformationUpdateResponse
*/
func (c *APIClient) UpdateTransformation(r ApiUpdateTransformationRequest, opts ...RequestOption) (*TransformationUpdateResponse, error) {
	var returnValue *TransformationUpdateResponse

	res, resBody, err := c.UpdateTransformationWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiValidateSourceRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["sourceCreate"]; ok {
		err = json.Unmarshal(v, &r.sourceCreate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceCreate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceCreate: %w", err)
			}
		}
	}

	return nil
}

// ApiValidateSourceRequest represents the request with all the parameters for the API call.
type ApiValidateSourceRequest struct {
	sourceCreate *SourceCreate
}

// NewApiValidateSourceRequest creates an instance of the ApiValidateSourceRequest to be used for the API call.
func (c *APIClient) NewApiValidateSourceRequest() ApiValidateSourceRequest {
	return ApiValidateSourceRequest{}
}

// WithSourceCreate adds the sourceCreate to the ApiValidateSourceRequest and returns the request for chaining.
func (r ApiValidateSourceRequest) WithSourceCreate(sourceCreate *SourceCreate) ApiValidateSourceRequest {
	r.sourceCreate = sourceCreate

	return r
}

/*
ValidateSource calls the API and returns the raw response from it.

	  Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.


	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiValidateSourceRequest with parameters below.
	  @param sourceCreate SourceCreate -
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ValidateSourceWithHTTPInfo(r ApiValidateSourceRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/sources/validate"

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
		timeouts: transport.RequestConfiguration{
			ReadTimeout:    utils.ToPtr(180000 * time.Millisecond),
			WriteTimeout:   utils.ToPtr(180000 * time.Millisecond),
			ConnectTimeout: utils.ToPtr(180000 * time.Millisecond),
		},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.sourceCreate) {
		postBody = "{}"
	} else {
		postBody = r.sourceCreate
	}

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
ValidateSource casts the HTTP response body to a defined struct.

Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiValidateSourceRequest with parameters below.

	@param sourceCreate SourceCreate -
	@return WatchResponse
*/
func (c *APIClient) ValidateSource(r ApiValidateSourceRequest, opts ...RequestOption) (*WatchResponse, error) {
	var returnValue *WatchResponse

	res, resBody, err := c.ValidateSourceWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiValidateSourceBeforeUpdateRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["sourceID"]; ok {
		err = json.Unmarshal(v, &r.sourceID)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceID: %w", err)
			}
		}
	}

	if v, ok := req["sourceUpdate"]; ok {
		err = json.Unmarshal(v, &r.sourceUpdate)
		if err != nil {
			err = json.Unmarshal(b, &r.sourceUpdate)
			if err != nil {
				return fmt.Errorf("cannot unmarshal sourceUpdate: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.sourceUpdate)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter sourceUpdate: %w", err)
		}
	}

	return nil
}

// ApiValidateSourceBeforeUpdateRequest represents the request with all the parameters for the API call.
type ApiValidateSourceBeforeUpdateRequest struct {
	sourceID     string
	sourceUpdate *SourceUpdate
}

// NewApiValidateSourceBeforeUpdateRequest creates an instance of the ApiValidateSourceBeforeUpdateRequest to be used for the API call.
func (c *APIClient) NewApiValidateSourceBeforeUpdateRequest(sourceID string, sourceUpdate *SourceUpdate) ApiValidateSourceBeforeUpdateRequest {
	return ApiValidateSourceBeforeUpdateRequest{
		sourceID:     sourceID,
		sourceUpdate: sourceUpdate,
	}
}

/*
ValidateSourceBeforeUpdate calls the API and returns the raw response from it.

	  Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.


	    Required API Key ACLs:
	    - addObject
	    - deleteIndex
	    - editSettings

	Request can be constructed by NewApiValidateSourceBeforeUpdateRequest with parameters below.
	  @param sourceID string - Unique identifier of a source.
	  @param sourceUpdate SourceUpdate
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) ValidateSourceBeforeUpdateWithHTTPInfo(
	r ApiValidateSourceBeforeUpdateRequest,
	opts ...RequestOption,
) (*http.Response, []byte, error) {
	requestPath := "/1/sources/{sourceID}/validate"
	requestPath = strings.ReplaceAll(requestPath, "{sourceID}", url.PathEscape(utils.ParameterToString(r.sourceID)))

	if r.sourceID == "" {
		return nil, nil, reportError("Parameter `sourceID` is required when calling `ValidateSourceBeforeUpdate`.")
	}

	if r.sourceUpdate == nil {
		return nil, nil, reportError("Parameter `sourceUpdate` is required when calling `ValidateSourceBeforeUpdate`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
		timeouts: transport.RequestConfiguration{
			ReadTimeout:    utils.ToPtr(180000 * time.Millisecond),
			WriteTimeout:   utils.ToPtr(180000 * time.Millisecond),
			ConnectTimeout: utils.ToPtr(180000 * time.Millisecond),
		},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.sourceUpdate

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
ValidateSourceBeforeUpdate casts the HTTP response body to a defined struct.

Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.

Required API Key ACLs:
  - addObject
  - deleteIndex
  - editSettings

Request can be constructed by NewApiValidateSourceBeforeUpdateRequest with parameters below.

	@param sourceID string - Unique identifier of a source.
	@param sourceUpdate SourceUpdate
	@return WatchResponse
*/
func (c *APIClient) ValidateSourceBeforeUpdate(r ApiValidateSourceBeforeUpdateRequest, opts ...RequestOption) (*WatchResponse, error) {
	var returnValue *WatchResponse

	res, resBody, err := c.ValidateSourceBeforeUpdateWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

// --------- ChunkedBatch options ---------

type ChunkedBatchOption interface {
	RequestOption
	chunkedBatch()
}

type chunkedBatchOption func(*config)

var (
	_ ChunkedBatchOption = (*chunkedBatchOption)(nil)
	_ ChunkedBatchOption = (*requestOption)(nil)
)

func (c chunkedBatchOption) apply(conf *config) {
	c(conf)
}

func (c chunkedBatchOption) chunkedBatch() {}

func (r requestOption) chunkedBatch() {}

// WithWaitForTasks whether or not we should wait until every `batch` tasks has been processed, this operation may slow the total execution time of this method but is more reliable.
func WithWaitForTasks(waitForTasks bool) chunkedBatchOption {
	return chunkedBatchOption(func(c *config) {
		c.waitForTasks = waitForTasks
	})
}

// WithBatchSize the size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.
func WithBatchSize(batchSize int) chunkedBatchOption {
	return chunkedBatchOption(func(c *config) {
		c.batchSize = batchSize
	})
}

// --------- Iterable options ---------.

type IterableOption interface {
	RequestOption
	iterable()
}

type iterableOption func(*config)

var (
	_ IterableOption = (*iterableOption)(nil)
	_ IterableOption = (*requestOption)(nil)
)

func (i iterableOption) apply(c *config) {
	i(c)
}

func (r requestOption) iterable() {}

func (i iterableOption) iterable() {}

// WithMaxRetries the maximum number of retry. Default to 50.
func WithMaxRetries(maxRetries int) iterableOption {
	return iterableOption(func(c *config) {
		c.maxRetries = maxRetries
	})
}

// WithTimeout he function to decide how long to wait between retries. Default to min(retryCount * 200, 5000).
func WithTimeout(timeout func(int) time.Duration) iterableOption {
	return iterableOption(func(c *config) {
		c.timeout = timeout
	})
}

// WithAggregator the function to aggregate the results of the iterable.
func WithAggregator(aggregator func(any, error)) iterableOption {
	return iterableOption(func(c *config) {
		c.aggregator = aggregator
	})
}

func CreateIterable[T any](execute func(*T, error) (*T, error), validate func(*T, error) (bool, error), opts ...IterableOption) (*T, error) {
	conf := config{
		headerParams: map[string]string{},
		maxRetries:   -1,
		timeout: func(count int) time.Duration {
			return 0 * time.Millisecond
		},
	}

	for _, opt := range opts {
		opt.apply(&conf)
	}

	var executor func(*T, error) (*T, error)

	retryCount := 0

	executor = func(previousResponse *T, previousError error) (*T, error) {
		response, responseErr := execute(previousResponse, previousError)

		retryCount++

		if conf.aggregator != nil {
			conf.aggregator(response, responseErr)
		}

		canStop, err := validate(response, responseErr)
		if canStop || err != nil {
			return response, err
		}

		if conf.maxRetries >= 0 && retryCount >= conf.maxRetries {
			return nil, errs.NewWaitError(fmt.Sprintf("The maximum number of retries exceeded. (%d/%d)", retryCount, conf.maxRetries))
		}

		time.Sleep(conf.timeout(retryCount))

		return executor(response, responseErr)
	}

	return executor(nil, nil)
}

/*
ChunkedPush Chunks the given `objects` list in subset of 1000 elements max in order to make it fit in `push` requests by leveraging the Transformation pipeline setup in the Push connector (https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/connectors/push/).

	@param indexName string - the index name to save objects into.
	@param objects []map[string]any - List of objects to save.
	@param action Action - The action to perform on the objects.


	@param referenceIndexName *string - This is required when targeting an index that does not have a push connector setup (e.g. a tmp index), but you wish to attach another index's transformation to it (e.g. the source index name).
	@param opts ...ChunkedBatchOption - Optional parameters for the request.
	@return []WatchResponse - List of push responses.
	@return error - Error if any.
*/
func (c *APIClient) ChunkedPush(
	indexName string,
	objects []map[string]any,
	action Action,
	referenceIndexName *string,
	opts ...ChunkedBatchOption,
) ([]WatchResponse, error) {
	conf := config{
		headerParams: map[string]string{},
		waitForTasks: false,
		batchSize:    1000,
	}

	offset := 0

	waitBatchSize := conf.batchSize / 10
	if waitBatchSize < 1 {
		waitBatchSize = conf.batchSize
	}

	for _, opt := range opts {
		opt.apply(&conf)
	}

	records := make([]map[string]any, 0, len(objects)%conf.batchSize)
	responses := make([]WatchResponse, 0, len(objects)%conf.batchSize)

	for i, obj := range objects {
		records = append(records, obj)

		if len(records) == conf.batchSize || i == len(objects)-1 {
			pushRecords := make([]PushTaskRecords, 0, len(records))

			rawRecords, err := json.Marshal(records)
			if err != nil {
				return nil, reportError("unable to marshal the given `objects`: %w", err)
			}

			err = json.Unmarshal(rawRecords, &pushRecords)
			if err != nil {
				return nil, reportError("unable to unmarshal the given `objects` to an `[]PushTaskRecords` payload: %w", err)
			}

			request := c.NewApiPushRequest(
				indexName,
				NewEmptyPushTaskPayload().
					SetAction(action).
					SetRecords(pushRecords),
			)

			if referenceIndexName != nil {
				request = request.WithReferenceIndexName(*referenceIndexName)
			}

			resp, err := c.Push(request)
			if err != nil {
				return nil, err
			}

			responses = append(responses, *resp)
			records = make([]map[string]any, 0, len(objects)%conf.batchSize)
		}

		if conf.waitForTasks && len(responses) > 0 && (len(responses)%waitBatchSize == 0 || i == len(objects)-1) {
			var waitableResponses []WatchResponse

			if len(responses) > offset+waitBatchSize {
				waitableResponses = responses[offset:waitBatchSize]
			} else {
				waitableResponses = responses[offset:]
			}

			for _, resp := range waitableResponses {
				_, err := CreateIterable(
					func(*Event, error) (*Event, error) {
						if resp.EventID == nil {
							return nil, reportError("received unexpected response from the push endpoint, eventID must not be undefined")
						}

						return c.GetEvent(c.NewApiGetEventRequest(resp.RunID, *resp.EventID))
					},
					func(response *Event, err error) (bool, error) {
						var apiErr *APIError
						if errors.As(err, &apiErr) {
							return apiErr.Status != 404, nil
						}

						return true, err
					},
					WithTimeout(func(count int) time.Duration { return time.Duration(min(500*count, 5000)) * time.Millisecond }), WithMaxRetries(50),
				)
				if err != nil {
					return nil, err
				}
			}

			offset += waitBatchSize
		}
	}

	return responses, nil
}
