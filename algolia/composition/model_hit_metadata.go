// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package composition

import (
	"encoding/json"
	"fmt"
)

// HitMetadata An object that contains the extra key-value pairs provided in the injectedItem definition.
type HitMetadata struct {
	// The key of the injectedItem that inserted this metadata.
	InjectedItemKey      *string        `json:"_injectedItemKey,omitempty"`
	AdditionalProperties map[string]any `json:"-"`
}

type _HitMetadata HitMetadata

type HitMetadataOption func(f *HitMetadata)

func WithHitMetadataInjectedItemKey(val string) HitMetadataOption {
	return func(f *HitMetadata) {
		f.InjectedItemKey = &val
	}
}

// NewHitMetadata instantiates a new HitMetadata object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed.
func NewHitMetadata(opts ...HitMetadataOption) *HitMetadata {
	this := &HitMetadata{}
	for _, opt := range opts {
		opt(this)
	}

	return this
}

// NewEmptyHitMetadata return a pointer to an empty HitMetadata object.
func NewEmptyHitMetadata() *HitMetadata {
	return &HitMetadata{}
}

// GetInjectedItemKey returns the InjectedItemKey field value if set, zero value otherwise.
func (o *HitMetadata) GetInjectedItemKey() string {
	if o == nil || o.InjectedItemKey == nil {
		var ret string

		return ret
	}

	return *o.InjectedItemKey
}

// GetInjectedItemKeyOk returns a tuple with the InjectedItemKey field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *HitMetadata) GetInjectedItemKeyOk() (*string, bool) {
	if o == nil || o.InjectedItemKey == nil {
		return nil, false
	}

	return o.InjectedItemKey, true
}

// HasInjectedItemKey returns a boolean if a field has been set.
func (o *HitMetadata) HasInjectedItemKey() bool {
	if o != nil && o.InjectedItemKey != nil {
		return true
	}

	return false
}

// SetInjectedItemKey gets a reference to the given string and assigns it to the InjectedItemKey field.
func (o *HitMetadata) SetInjectedItemKey(v string) *HitMetadata {
	o.InjectedItemKey = &v

	return o
}

func (o *HitMetadata) SetAdditionalProperty(key string, value any) *HitMetadata {
	if o.AdditionalProperties == nil {
		o.AdditionalProperties = make(map[string]any)
	}

	o.AdditionalProperties[key] = value

	return o
}

func (o HitMetadata) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]any{}
	if o.InjectedItemKey != nil {
		toSerialize["_injectedItemKey"] = o.InjectedItemKey
	}

	for key, value := range o.AdditionalProperties {
		toSerialize[key] = value
	}

	serialized, err := json.Marshal(toSerialize)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal HitMetadata: %w", err)
	}

	return serialized, nil
}

func (o *HitMetadata) UnmarshalJSON(bytes []byte) error {
	varHitMetadata := _HitMetadata{}

	err := json.Unmarshal(bytes, &varHitMetadata)
	if err != nil {
		return fmt.Errorf("failed to unmarshal HitMetadata: %w", err)
	}

	*o = HitMetadata(varHitMetadata)

	additionalProperties := make(map[string]any)

	err = json.Unmarshal(bytes, &additionalProperties)
	if err != nil {
		return fmt.Errorf("failed to unmarshal additionalProperties in HitMetadata: %w", err)
	}

	delete(additionalProperties, "_injectedItemKey")
	o.AdditionalProperties = additionalProperties

	return nil
}

func (o HitMetadata) String() string {
	out := ""

	out += fmt.Sprintf("  _injectedItemKey=%v\n", o.InjectedItemKey)
	for key, value := range o.AdditionalProperties {
		out += fmt.Sprintf("  %s=%v\n", key, value)
	}

	return fmt.Sprintf("HitMetadata {\n%s}", out)
}
