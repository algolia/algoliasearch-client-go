// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package composition

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/transport"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type config struct {
	// -- Request options for API calls
	context      context.Context
	queryParams  url.Values
	headerParams map[string]string
	timeouts     transport.RequestConfiguration
}

type RequestOption interface {
	apply(*config)
}

type requestOption func(*config)

func (r requestOption) apply(c *config) {
	r(c)
}

func WithContext(ctx context.Context) requestOption {
	return requestOption(func(c *config) {
		c.context = ctx
	})
}

func WithHeaderParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.headerParams[key] = utils.ParameterToString(value)
	})
}

func WithQueryParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.queryParams.Set(utils.QueryParameterToString(key), utils.QueryParameterToString(value))
	})
}

func WithReadTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ReadTimeout = &timeout
	})
}

func WithWriteTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.WriteTimeout = &timeout
	})
}

func WithConnectTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ConnectTimeout = &timeout
	})
}

func (r *ApiSearchRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["compositionID"]; ok {
		err = json.Unmarshal(v, &r.compositionID)
		if err != nil {
			err = json.Unmarshal(b, &r.compositionID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal compositionID: %w", err)
			}
		}
	}
	if v, ok := req["requestBody"]; ok {
		err = json.Unmarshal(v, &r.requestBody)
		if err != nil {
			err = json.Unmarshal(b, &r.requestBody)
			if err != nil {
				return fmt.Errorf("cannot unmarshal requestBody: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.requestBody)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter requestBody: %w", err)
		}
	}

	return nil
}

// ApiSearchRequest represents the request with all the parameters for the API call.
type ApiSearchRequest struct {
	compositionID string
	requestBody   *RequestBody
}

// NewApiSearchRequest creates an instance of the ApiSearchRequest to be used for the API call.
func (c *APIClient) NewApiSearchRequest(compositionID string, requestBody *RequestBody) ApiSearchRequest {
	return ApiSearchRequest{
		compositionID: compositionID,
		requestBody:   requestBody,
	}
}

/*
Search calls the API and returns the raw response from it.

	  Runs a query on a single composition and returns matching results.

	    Required API Key ACLs:
	    - search

	Request can be constructed by NewApiSearchRequest with parameters below.
	  @param compositionID string - Unique Composition ObjectID.
	  @param requestBody RequestBody
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchWithHTTPInfo(r ApiSearchRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}/run"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(r.compositionID)))

	if r.compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `Search`.")
	}

	if r.requestBody == nil {
		return nil, nil, reportError("Parameter `requestBody` is required when calling `Search`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.requestBody
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

/*
Search casts the HTTP response body to a defined struct.

Runs a query on a single composition and returns matching results.

Required API Key ACLs:
  - search

Request can be constructed by NewApiSearchRequest with parameters below.

	@param compositionID string - Unique Composition ObjectID.
	@param requestBody RequestBody
	@return SearchResponse
*/
func (c *APIClient) Search(r ApiSearchRequest, opts ...RequestOption) (*SearchResponse, error) {
	var returnValue *SearchResponse

	res, resBody, err := c.SearchWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchForFacetValuesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["compositionID"]; ok {
		err = json.Unmarshal(v, &r.compositionID)
		if err != nil {
			err = json.Unmarshal(b, &r.compositionID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal compositionID: %w", err)
			}
		}
	}
	if v, ok := req["facetName"]; ok {
		err = json.Unmarshal(v, &r.facetName)
		if err != nil {
			err = json.Unmarshal(b, &r.facetName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal facetName: %w", err)
			}
		}
	}
	if v, ok := req["searchForFacetValuesRequest"]; ok {
		err = json.Unmarshal(v, &r.searchForFacetValuesRequest)
		if err != nil {
			err = json.Unmarshal(b, &r.searchForFacetValuesRequest)
			if err != nil {
				return fmt.Errorf("cannot unmarshal searchForFacetValuesRequest: %w", err)
			}
		}
	}

	return nil
}

// ApiSearchForFacetValuesRequest represents the request with all the parameters for the API call.
type ApiSearchForFacetValuesRequest struct {
	compositionID               string
	facetName                   string
	searchForFacetValuesRequest *SearchForFacetValuesRequest
}

// NewApiSearchForFacetValuesRequest creates an instance of the ApiSearchForFacetValuesRequest to be used for the API call.
func (c *APIClient) NewApiSearchForFacetValuesRequest(compositionID string, facetName string) ApiSearchForFacetValuesRequest {
	return ApiSearchForFacetValuesRequest{
		compositionID: compositionID,
		facetName:     facetName,
	}
}

// WithSearchForFacetValuesRequest adds the searchForFacetValuesRequest to the ApiSearchForFacetValuesRequest and returns the request for chaining.
func (r ApiSearchForFacetValuesRequest) WithSearchForFacetValuesRequest(searchForFacetValuesRequest *SearchForFacetValuesRequest) ApiSearchForFacetValuesRequest {
	r.searchForFacetValuesRequest = searchForFacetValuesRequest
	return r
}

/*
SearchForFacetValues calls the API and returns the raw response from it.

		Searches for values of a specified facet attribute on the composition's main source's index.

	  - By default, facet values are sorted by decreasing count.
	    You can adjust this with the `sortFacetValueBy` parameter.

	  - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.

	    Required API Key ACLs:

	  - search

	    Request can be constructed by NewApiSearchForFacetValuesRequest with parameters below.
	    @param compositionID string - Unique Composition ObjectID.
	    @param facetName string - Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.
	    @param searchForFacetValuesRequest SearchForFacetValuesRequest
	    @param opts ...RequestOption - Optional parameters for the API call
	    @return *http.Response - The raw response from the API
	    @return []byte - The raw response body from the API
	    @return error - An error if the API call fails
*/
func (c *APIClient) SearchForFacetValuesWithHTTPInfo(r ApiSearchForFacetValuesRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/compositions/{compositionID}/facets/{facetName}/query"
	requestPath = strings.ReplaceAll(requestPath, "{compositionID}", url.PathEscape(utils.ParameterToString(r.compositionID)))
	requestPath = strings.ReplaceAll(requestPath, "{facetName}", url.PathEscape(utils.ParameterToString(r.facetName)))

	if r.compositionID == "" {
		return nil, nil, reportError("Parameter `compositionID` is required when calling `SearchForFacetValues`.")
	}
	if r.facetName == "" {
		return nil, nil, reportError("Parameter `facetName` is required when calling `SearchForFacetValues`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.searchForFacetValuesRequest) {
		postBody = "{}"
	} else {
		postBody = r.searchForFacetValuesRequest
	}
	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

/*
SearchForFacetValues casts the HTTP response body to a defined struct.

Searches for values of a specified facet attribute on the composition's main source's index.

  - By default, facet values are sorted by decreasing count.
    You can adjust this with the `sortFacetValueBy` parameter.
  - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.

Required API Key ACLs:
  - search

Request can be constructed by NewApiSearchForFacetValuesRequest with parameters below.

	@param compositionID string - Unique Composition ObjectID.
	@param facetName string - Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.
	@param searchForFacetValuesRequest SearchForFacetValuesRequest
	@return SearchForFacetValuesResponse
*/
func (c *APIClient) SearchForFacetValues(r ApiSearchForFacetValuesRequest, opts ...RequestOption) (*SearchForFacetValuesResponse, error) {
	var returnValue *SearchForFacetValuesResponse

	res, resBody, err := c.SearchForFacetValuesWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
