// File generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation.
package recommend

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       name,
		value:      parameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

func (r *ApiCustomDeleteRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiCustomDeleteRequest represents the request with all the parameters for the API call.
type ApiCustomDeleteRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiCustomDeleteRequest creates an instance of the ApiCustomDeleteRequest to be used for the API call.
func (c *APIClient) NewApiCustomDeleteRequest(path string) ApiCustomDeleteRequest {
	return ApiCustomDeleteRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomDeleteRequest and returns the request for chaining.
func (r ApiCustomDeleteRequest) WithParameters(parameters map[string]interface{}) ApiCustomDeleteRequest {
	r.parameters = parameters
	return r
}

/*
CustomDelete Send requests to the Algolia REST API. Wraps CustomDeleteWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomDelete(r ApiCustomDeleteRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomDeleteWithContext(context.Background(), r, opts...)
}

/*
CustomDelete Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomDeleteWithContext(ctx context.Context, r ApiCustomDeleteRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", url.PathEscape(parameterToString(r.path)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiCustomGetRequest represents the request with all the parameters for the API call.
type ApiCustomGetRequest struct {
	path       string
	parameters map[string]interface{}
}

// NewApiCustomGetRequest creates an instance of the ApiCustomGetRequest to be used for the API call.
func (c *APIClient) NewApiCustomGetRequest(path string) ApiCustomGetRequest {
	return ApiCustomGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomGetRequest and returns the request for chaining.
func (r ApiCustomGetRequest) WithParameters(parameters map[string]interface{}) ApiCustomGetRequest {
	r.parameters = parameters
	return r
}

/*
CustomGet Send requests to the Algolia REST API. Wraps CustomGetWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomGet(r ApiCustomGetRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomGetWithContext(context.Background(), r, opts...)
}

/*
CustomGet Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@return map[string]interface{}
*/
func (c *APIClient) CustomGetWithContext(ctx context.Context, r ApiCustomGetRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", url.PathEscape(parameterToString(r.path)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiCustomPostRequest represents the request with all the parameters for the API call.
type ApiCustomPostRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiCustomPostRequest creates an instance of the ApiCustomPostRequest to be used for the API call.
func (c *APIClient) NewApiCustomPostRequest(path string) ApiCustomPostRequest {
	return ApiCustomPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithParameters(parameters map[string]interface{}) ApiCustomPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithBody(body map[string]interface{}) ApiCustomPostRequest {
	r.body = body
	return r
}

/*
CustomPost Send requests to the Algolia REST API. Wraps CustomPostWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPost(r ApiCustomPostRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomPostWithContext(context.Background(), r, opts...)
}

/*
CustomPost Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPostWithContext(ctx context.Context, r ApiCustomPostRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", url.PathEscape(parameterToString(r.path)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiCustomPutRequest represents the request with all the parameters for the API call.
type ApiCustomPutRequest struct {
	path       string
	parameters map[string]interface{}
	body       map[string]interface{}
}

// NewApiCustomPutRequest creates an instance of the ApiCustomPutRequest to be used for the API call.
func (c *APIClient) NewApiCustomPutRequest(path string) ApiCustomPutRequest {
	return ApiCustomPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithParameters(parameters map[string]interface{}) ApiCustomPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithBody(body map[string]interface{}) ApiCustomPutRequest {
	r.body = body
	return r
}

/*
CustomPut Send requests to the Algolia REST API. Wraps CustomPutWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPut(r ApiCustomPutRequest, opts ...Option) (map[string]interface{}, error) {
	return c.CustomPutWithContext(context.Background(), r, opts...)
}

/*
CustomPut Send requests to the Algolia REST API.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]interface{} - Query parameters to apply to the current query.
	@param body map[string]interface{} - Parameters to send with the custom request.
	@return map[string]interface{}
*/
func (c *APIClient) CustomPutWithContext(ctx context.Context, r ApiCustomPutRequest, opts ...Option) (map[string]interface{}, error) {
	var (
		postBody    any
		returnValue map[string]interface{}
	)

	requestPath := "/1{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", url.PathEscape(parameterToString(r.path)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return returnValue, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, parameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteRecommendRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["model"]; ok {
		err = json.Unmarshal(v, &r.model)
		if err != nil {
			err = json.Unmarshal(b, &r.model)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiDeleteRecommendRuleRequest represents the request with all the parameters for the API call.
type ApiDeleteRecommendRuleRequest struct {
	indexName string
	model     RecommendModels
	objectID  string
}

// NewApiDeleteRecommendRuleRequest creates an instance of the ApiDeleteRecommendRuleRequest to be used for the API call.
func (c *APIClient) NewApiDeleteRecommendRuleRequest(indexName string, model RecommendModels, objectID string) ApiDeleteRecommendRuleRequest {
	return ApiDeleteRecommendRuleRequest{
		indexName: indexName,
		model:     model,
		objectID:  objectID,
	}
}

/*
DeleteRecommendRule Delete a Recommend rule. Wraps DeleteRecommendRuleWithContext using context.Background.

Delete a [Recommend rule](https://www.algolia.com/doc/guides/algolia-recommend/how-to/rules/).

Request can be constructed by NewApiDeleteRecommendRuleRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param model RecommendModels - [Recommend models](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param objectID string - Unique record (object) identifier.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteRecommendRule(r ApiDeleteRecommendRuleRequest, opts ...Option) (*DeletedAtResponse, error) {
	return c.DeleteRecommendRuleWithContext(context.Background(), r, opts...)
}

/*
DeleteRecommendRule Delete a Recommend rule.

Delete a [Recommend rule](https://www.algolia.com/doc/guides/algolia-recommend/how-to/rules/).

Request can be constructed by NewApiDeleteRecommendRuleRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param model RecommendModels - [Recommend models](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param objectID string - Unique record (object) identifier.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteRecommendRuleWithContext(ctx context.Context, r ApiDeleteRecommendRuleRequest, opts ...Option) (*DeletedAtResponse, error) {
	var (
		postBody    any
		returnValue *DeletedAtResponse
	)

	requestPath := "/1/indexes/{indexName}/{model}/recommend/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(parameterToString(r.model)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(parameterToString(r.objectID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return returnValue, reportError("Parameter `indexName` is required when calling `DeleteRecommendRule`.")
	}

	if r.objectID == "" {
		return returnValue, reportError("Parameter `objectID` is required when calling `DeleteRecommendRule`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRecommendRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["model"]; ok {
		err = json.Unmarshal(v, &r.model)
		if err != nil {
			err = json.Unmarshal(b, &r.model)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetRecommendRuleRequest represents the request with all the parameters for the API call.
type ApiGetRecommendRuleRequest struct {
	indexName string
	model     RecommendModels
	objectID  string
}

// NewApiGetRecommendRuleRequest creates an instance of the ApiGetRecommendRuleRequest to be used for the API call.
func (c *APIClient) NewApiGetRecommendRuleRequest(indexName string, model RecommendModels, objectID string) ApiGetRecommendRuleRequest {
	return ApiGetRecommendRuleRequest{
		indexName: indexName,
		model:     model,
		objectID:  objectID,
	}
}

/*
GetRecommendRule Get a Recommend rule. Wraps GetRecommendRuleWithContext using context.Background.

Return a [Recommend rule](https://www.algolia.com/doc/guides/algolia-recommend/how-to/rules/).

Request can be constructed by NewApiGetRecommendRuleRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param model RecommendModels - [Recommend models](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param objectID string - Unique record (object) identifier.
	@return RuleResponse
*/
func (c *APIClient) GetRecommendRule(r ApiGetRecommendRuleRequest, opts ...Option) (*RuleResponse, error) {
	return c.GetRecommendRuleWithContext(context.Background(), r, opts...)
}

/*
GetRecommendRule Get a Recommend rule.

Return a [Recommend rule](https://www.algolia.com/doc/guides/algolia-recommend/how-to/rules/).

Request can be constructed by NewApiGetRecommendRuleRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param model RecommendModels - [Recommend models](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param objectID string - Unique record (object) identifier.
	@return RuleResponse
*/
func (c *APIClient) GetRecommendRuleWithContext(ctx context.Context, r ApiGetRecommendRuleRequest, opts ...Option) (*RuleResponse, error) {
	var (
		postBody    any
		returnValue *RuleResponse
	)

	requestPath := "/1/indexes/{indexName}/{model}/recommend/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(parameterToString(r.model)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(parameterToString(r.objectID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return returnValue, reportError("Parameter `indexName` is required when calling `GetRecommendRule`.")
	}

	if r.objectID == "" {
		return returnValue, reportError("Parameter `objectID` is required when calling `GetRecommendRule`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRecommendStatusRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["model"]; ok {
		err = json.Unmarshal(v, &r.model)
		if err != nil {
			err = json.Unmarshal(b, &r.model)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiGetRecommendStatusRequest represents the request with all the parameters for the API call.
type ApiGetRecommendStatusRequest struct {
	indexName string
	model     RecommendModels
	taskID    int64
}

// NewApiGetRecommendStatusRequest creates an instance of the ApiGetRecommendStatusRequest to be used for the API call.
func (c *APIClient) NewApiGetRecommendStatusRequest(indexName string, model RecommendModels, taskID int64) ApiGetRecommendStatusRequest {
	return ApiGetRecommendStatusRequest{
		indexName: indexName,
		model:     model,
		taskID:    taskID,
	}
}

/*
GetRecommendStatus Get a Recommend task's status. Wraps GetRecommendStatusWithContext using context.Background.

Some operations, such as deleting a Recommend rule, will respond with a `taskID` value. Use this value here to check the status of that task.

Request can be constructed by NewApiGetRecommendStatusRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param model RecommendModels - [Recommend models](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param taskID int64 - Unique identifier of a task. Numeric value (up to 64bits).
	@return GetRecommendTaskResponse
*/
func (c *APIClient) GetRecommendStatus(r ApiGetRecommendStatusRequest, opts ...Option) (*GetRecommendTaskResponse, error) {
	return c.GetRecommendStatusWithContext(context.Background(), r, opts...)
}

/*
GetRecommendStatus Get a Recommend task's status.

Some operations, such as deleting a Recommend rule, will respond with a `taskID` value. Use this value here to check the status of that task.

Request can be constructed by NewApiGetRecommendStatusRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param model RecommendModels - [Recommend models](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param taskID int64 - Unique identifier of a task. Numeric value (up to 64bits).
	@return GetRecommendTaskResponse
*/
func (c *APIClient) GetRecommendStatusWithContext(ctx context.Context, r ApiGetRecommendStatusRequest, opts ...Option) (*GetRecommendTaskResponse, error) {
	var (
		postBody    any
		returnValue *GetRecommendTaskResponse
	)

	requestPath := "/1/indexes/{indexName}/{model}/task/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(parameterToString(r.model)))
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(parameterToString(r.taskID)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return returnValue, reportError("Parameter `indexName` is required when calling `GetRecommendStatus`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, false)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRecommendationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["getRecommendationsParams"]; ok {
		err = json.Unmarshal(v, &r.getRecommendationsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.getRecommendationsParams)
			if err != nil {
				return err
			}
		}
	} else {
		err = json.Unmarshal(b, &r.getRecommendationsParams)
		if err != nil {
			return err
		}
	}

	return nil
}

// ApiGetRecommendationsRequest represents the request with all the parameters for the API call.
type ApiGetRecommendationsRequest struct {
	getRecommendationsParams *GetRecommendationsParams
}

// NewApiGetRecommendationsRequest creates an instance of the ApiGetRecommendationsRequest to be used for the API call.
func (c *APIClient) NewApiGetRecommendationsRequest(getRecommendationsParams *GetRecommendationsParams) ApiGetRecommendationsRequest {
	return ApiGetRecommendationsRequest{
		getRecommendationsParams: getRecommendationsParams,
	}
}

/*
GetRecommendations Get recommendations and trending items. Wraps GetRecommendationsWithContext using context.Background.

Returns results from either recommendation or trending models:

  - **Recommendations** are provided by the [Related Products](https://www.algolia.com/doc/guides/algolia-recommend/overview/#related-products-and-related-content) and [Frequently Bought Together](https://www.algolia.com/doc/guides/algolia-recommend/overview/#frequently-bought-together) models
  - **Trending** models are [Trending Items and Trending Facet Values](https://www.algolia.com/doc/guides/algolia-recommend/overview/#trending-items-and-trending-facet-values).

Request can be constructed by NewApiGetRecommendationsRequest with parameters below.

	@param getRecommendationsParams GetRecommendationsParams
	@return GetRecommendationsResponse
*/
func (c *APIClient) GetRecommendations(r ApiGetRecommendationsRequest, opts ...Option) (*GetRecommendationsResponse, error) {
	return c.GetRecommendationsWithContext(context.Background(), r, opts...)
}

/*
GetRecommendations Get recommendations and trending items.

Returns results from either recommendation or trending models:

  - **Recommendations** are provided by the [Related Products](https://www.algolia.com/doc/guides/algolia-recommend/overview/#related-products-and-related-content) and [Frequently Bought Together](https://www.algolia.com/doc/guides/algolia-recommend/overview/#frequently-bought-together) models
  - **Trending** models are [Trending Items and Trending Facet Values](https://www.algolia.com/doc/guides/algolia-recommend/overview/#trending-items-and-trending-facet-values).

Request can be constructed by NewApiGetRecommendationsRequest with parameters below.

	@param getRecommendationsParams GetRecommendationsParams
	@return GetRecommendationsResponse
*/
func (c *APIClient) GetRecommendationsWithContext(ctx context.Context, r ApiGetRecommendationsRequest, opts ...Option) (*GetRecommendationsResponse, error) {
	var (
		postBody    any
		returnValue *GetRecommendationsResponse
	)

	requestPath := "/1/indexes/*/recommendations"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.getRecommendationsParams == nil {
		return returnValue, reportError("Parameter `getRecommendationsParams` is required when calling `GetRecommendations`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.getRecommendationsParams
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, true)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchRecommendRulesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return err
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["model"]; ok {
		err = json.Unmarshal(v, &r.model)
		if err != nil {
			err = json.Unmarshal(b, &r.model)
			if err != nil {
				return err
			}
		}
	}
	if v, ok := req["searchRecommendRulesParams"]; ok {
		err = json.Unmarshal(v, &r.searchRecommendRulesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchRecommendRulesParams)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// ApiSearchRecommendRulesRequest represents the request with all the parameters for the API call.
type ApiSearchRecommendRulesRequest struct {
	indexName                  string
	model                      RecommendModels
	searchRecommendRulesParams *SearchRecommendRulesParams
}

// NewApiSearchRecommendRulesRequest creates an instance of the ApiSearchRecommendRulesRequest to be used for the API call.
func (c *APIClient) NewApiSearchRecommendRulesRequest(indexName string, model RecommendModels) ApiSearchRecommendRulesRequest {
	return ApiSearchRecommendRulesRequest{
		indexName: indexName,
		model:     model,
	}
}

// WithSearchRecommendRulesParams adds the searchRecommendRulesParams to the ApiSearchRecommendRulesRequest and returns the request for chaining.
func (r ApiSearchRecommendRulesRequest) WithSearchRecommendRulesParams(searchRecommendRulesParams *SearchRecommendRulesParams) ApiSearchRecommendRulesRequest {
	r.searchRecommendRulesParams = searchRecommendRulesParams
	return r
}

/*
SearchRecommendRules List Recommend rules. Wraps SearchRecommendRulesWithContext using context.Background.

List [Recommend rules](https://www.algolia.com/doc/guides/algolia-recommend/how-to/rules/).

Request can be constructed by NewApiSearchRecommendRulesRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param model RecommendModels - [Recommend models](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param searchRecommendRulesParams SearchRecommendRulesParams
	@return SearchRecommendRulesResponse
*/
func (c *APIClient) SearchRecommendRules(r ApiSearchRecommendRulesRequest, opts ...Option) (*SearchRecommendRulesResponse, error) {
	return c.SearchRecommendRulesWithContext(context.Background(), r, opts...)
}

/*
SearchRecommendRules List Recommend rules.

List [Recommend rules](https://www.algolia.com/doc/guides/algolia-recommend/how-to/rules/).

Request can be constructed by NewApiSearchRecommendRulesRequest with parameters below.

	@param indexName string - Index on which to perform the request.
	@param model RecommendModels - [Recommend models](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param searchRecommendRulesParams SearchRecommendRulesParams
	@return SearchRecommendRulesResponse
*/
func (c *APIClient) SearchRecommendRulesWithContext(ctx context.Context, r ApiSearchRecommendRulesRequest, opts ...Option) (*SearchRecommendRulesResponse, error) {
	var (
		postBody    any
		returnValue *SearchRecommendRulesResponse
	)

	requestPath := "/1/indexes/{indexName}/{model}/recommend/rules/search"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(parameterToString(r.model)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return returnValue, reportError("Parameter `indexName` is required when calling `SearchRecommendRules`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.searchRecommendRulesParams) {
		postBody = "{}"
	} else {
		postBody = r.searchRecommendRulesParams
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return returnValue, err
	}

	res, err := c.callAPI(req, true)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	resBody, err := io.ReadAll(res.Body)
	res.Body.Close()
	res.Body = io.NopCloser(bytes.NewBuffer(resBody))
	if err != nil {
		return returnValue, err
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody, res.Header.Get("Content-Type"))
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody, res.Header.Get("Content-Type"))
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
