// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package recommend

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/transport"
	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type config struct {
	// -- Request options for API calls
	context      context.Context
	queryParams  url.Values
	headerParams map[string]string
	timeouts     transport.RequestConfiguration
}

type RequestOption interface {
	apply(*config)
}

type requestOption func(*config)

func (r requestOption) apply(c *config) {
	r(c)
}

func WithContext(ctx context.Context) requestOption {
	return requestOption(func(c *config) {
		c.context = ctx
	})
}

func WithHeaderParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.headerParams[key] = utils.ParameterToString(value)
	})
}

func WithQueryParam(key string, value any) requestOption {
	return requestOption(func(c *config) {
		c.queryParams.Set(utils.QueryParameterToString(key), utils.QueryParameterToString(value))
	})
}

func WithReadTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ReadTimeout = &timeout
	})
}

func WithWriteTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.WriteTimeout = &timeout
	})
}

func WithConnectTimeout(timeout time.Duration) requestOption {
	return requestOption(func(c *config) {
		c.timeouts.ConnectTimeout = &timeout
	})
}

func (r *ApiBatchRecommendRulesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	if v, ok := req["model"]; ok {
		err = json.Unmarshal(v, &r.model)
		if err != nil {
			err = json.Unmarshal(b, &r.model)
			if err != nil {
				return fmt.Errorf("cannot unmarshal model: %w", err)
			}
		}
	}

	if v, ok := req["recommendRule"]; ok {
		err = json.Unmarshal(v, &r.recommendRule)
		if err != nil {
			err = json.Unmarshal(b, &r.recommendRule)
			if err != nil {
				return fmt.Errorf("cannot unmarshal recommendRule: %w", err)
			}
		}
	}

	return nil
}

// ApiBatchRecommendRulesRequest represents the request with all the parameters for the API call.
type ApiBatchRecommendRulesRequest struct {
	indexName     string
	model         RecommendModels
	recommendRule []RecommendRule
}

// NewApiBatchRecommendRulesRequest creates an instance of the ApiBatchRecommendRulesRequest to be used for the API call.
func (c *APIClient) NewApiBatchRecommendRulesRequest(indexName string, model RecommendModels) ApiBatchRecommendRulesRequest {
	return ApiBatchRecommendRulesRequest{
		indexName: indexName,
		model:     model,
	}
}

// WithRecommendRule adds the recommendRule to the ApiBatchRecommendRulesRequest and returns the request for chaining.
func (r ApiBatchRecommendRulesRequest) WithRecommendRule(recommendRule []RecommendRule) ApiBatchRecommendRulesRequest {
	r.recommendRule = recommendRule

	return r
}

/*
BatchRecommendRules calls the API and returns the raw response from it.

	Create or update a batch of Recommend Rules

Each Recommend Rule is created or updated, depending on whether a Recommend Rule with the same `objectID` already exists.
You may also specify `true` for `clearExistingRules`, in which case the batch will atomically replace all the existing Recommend Rules.

Recommend Rules are similar to Search Rules, except that the conditions and consequences apply to a [source item](/doc/guides/algolia-recommend/overview/#recommend-models) instead of a query. The main differences are the following:
- Conditions `pattern` and `anchoring` are unavailable.
- Condition `filters` triggers if the source item matches the specified filters.
- Condition `filters` accepts numeric filters.
- Consequence `params` only covers filtering parameters.
- Consequence `automaticFacetFilters` doesn't require a facet value placeholder (it tries to match the data source item's attributes instead).

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiBatchRecommendRulesRequest with parameters below.
	  @param indexName string - Name of the index on which to perform the operation.
	  @param model RecommendModels - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	  @param recommendRule []RecommendRule
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) BatchRecommendRulesWithHTTPInfo(r ApiBatchRecommendRulesRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{model}/recommend/rules/batch"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(utils.ParameterToString(r.model)))

	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `BatchRecommendRules`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.recommendRule) {
		postBody = "{}"
	} else {
		postBody = r.recommendRule
	}

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
BatchRecommendRules casts the HTTP response body to a defined struct.

# Create or update a batch of Recommend Rules

Each Recommend Rule is created or updated, depending on whether a Recommend Rule with the same `objectID` already exists.
You may also specify `true` for `clearExistingRules`, in which case the batch will atomically replace all the existing Recommend Rules.

Recommend Rules are similar to Search Rules, except that the conditions and consequences apply to a [source item](/doc/guides/algolia-recommend/overview/#recommend-models) instead of a query. The main differences are the following:
- Conditions `pattern` and `anchoring` are unavailable.
- Condition `filters` triggers if the source item matches the specified filters.
- Condition `filters` accepts numeric filters.
- Consequence `params` only covers filtering parameters.
- Consequence `automaticFacetFilters` doesn't require a facet value placeholder (it tries to match the data source item's attributes instead).

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiBatchRecommendRulesRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param model RecommendModels - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param recommendRule []RecommendRule
	@return RecommendUpdatedAtResponse
*/
func (c *APIClient) BatchRecommendRules(r ApiBatchRecommendRulesRequest, opts ...RequestOption) (*RecommendUpdatedAtResponse, error) {
	var returnValue *RecommendUpdatedAtResponse

	res, resBody, err := c.BatchRecommendRulesWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomDeleteRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}

	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomDeleteRequest represents the request with all the parameters for the API call.
type ApiCustomDeleteRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomDeleteRequest creates an instance of the ApiCustomDeleteRequest to be used for the API call.
func (c *APIClient) NewApiCustomDeleteRequest(path string) ApiCustomDeleteRequest {
	return ApiCustomDeleteRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomDeleteRequest and returns the request for chaining.
func (r ApiCustomDeleteRequest) WithParameters(parameters map[string]any) ApiCustomDeleteRequest {
	r.parameters = parameters

	return r
}

/*
CustomDelete calls the API and returns the raw response from it.

	  This method lets you send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomDeleteRequest with parameters below.
	  @param path string - Path of the endpoint, for example `1/newFeature`.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomDeleteWithHTTPInfo(r ApiCustomDeleteRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CustomDelete casts the HTTP response body to a defined struct.

This method lets you send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, for example `1/newFeature`.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomDelete(r ApiCustomDeleteRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}

	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomGetRequest represents the request with all the parameters for the API call.
type ApiCustomGetRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomGetRequest creates an instance of the ApiCustomGetRequest to be used for the API call.
func (c *APIClient) NewApiCustomGetRequest(path string) ApiCustomGetRequest {
	return ApiCustomGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomGetRequest and returns the request for chaining.
func (r ApiCustomGetRequest) WithParameters(parameters map[string]any) ApiCustomGetRequest {
	r.parameters = parameters

	return r
}

/*
CustomGet calls the API and returns the raw response from it.

	  This method lets you send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomGetRequest with parameters below.
	  @param path string - Path of the endpoint, for example `1/newFeature`.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomGetWithHTTPInfo(r ApiCustomGetRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CustomGet casts the HTTP response body to a defined struct.

This method lets you send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, for example `1/newFeature`.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomGet(r ApiCustomGetRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}

	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPostRequest represents the request with all the parameters for the API call.
type ApiCustomPostRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPostRequest creates an instance of the ApiCustomPostRequest to be used for the API call.
func (c *APIClient) NewApiCustomPostRequest(path string) ApiCustomPostRequest {
	return ApiCustomPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithParameters(parameters map[string]any) ApiCustomPostRequest {
	r.parameters = parameters

	return r
}

// WithBody adds the body to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithBody(body map[string]any) ApiCustomPostRequest {
	r.body = body

	return r
}

/*
CustomPost calls the API and returns the raw response from it.

	  This method lets you send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomPostRequest with parameters below.
	  @param path string - Path of the endpoint, for example `1/newFeature`.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	  @param body map[string]any - Parameters to send with the custom request.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomPostWithHTTPInfo(r ApiCustomPostRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CustomPost casts the HTTP response body to a defined struct.

This method lets you send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, for example `1/newFeature`.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPost(r ApiCustomPostRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}

	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPutRequest represents the request with all the parameters for the API call.
type ApiCustomPutRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPutRequest creates an instance of the ApiCustomPutRequest to be used for the API call.
func (c *APIClient) NewApiCustomPutRequest(path string) ApiCustomPutRequest {
	return ApiCustomPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithParameters(parameters map[string]any) ApiCustomPutRequest {
	r.parameters = parameters

	return r
}

// WithBody adds the body to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithBody(body map[string]any) ApiCustomPutRequest {
	r.body = body

	return r
}

/*
CustomPut calls the API and returns the raw response from it.

	  This method lets you send requests to the Algolia REST API.


	Request can be constructed by NewApiCustomPutRequest with parameters below.
	  @param path string - Path of the endpoint, for example `1/newFeature`.
	  @param parameters map[string]any - Query parameters to apply to the current query.
	  @param body map[string]any - Parameters to send with the custom request.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) CustomPutWithHTTPInfo(r ApiCustomPutRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", utils.ParameterToString(r.path))

	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			conf.queryParams.Set(k, utils.QueryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPut, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
CustomPut casts the HTTP response body to a defined struct.

This method lets you send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, for example `1/newFeature`.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPut(r ApiCustomPutRequest, opts ...RequestOption) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteRecommendRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	if v, ok := req["model"]; ok {
		err = json.Unmarshal(v, &r.model)
		if err != nil {
			err = json.Unmarshal(b, &r.model)
			if err != nil {
				return fmt.Errorf("cannot unmarshal model: %w", err)
			}
		}
	}

	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal objectID: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteRecommendRuleRequest represents the request with all the parameters for the API call.
type ApiDeleteRecommendRuleRequest struct {
	indexName string
	model     RecommendModels
	objectID  string
}

// NewApiDeleteRecommendRuleRequest creates an instance of the ApiDeleteRecommendRuleRequest to be used for the API call.
func (c *APIClient) NewApiDeleteRecommendRuleRequest(indexName string, model RecommendModels, objectID string) ApiDeleteRecommendRuleRequest {
	return ApiDeleteRecommendRuleRequest{
		indexName: indexName,
		model:     model,
		objectID:  objectID,
	}
}

/*
DeleteRecommendRule calls the API and returns the raw response from it.

	  Deletes a Recommend rule from a recommendation scenario.

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiDeleteRecommendRuleRequest with parameters below.
	  @param indexName string - Name of the index on which to perform the operation.
	  @param model RecommendModels - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	  @param objectID string - Unique record identifier.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) DeleteRecommendRuleWithHTTPInfo(r ApiDeleteRecommendRuleRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{model}/recommend/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(utils.ParameterToString(r.model)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(r.objectID)))

	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteRecommendRule`.")
	}

	if r.objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `DeleteRecommendRule`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodDelete, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
DeleteRecommendRule casts the HTTP response body to a defined struct.

Deletes a Recommend rule from a recommendation scenario.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiDeleteRecommendRuleRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param model RecommendModels - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param objectID string - Unique record identifier.
	@return DeletedAtResponse
*/
func (c *APIClient) DeleteRecommendRule(r ApiDeleteRecommendRuleRequest, opts ...RequestOption) (*DeletedAtResponse, error) {
	var returnValue *DeletedAtResponse

	res, resBody, err := c.DeleteRecommendRuleWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRecommendRuleRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	if v, ok := req["model"]; ok {
		err = json.Unmarshal(v, &r.model)
		if err != nil {
			err = json.Unmarshal(b, &r.model)
			if err != nil {
				return fmt.Errorf("cannot unmarshal model: %w", err)
			}
		}
	}

	if v, ok := req["objectID"]; ok {
		err = json.Unmarshal(v, &r.objectID)
		if err != nil {
			err = json.Unmarshal(b, &r.objectID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal objectID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetRecommendRuleRequest represents the request with all the parameters for the API call.
type ApiGetRecommendRuleRequest struct {
	indexName string
	model     RecommendModels
	objectID  string
}

// NewApiGetRecommendRuleRequest creates an instance of the ApiGetRecommendRuleRequest to be used for the API call.
func (c *APIClient) NewApiGetRecommendRuleRequest(indexName string, model RecommendModels, objectID string) ApiGetRecommendRuleRequest {
	return ApiGetRecommendRuleRequest{
		indexName: indexName,
		model:     model,
		objectID:  objectID,
	}
}

/*
GetRecommendRule calls the API and returns the raw response from it.

	  Retrieves a Recommend rule that you previously created in the Algolia dashboard.

	    Required API Key ACLs:
	    - settings

	Request can be constructed by NewApiGetRecommendRuleRequest with parameters below.
	  @param indexName string - Name of the index on which to perform the operation.
	  @param model RecommendModels - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	  @param objectID string - Unique record identifier.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetRecommendRuleWithHTTPInfo(r ApiGetRecommendRuleRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{model}/recommend/rules/{objectID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(utils.ParameterToString(r.model)))
	requestPath = strings.ReplaceAll(requestPath, "{objectID}", url.PathEscape(utils.ParameterToString(r.objectID)))

	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetRecommendRule`.")
	}

	if r.objectID == "" {
		return nil, nil, reportError("Parameter `objectID` is required when calling `GetRecommendRule`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetRecommendRule casts the HTTP response body to a defined struct.

Retrieves a Recommend rule that you previously created in the Algolia dashboard.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetRecommendRuleRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param model RecommendModels - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param objectID string - Unique record identifier.
	@return RecommendRule
*/
func (c *APIClient) GetRecommendRule(r ApiGetRecommendRuleRequest, opts ...RequestOption) (*RecommendRule, error) {
	var returnValue *RecommendRule

	res, resBody, err := c.GetRecommendRuleWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRecommendStatusRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	if v, ok := req["model"]; ok {
		err = json.Unmarshal(v, &r.model)
		if err != nil {
			err = json.Unmarshal(b, &r.model)
			if err != nil {
				return fmt.Errorf("cannot unmarshal model: %w", err)
			}
		}
	}

	if v, ok := req["taskID"]; ok {
		err = json.Unmarshal(v, &r.taskID)
		if err != nil {
			err = json.Unmarshal(b, &r.taskID)
			if err != nil {
				return fmt.Errorf("cannot unmarshal taskID: %w", err)
			}
		}
	}

	return nil
}

// ApiGetRecommendStatusRequest represents the request with all the parameters for the API call.
type ApiGetRecommendStatusRequest struct {
	indexName string
	model     RecommendModels
	taskID    int64
}

// NewApiGetRecommendStatusRequest creates an instance of the ApiGetRecommendStatusRequest to be used for the API call.
func (c *APIClient) NewApiGetRecommendStatusRequest(indexName string, model RecommendModels, taskID int64) ApiGetRecommendStatusRequest {
	return ApiGetRecommendStatusRequest{
		indexName: indexName,
		model:     model,
		taskID:    taskID,
	}
}

/*
GetRecommendStatus calls the API and returns the raw response from it.

	Checks the status of a given task.

Deleting a Recommend rule is asynchronous.
When you delete a rule, a task is created on a queue and completed depending on the load on the server.
The API response includes a task ID that you can use to check the status.

	    Required API Key ACLs:
	    - editSettings

	Request can be constructed by NewApiGetRecommendStatusRequest with parameters below.
	  @param indexName string - Name of the index on which to perform the operation.
	  @param model RecommendModels - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	  @param taskID int64 - Unique task identifier.
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetRecommendStatusWithHTTPInfo(r ApiGetRecommendStatusRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{model}/task/{taskID}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(utils.ParameterToString(r.model)))
	requestPath = strings.ReplaceAll(requestPath, "{taskID}", url.PathEscape(utils.ParameterToString(r.taskID)))

	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetRecommendStatus`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodGet, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false, conf.timeouts)
}

/*
GetRecommendStatus casts the HTTP response body to a defined struct.

Checks the status of a given task.

Deleting a Recommend rule is asynchronous.
When you delete a rule, a task is created on a queue and completed depending on the load on the server.
The API response includes a task ID that you can use to check the status.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiGetRecommendStatusRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param model RecommendModels - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param taskID int64 - Unique task identifier.
	@return GetRecommendTaskResponse
*/
func (c *APIClient) GetRecommendStatus(r ApiGetRecommendStatusRequest, opts ...RequestOption) (*GetRecommendTaskResponse, error) {
	var returnValue *GetRecommendTaskResponse

	res, resBody, err := c.GetRecommendStatusWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetRecommendationsRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["getRecommendationsParams"]; ok {
		err = json.Unmarshal(v, &r.getRecommendationsParams)
		if err != nil {
			err = json.Unmarshal(b, &r.getRecommendationsParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal getRecommendationsParams: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.getRecommendationsParams)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter getRecommendationsParams: %w", err)
		}
	}

	return nil
}

// ApiGetRecommendationsRequest represents the request with all the parameters for the API call.
type ApiGetRecommendationsRequest struct {
	getRecommendationsParams *GetRecommendationsParams
}

// NewApiGetRecommendationsRequest creates an instance of the ApiGetRecommendationsRequest to be used for the API call.
func (c *APIClient) NewApiGetRecommendationsRequest(getRecommendationsParams *GetRecommendationsParams) ApiGetRecommendationsRequest {
	return ApiGetRecommendationsRequest{
		getRecommendationsParams: getRecommendationsParams,
	}
}

/*
GetRecommendations calls the API and returns the raw response from it.

	  Retrieves recommendations from selected AI models.


	    Required API Key ACLs:
	    - search

	Request can be constructed by NewApiGetRecommendationsRequest with parameters below.
	  @param getRecommendationsParams GetRecommendationsParams
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) GetRecommendationsWithHTTPInfo(r ApiGetRecommendationsRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/*/recommendations"

	if r.getRecommendationsParams == nil {
		return nil, nil, reportError("Parameter `getRecommendationsParams` is required when calling `GetRecommendations`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	postBody = r.getRecommendationsParams

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

/*
GetRecommendations casts the HTTP response body to a defined struct.

Retrieves recommendations from selected AI models.

Required API Key ACLs:
  - search

Request can be constructed by NewApiGetRecommendationsRequest with parameters below.

	@param getRecommendationsParams GetRecommendationsParams
	@return GetRecommendationsResponse
*/
func (c *APIClient) GetRecommendations(r ApiGetRecommendationsRequest, opts ...RequestOption) (*GetRecommendationsResponse, error) {
	var returnValue *GetRecommendationsResponse

	res, resBody, err := c.GetRecommendationsWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiSearchRecommendRulesRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}

	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}

	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	if v, ok := req["model"]; ok {
		err = json.Unmarshal(v, &r.model)
		if err != nil {
			err = json.Unmarshal(b, &r.model)
			if err != nil {
				return fmt.Errorf("cannot unmarshal model: %w", err)
			}
		}
	}

	if v, ok := req["searchRecommendRulesParams"]; ok {
		err = json.Unmarshal(v, &r.searchRecommendRulesParams)
		if err != nil {
			err = json.Unmarshal(b, &r.searchRecommendRulesParams)
			if err != nil {
				return fmt.Errorf("cannot unmarshal searchRecommendRulesParams: %w", err)
			}
		}
	}

	return nil
}

// ApiSearchRecommendRulesRequest represents the request with all the parameters for the API call.
type ApiSearchRecommendRulesRequest struct {
	indexName                  string
	model                      RecommendModels
	searchRecommendRulesParams *SearchRecommendRulesParams
}

// NewApiSearchRecommendRulesRequest creates an instance of the ApiSearchRecommendRulesRequest to be used for the API call.
func (c *APIClient) NewApiSearchRecommendRulesRequest(indexName string, model RecommendModels) ApiSearchRecommendRulesRequest {
	return ApiSearchRecommendRulesRequest{
		indexName: indexName,
		model:     model,
	}
}

// WithSearchRecommendRulesParams adds the searchRecommendRulesParams to the ApiSearchRecommendRulesRequest and returns the request for chaining.
func (r ApiSearchRecommendRulesRequest) WithSearchRecommendRulesParams(
	searchRecommendRulesParams *SearchRecommendRulesParams,
) ApiSearchRecommendRulesRequest {
	r.searchRecommendRulesParams = searchRecommendRulesParams

	return r
}

/*
SearchRecommendRules calls the API and returns the raw response from it.

	Searches for Recommend rules.

Use an empty query to list all rules for this recommendation scenario.

	    Required API Key ACLs:
	    - settings

	Request can be constructed by NewApiSearchRecommendRulesRequest with parameters below.
	  @param indexName string - Name of the index on which to perform the operation.
	  @param model RecommendModels - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	  @param searchRecommendRulesParams SearchRecommendRulesParams
	@param opts ...RequestOption - Optional parameters for the API call
	@return *http.Response - The raw response from the API
	@return []byte - The raw response body from the API
	@return error - An error if the API call fails
*/
func (c *APIClient) SearchRecommendRulesWithHTTPInfo(r ApiSearchRecommendRulesRequest, opts ...RequestOption) (*http.Response, []byte, error) {
	requestPath := "/1/indexes/{indexName}/{model}/recommend/rules/search"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(utils.ParameterToString(r.indexName)))
	requestPath = strings.ReplaceAll(requestPath, "{model}", url.PathEscape(utils.ParameterToString(r.model)))

	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `SearchRecommendRules`.")
	}

	conf := config{
		context:      context.Background(),
		queryParams:  url.Values{},
		headerParams: map[string]string{},
	}

	// optional params if any
	for _, opt := range opts {
		opt.apply(&conf)
	}

	var postBody any

	// body params
	if utils.IsNilOrEmpty(r.searchRecommendRulesParams) {
		postBody = "{}"
	} else {
		postBody = r.searchRecommendRulesParams
	}

	req, err := c.prepareRequest(conf.context, requestPath, http.MethodPost, postBody, conf.headerParams, conf.queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, true, conf.timeouts)
}

/*
SearchRecommendRules casts the HTTP response body to a defined struct.

Searches for Recommend rules.

Use an empty query to list all rules for this recommendation scenario.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiSearchRecommendRulesRequest with parameters below.

	@param indexName string - Name of the index on which to perform the operation.
	@param model RecommendModels - [Recommend model](https://www.algolia.com/doc/guides/algolia-recommend/overview/#recommend-models).
	@param searchRecommendRulesParams SearchRecommendRulesParams
	@return SearchRecommendRulesResponse
*/
func (c *APIClient) SearchRecommendRules(r ApiSearchRecommendRulesRequest, opts ...RequestOption) (*SearchRecommendRulesResponse, error) {
	var returnValue *SearchRecommendRulesResponse

	res, resBody, err := c.SearchRecommendRulesWithHTTPInfo(r, opts...)
	if err != nil {
		return returnValue, err
	}

	if res == nil {
		return returnValue, reportError("res is nil")
	}
	defer res.Body.Close()

	if res.StatusCode >= 300 {
		return returnValue, c.decodeError(res, resBody)
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
