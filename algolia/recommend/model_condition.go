// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package recommend

import (
	"encoding/json"
	"fmt"
)

// Condition Condition that triggers the rule. If not specified, the rule is triggered for all recommendations.
type Condition struct {
	// Filter expression to only include items that match the filter criteria in the response.  You can use these filter expressions:  - **Numeric filters.** `<facet> <op> <number>`, where `<op>` is one of `<`, `<=`, `=`, `!=`, `>`, `>=`. - **Ranges.** `<facet>:<lower> TO <upper>` where `<lower>` and `<upper>` are the lower and upper limits of the range (inclusive). - **Facet filters.** `<facet>:<value>` where `<facet>` is a facet attribute (case-sensitive) and `<value>` a facet value. - **Tag filters.** `_tags:<value>` or just `<value>` (case-sensitive). - **Boolean filters.** `<facet>: true | false`.  You can combine filters with `AND`, `OR`, and `NOT` operators with the following restrictions:  - You can only combine filters of the same type with `OR`.   **Not supported:** `facet:value OR num > 3`. - You can't use `NOT` with combinations of filters.   **Not supported:** `NOT(facet:value OR facet:value)` - You can't combine conjunctions (`AND`) with `OR`.   **Not supported:** `facet:value OR (facet:value AND facet:value)`  Use quotes around your filters, if the facet attribute name or facet value has spaces, keywords (`OR`, `AND`, `NOT`), or quotes. If a facet attribute is an array, the filter matches if it matches at least one element of the array.  For more information, see [Filters](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering/).
	Filters *string `json:"filters,omitempty"`
	// An additional restriction that only triggers the rule, when the search has the same value as `ruleContexts` parameter. For example, if `context: mobile`, the rule is only triggered when the search request has a matching `ruleContexts: mobile`. A rule context must only contain alphanumeric characters.
	Context *string `json:"context,omitempty"`
}

type ConditionOption func(f *Condition)

func WithConditionFilters(val string) ConditionOption {
	return func(f *Condition) {
		f.Filters = &val
	}
}

func WithConditionContext(val string) ConditionOption {
	return func(f *Condition) {
		f.Context = &val
	}
}

// NewCondition instantiates a new Condition object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed.
func NewCondition(opts ...ConditionOption) *Condition {
	this := &Condition{}
	for _, opt := range opts {
		opt(this)
	}
	return this
}

// NewEmptyCondition return a pointer to an empty Condition object.
func NewEmptyCondition() *Condition {
	return &Condition{}
}

// GetFilters returns the Filters field value if set, zero value otherwise.
func (o *Condition) GetFilters() string {
	if o == nil || o.Filters == nil {
		var ret string
		return ret
	}
	return *o.Filters
}

// GetFiltersOk returns a tuple with the Filters field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Condition) GetFiltersOk() (*string, bool) {
	if o == nil || o.Filters == nil {
		return nil, false
	}
	return o.Filters, true
}

// HasFilters returns a boolean if a field has been set.
func (o *Condition) HasFilters() bool {
	if o != nil && o.Filters != nil {
		return true
	}

	return false
}

// SetFilters gets a reference to the given string and assigns it to the Filters field.
func (o *Condition) SetFilters(v string) *Condition {
	o.Filters = &v
	return o
}

// GetContext returns the Context field value if set, zero value otherwise.
func (o *Condition) GetContext() string {
	if o == nil || o.Context == nil {
		var ret string
		return ret
	}
	return *o.Context
}

// GetContextOk returns a tuple with the Context field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *Condition) GetContextOk() (*string, bool) {
	if o == nil || o.Context == nil {
		return nil, false
	}
	return o.Context, true
}

// HasContext returns a boolean if a field has been set.
func (o *Condition) HasContext() bool {
	if o != nil && o.Context != nil {
		return true
	}

	return false
}

// SetContext gets a reference to the given string and assigns it to the Context field.
func (o *Condition) SetContext(v string) *Condition {
	o.Context = &v
	return o
}

func (o Condition) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]any{}
	if o.Filters != nil {
		toSerialize["filters"] = o.Filters
	}
	if o.Context != nil {
		toSerialize["context"] = o.Context
	}
	serialized, err := json.Marshal(toSerialize)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal Condition: %w", err)
	}

	return serialized, nil
}

func (o Condition) String() string {
	out := ""
	out += fmt.Sprintf("  filters=%v\n", o.Filters)
	out += fmt.Sprintf("  context=%v\n", o.Context)
	return fmt.Sprintf("Condition {\n%s}", out)
}
