// Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.
package suggestions

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v4/algolia/utils"
)

type Option struct {
	optionType string
	name       string
	value      string
}

func QueryParamOption(name string, val any) Option {
	return Option{
		optionType: "query",
		name:       queryParameterToString(name),
		value:      queryParameterToString(val),
	}
}

func HeaderParamOption(name string, val any) Option {
	return Option{
		optionType: "header",
		name:       name,
		value:      parameterToString(val),
	}
}

func (r *ApiCreateConfigRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["querySuggestionsConfigurationWithIndex"]; ok {
		err = json.Unmarshal(v, &r.querySuggestionsConfigurationWithIndex)
		if err != nil {
			err = json.Unmarshal(b, &r.querySuggestionsConfigurationWithIndex)
			if err != nil {
				return fmt.Errorf("cannot unmarshal querySuggestionsConfigurationWithIndex: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.querySuggestionsConfigurationWithIndex)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter querySuggestionsConfigurationWithIndex: %w", err)
		}
	}

	return nil
}

// ApiCreateConfigRequest represents the request with all the parameters for the API call.
type ApiCreateConfigRequest struct {
	querySuggestionsConfigurationWithIndex *QuerySuggestionsConfigurationWithIndex
}

// NewApiCreateConfigRequest creates an instance of the ApiCreateConfigRequest to be used for the API call.
func (c *APIClient) NewApiCreateConfigRequest(querySuggestionsConfigurationWithIndex *QuerySuggestionsConfigurationWithIndex) ApiCreateConfigRequest {
	return ApiCreateConfigRequest{
		querySuggestionsConfigurationWithIndex: querySuggestionsConfigurationWithIndex,
	}
}

/*
CreateConfig calls the API and returns the raw response from it.

Creates a new Query Suggestions configuration.

You can have up to 100 configurations per Algolia application.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiCreateConfigRequest with parameters below.

	@param querySuggestionsConfigurationWithIndex QuerySuggestionsConfigurationWithIndex
	@return BaseResponse
*/
func (c *APIClient) CreateConfigWithHTTPInfo(ctx context.Context, r ApiCreateConfigRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/configs"

	headers := make(map[string]string)
	queryParams := url.Values{}

	if r.querySuggestionsConfigurationWithIndex == nil {
		return nil, nil, reportError("Parameter `querySuggestionsConfigurationWithIndex` is required when calling `CreateConfig`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.querySuggestionsConfigurationWithIndex
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CreateConfig wraps CreateConfigWithContext using context.Background.

Creates a new Query Suggestions configuration.

You can have up to 100 configurations per Algolia application.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiCreateConfigRequest with parameters below.

	@param querySuggestionsConfigurationWithIndex QuerySuggestionsConfigurationWithIndex
	@return BaseResponse
*/
func (c *APIClient) CreateConfig(r ApiCreateConfigRequest, opts ...Option) (*BaseResponse, error) {
	return c.CreateConfigWithContext(context.Background(), r, opts...)
}

/*
CreateConfig casts the HTTP response body to a defined struct.

Creates a new Query Suggestions configuration.

You can have up to 100 configurations per Algolia application.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiCreateConfigRequest with parameters below.

	@param querySuggestionsConfigurationWithIndex QuerySuggestionsConfigurationWithIndex
	@return BaseResponse
*/
func (c *APIClient) CreateConfigWithContext(ctx context.Context, r ApiCreateConfigRequest, opts ...Option) (*BaseResponse, error) {
	var returnValue *BaseResponse

	res, resBody, err := c.CreateConfigWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomDeleteRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomDeleteRequest represents the request with all the parameters for the API call.
type ApiCustomDeleteRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomDeleteRequest creates an instance of the ApiCustomDeleteRequest to be used for the API call.
func (c *APIClient) NewApiCustomDeleteRequest(path string) ApiCustomDeleteRequest {
	return ApiCustomDeleteRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomDeleteRequest and returns the request for chaining.
func (r ApiCustomDeleteRequest) WithParameters(parameters map[string]any) ApiCustomDeleteRequest {
	r.parameters = parameters
	return r
}

/*
CustomDelete calls the API and returns the raw response from it.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomDeleteWithHTTPInfo(ctx context.Context, r ApiCustomDeleteRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomDelete`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomDelete wraps CustomDeleteWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomDelete(r ApiCustomDeleteRequest, opts ...Option) (*map[string]any, error) {
	return c.CustomDeleteWithContext(context.Background(), r, opts...)
}

/*
CustomDelete casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomDeleteRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomDeleteWithContext(ctx context.Context, r ApiCustomDeleteRequest, opts ...Option) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomDeleteWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomGetRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomGetRequest represents the request with all the parameters for the API call.
type ApiCustomGetRequest struct {
	path       string
	parameters map[string]any
}

// NewApiCustomGetRequest creates an instance of the ApiCustomGetRequest to be used for the API call.
func (c *APIClient) NewApiCustomGetRequest(path string) ApiCustomGetRequest {
	return ApiCustomGetRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomGetRequest and returns the request for chaining.
func (r ApiCustomGetRequest) WithParameters(parameters map[string]any) ApiCustomGetRequest {
	r.parameters = parameters
	return r
}

/*
CustomGet calls the API and returns the raw response from it.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomGetWithHTTPInfo(ctx context.Context, r ApiCustomGetRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomGet`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomGet wraps CustomGetWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomGet(r ApiCustomGetRequest, opts ...Option) (*map[string]any, error) {
	return c.CustomGetWithContext(context.Background(), r, opts...)
}

/*
CustomGet casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomGetRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@return map[string]any
*/
func (c *APIClient) CustomGetWithContext(ctx context.Context, r ApiCustomGetRequest, opts ...Option) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomGetWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPostRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPostRequest represents the request with all the parameters for the API call.
type ApiCustomPostRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPostRequest creates an instance of the ApiCustomPostRequest to be used for the API call.
func (c *APIClient) NewApiCustomPostRequest(path string) ApiCustomPostRequest {
	return ApiCustomPostRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithParameters(parameters map[string]any) ApiCustomPostRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPostRequest and returns the request for chaining.
func (r ApiCustomPostRequest) WithBody(body map[string]any) ApiCustomPostRequest {
	r.body = body
	return r
}

/*
CustomPost calls the API and returns the raw response from it.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPostWithHTTPInfo(ctx context.Context, r ApiCustomPostRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPost`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPost, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomPost wraps CustomPostWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPost(r ApiCustomPostRequest, opts ...Option) (*map[string]any, error) {
	return c.CustomPostWithContext(context.Background(), r, opts...)
}

/*
CustomPost casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPostRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPostWithContext(ctx context.Context, r ApiCustomPostRequest, opts ...Option) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPostWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiCustomPutRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["path"]; ok {
		err = json.Unmarshal(v, &r.path)
		if err != nil {
			err = json.Unmarshal(b, &r.path)
			if err != nil {
				return fmt.Errorf("cannot unmarshal path: %w", err)
			}
		}
	}
	if v, ok := req["parameters"]; ok {
		err = json.Unmarshal(v, &r.parameters)
		if err != nil {
			err = json.Unmarshal(b, &r.parameters)
			if err != nil {
				return fmt.Errorf("cannot unmarshal parameters: %w", err)
			}
		}
	}
	if v, ok := req["body"]; ok {
		err = json.Unmarshal(v, &r.body)
		if err != nil {
			err = json.Unmarshal(b, &r.body)
			if err != nil {
				return fmt.Errorf("cannot unmarshal body: %w", err)
			}
		}
	}

	return nil
}

// ApiCustomPutRequest represents the request with all the parameters for the API call.
type ApiCustomPutRequest struct {
	path       string
	parameters map[string]any
	body       map[string]any
}

// NewApiCustomPutRequest creates an instance of the ApiCustomPutRequest to be used for the API call.
func (c *APIClient) NewApiCustomPutRequest(path string) ApiCustomPutRequest {
	return ApiCustomPutRequest{
		path: path,
	}
}

// WithParameters adds the parameters to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithParameters(parameters map[string]any) ApiCustomPutRequest {
	r.parameters = parameters
	return r
}

// WithBody adds the body to the ApiCustomPutRequest and returns the request for chaining.
func (r ApiCustomPutRequest) WithBody(body map[string]any) ApiCustomPutRequest {
	r.body = body
	return r
}

/*
CustomPut calls the API and returns the raw response from it.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPutWithHTTPInfo(ctx context.Context, r ApiCustomPutRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/{path}"
	requestPath = strings.ReplaceAll(requestPath, "{path}", parameterToString(r.path))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.path == "" {
		return nil, nil, reportError("Parameter `path` is required when calling `CustomPut`.")
	}

	if !utils.IsNilOrEmpty(r.parameters) {
		for k, v := range r.parameters {
			queryParams.Set(k, queryParameterToString(v))
		}
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	if utils.IsNilOrEmpty(r.body) {
		postBody = "{}"
	} else {
		postBody = r.body
	}
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
CustomPut wraps CustomPutWithContext using context.Background.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPut(r ApiCustomPutRequest, opts ...Option) (*map[string]any, error) {
	return c.CustomPutWithContext(context.Background(), r, opts...)
}

/*
CustomPut casts the HTTP response body to a defined struct.

This method allow you to send requests to the Algolia REST API.

Request can be constructed by NewApiCustomPutRequest with parameters below.

	@param path string - Path of the endpoint, anything after \"/1\" must be specified.
	@param parameters map[string]any - Query parameters to apply to the current query.
	@param body map[string]any - Parameters to send with the custom request.
	@return map[string]any
*/
func (c *APIClient) CustomPutWithContext(ctx context.Context, r ApiCustomPutRequest, opts ...Option) (*map[string]any, error) {
	var returnValue *map[string]any

	res, resBody, err := c.CustomPutWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiDeleteConfigRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	return nil
}

// ApiDeleteConfigRequest represents the request with all the parameters for the API call.
type ApiDeleteConfigRequest struct {
	indexName string
}

// NewApiDeleteConfigRequest creates an instance of the ApiDeleteConfigRequest to be used for the API call.
func (c *APIClient) NewApiDeleteConfigRequest(indexName string) ApiDeleteConfigRequest {
	return ApiDeleteConfigRequest{
		indexName: indexName,
	}
}

/*
DeleteConfig calls the API and returns the raw response from it.

Deletes a Query Suggestions configuration.

Deleting only removes the configuration and stops updates to the Query Suggestions index.
To delete the Query Suggestions index itself, use the Search API and the [Delete an index](/specs/search#tag/Indices/operation/deleteIndex) operation.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiDeleteConfigRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@return BaseResponse
*/
func (c *APIClient) DeleteConfigWithHTTPInfo(ctx context.Context, r ApiDeleteConfigRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/configs/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `DeleteConfig`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodDelete, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
DeleteConfig wraps DeleteConfigWithContext using context.Background.

Deletes a Query Suggestions configuration.

Deleting only removes the configuration and stops updates to the Query Suggestions index.
To delete the Query Suggestions index itself, use the Search API and the [Delete an index](/specs/search#tag/Indices/operation/deleteIndex) operation.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiDeleteConfigRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@return BaseResponse
*/
func (c *APIClient) DeleteConfig(r ApiDeleteConfigRequest, opts ...Option) (*BaseResponse, error) {
	return c.DeleteConfigWithContext(context.Background(), r, opts...)
}

/*
DeleteConfig casts the HTTP response body to a defined struct.

Deletes a Query Suggestions configuration.

Deleting only removes the configuration and stops updates to the Query Suggestions index.
To delete the Query Suggestions index itself, use the Search API and the [Delete an index](/specs/search#tag/Indices/operation/deleteIndex) operation.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiDeleteConfigRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@return BaseResponse
*/
func (c *APIClient) DeleteConfigWithContext(ctx context.Context, r ApiDeleteConfigRequest, opts ...Option) (*BaseResponse, error) {
	var returnValue *BaseResponse

	res, resBody, err := c.DeleteConfigWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

/*
GetAllConfigs calls the API and returns the raw response from it.

Retrieves all Query Suggestions configurations of your Algolia application.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetAllConfigsRequest with parameters below.

	@return []QuerySuggestionsConfigurationResponse
*/
func (c *APIClient) GetAllConfigsWithHTTPInfo(ctx context.Context, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/configs"

	headers := make(map[string]string)
	queryParams := url.Values{}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetAllConfigs wraps GetAllConfigsWithContext using context.Background.

Retrieves all Query Suggestions configurations of your Algolia application.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetAllConfigsRequest with parameters below.

	@return []QuerySuggestionsConfigurationResponse
*/
func (c *APIClient) GetAllConfigs(opts ...Option) ([]QuerySuggestionsConfigurationResponse, error) {
	return c.GetAllConfigsWithContext(context.Background(), opts...)
}

/*
GetAllConfigs casts the HTTP response body to a defined struct.

Retrieves all Query Suggestions configurations of your Algolia application.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetAllConfigsRequest with parameters below.

	@return []QuerySuggestionsConfigurationResponse
*/
func (c *APIClient) GetAllConfigsWithContext(ctx context.Context, opts ...Option) ([]QuerySuggestionsConfigurationResponse, error) {
	var returnValue []QuerySuggestionsConfigurationResponse

	res, resBody, err := c.GetAllConfigsWithHTTPInfo(ctx, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetConfigRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	return nil
}

// ApiGetConfigRequest represents the request with all the parameters for the API call.
type ApiGetConfigRequest struct {
	indexName string
}

// NewApiGetConfigRequest creates an instance of the ApiGetConfigRequest to be used for the API call.
func (c *APIClient) NewApiGetConfigRequest(indexName string) ApiGetConfigRequest {
	return ApiGetConfigRequest{
		indexName: indexName,
	}
}

/*
GetConfig calls the API and returns the raw response from it.

Retrieves a single Query Suggestions configuration by its index name.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetConfigRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@return QuerySuggestionsConfigurationResponse
*/
func (c *APIClient) GetConfigWithHTTPInfo(ctx context.Context, r ApiGetConfigRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/configs/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetConfig`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetConfig wraps GetConfigWithContext using context.Background.

Retrieves a single Query Suggestions configuration by its index name.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetConfigRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@return QuerySuggestionsConfigurationResponse
*/
func (c *APIClient) GetConfig(r ApiGetConfigRequest, opts ...Option) (*QuerySuggestionsConfigurationResponse, error) {
	return c.GetConfigWithContext(context.Background(), r, opts...)
}

/*
GetConfig casts the HTTP response body to a defined struct.

Retrieves a single Query Suggestions configuration by its index name.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetConfigRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@return QuerySuggestionsConfigurationResponse
*/
func (c *APIClient) GetConfigWithContext(ctx context.Context, r ApiGetConfigRequest, opts ...Option) (*QuerySuggestionsConfigurationResponse, error) {
	var returnValue *QuerySuggestionsConfigurationResponse

	res, resBody, err := c.GetConfigWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetConfigStatusRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	return nil
}

// ApiGetConfigStatusRequest represents the request with all the parameters for the API call.
type ApiGetConfigStatusRequest struct {
	indexName string
}

// NewApiGetConfigStatusRequest creates an instance of the ApiGetConfigStatusRequest to be used for the API call.
func (c *APIClient) NewApiGetConfigStatusRequest(indexName string) ApiGetConfigStatusRequest {
	return ApiGetConfigStatusRequest{
		indexName: indexName,
	}
}

/*
GetConfigStatus calls the API and returns the raw response from it.

Reports the status of a Query Suggestions index.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetConfigStatusRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@return GetConfigStatus200Response
*/
func (c *APIClient) GetConfigStatusWithHTTPInfo(ctx context.Context, r ApiGetConfigStatusRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/configs/{indexName}/status"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetConfigStatus`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetConfigStatus wraps GetConfigStatusWithContext using context.Background.

Reports the status of a Query Suggestions index.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetConfigStatusRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@return GetConfigStatus200Response
*/
func (c *APIClient) GetConfigStatus(r ApiGetConfigStatusRequest, opts ...Option) (*GetConfigStatus200Response, error) {
	return c.GetConfigStatusWithContext(context.Background(), r, opts...)
}

/*
GetConfigStatus casts the HTTP response body to a defined struct.

Reports the status of a Query Suggestions index.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetConfigStatusRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@return GetConfigStatus200Response
*/
func (c *APIClient) GetConfigStatusWithContext(ctx context.Context, r ApiGetConfigStatusRequest, opts ...Option) (*GetConfigStatus200Response, error) {
	var returnValue *GetConfigStatus200Response

	res, resBody, err := c.GetConfigStatusWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiGetLogFileRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}

	return nil
}

// ApiGetLogFileRequest represents the request with all the parameters for the API call.
type ApiGetLogFileRequest struct {
	indexName string
}

// NewApiGetLogFileRequest creates an instance of the ApiGetLogFileRequest to be used for the API call.
func (c *APIClient) NewApiGetLogFileRequest(indexName string) ApiGetLogFileRequest {
	return ApiGetLogFileRequest{
		indexName: indexName,
	}
}

/*
GetLogFile calls the API and returns the raw response from it.

Retrieves the logs for a single Query Suggestions index.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetLogFileRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@return GetLogFile200Response
*/
func (c *APIClient) GetLogFileWithHTTPInfo(ctx context.Context, r ApiGetLogFileRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/logs/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `GetLogFile`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	req, err := c.prepareRequest(ctx, requestPath, http.MethodGet, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
GetLogFile wraps GetLogFileWithContext using context.Background.

Retrieves the logs for a single Query Suggestions index.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetLogFileRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@return GetLogFile200Response
*/
func (c *APIClient) GetLogFile(r ApiGetLogFileRequest, opts ...Option) (*GetLogFile200Response, error) {
	return c.GetLogFileWithContext(context.Background(), r, opts...)
}

/*
GetLogFile casts the HTTP response body to a defined struct.

Retrieves the logs for a single Query Suggestions index.

Required API Key ACLs:
  - settings

Request can be constructed by NewApiGetLogFileRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@return GetLogFile200Response
*/
func (c *APIClient) GetLogFileWithContext(ctx context.Context, r ApiGetLogFileRequest, opts ...Option) (*GetLogFile200Response, error) {
	var returnValue *GetLogFile200Response

	res, resBody, err := c.GetLogFileWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}

func (r *ApiUpdateConfigRequest) UnmarshalJSON(b []byte) error {
	req := map[string]json.RawMessage{}
	err := json.Unmarshal(b, &req)
	if err != nil {
		return fmt.Errorf("cannot unmarshal request: %w", err)
	}
	if v, ok := req["indexName"]; ok {
		err = json.Unmarshal(v, &r.indexName)
		if err != nil {
			err = json.Unmarshal(b, &r.indexName)
			if err != nil {
				return fmt.Errorf("cannot unmarshal indexName: %w", err)
			}
		}
	}
	if v, ok := req["querySuggestionsConfiguration"]; ok {
		err = json.Unmarshal(v, &r.querySuggestionsConfiguration)
		if err != nil {
			err = json.Unmarshal(b, &r.querySuggestionsConfiguration)
			if err != nil {
				return fmt.Errorf("cannot unmarshal querySuggestionsConfiguration: %w", err)
			}
		}
	} else {
		err = json.Unmarshal(b, &r.querySuggestionsConfiguration)
		if err != nil {
			return fmt.Errorf("cannot unmarshal body parameter querySuggestionsConfiguration: %w", err)
		}
	}

	return nil
}

// ApiUpdateConfigRequest represents the request with all the parameters for the API call.
type ApiUpdateConfigRequest struct {
	indexName                     string
	querySuggestionsConfiguration *QuerySuggestionsConfiguration
}

// NewApiUpdateConfigRequest creates an instance of the ApiUpdateConfigRequest to be used for the API call.
func (c *APIClient) NewApiUpdateConfigRequest(indexName string, querySuggestionsConfiguration *QuerySuggestionsConfiguration) ApiUpdateConfigRequest {
	return ApiUpdateConfigRequest{
		indexName:                     indexName,
		querySuggestionsConfiguration: querySuggestionsConfiguration,
	}
}

/*
UpdateConfig calls the API and returns the raw response from it.

Updates a QuerySuggestions configuration.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiUpdateConfigRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@param querySuggestionsConfiguration QuerySuggestionsConfiguration
	@return BaseResponse
*/
func (c *APIClient) UpdateConfigWithHTTPInfo(ctx context.Context, r ApiUpdateConfigRequest, opts ...Option) (*http.Response, []byte, error) {
	var postBody any

	requestPath := "/1/configs/{indexName}"
	requestPath = strings.ReplaceAll(requestPath, "{indexName}", url.PathEscape(parameterToString(r.indexName)))

	headers := make(map[string]string)
	queryParams := url.Values{}
	if r.indexName == "" {
		return nil, nil, reportError("Parameter `indexName` is required when calling `UpdateConfig`.")
	}

	if r.querySuggestionsConfiguration == nil {
		return nil, nil, reportError("Parameter `querySuggestionsConfiguration` is required when calling `UpdateConfig`.")
	}

	// optional params if any
	for _, opt := range opts {
		switch opt.optionType {
		case "query":
			queryParams.Set(opt.name, opt.value)
		case "header":
			headers[opt.name] = opt.value
		}
	}

	// body params
	postBody = r.querySuggestionsConfiguration
	req, err := c.prepareRequest(ctx, requestPath, http.MethodPut, postBody, headers, queryParams)
	if err != nil {
		return nil, nil, err
	}

	return c.callAPI(req, false)
}

/*
UpdateConfig wraps UpdateConfigWithContext using context.Background.

Updates a QuerySuggestions configuration.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiUpdateConfigRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@param querySuggestionsConfiguration QuerySuggestionsConfiguration
	@return BaseResponse
*/
func (c *APIClient) UpdateConfig(r ApiUpdateConfigRequest, opts ...Option) (*BaseResponse, error) {
	return c.UpdateConfigWithContext(context.Background(), r, opts...)
}

/*
UpdateConfig casts the HTTP response body to a defined struct.

Updates a QuerySuggestions configuration.

Required API Key ACLs:
  - editSettings

Request can be constructed by NewApiUpdateConfigRequest with parameters below.

	@param indexName string - Query Suggestions index name.
	@param querySuggestionsConfiguration QuerySuggestionsConfiguration
	@return BaseResponse
*/
func (c *APIClient) UpdateConfigWithContext(ctx context.Context, r ApiUpdateConfigRequest, opts ...Option) (*BaseResponse, error) {
	var returnValue *BaseResponse

	res, resBody, err := c.UpdateConfigWithHTTPInfo(ctx, r, opts...)
	if err != nil {
		return returnValue, err
	}
	if res == nil {
		return returnValue, reportError("res is nil")
	}

	if res.StatusCode >= 300 {
		newErr := &APIError{
			Message: string(resBody),
			Status:  res.StatusCode,
		}

		var v ErrorBase
		err = c.decode(&v, resBody)
		if err != nil {
			newErr.Message = err.Error()
			return returnValue, newErr
		}

		return returnValue, newErr
	}

	err = c.decode(&returnValue, resBody)
	if err != nil {
		return returnValue, reportError("cannot decode result: %w", err)
	}

	return returnValue, nil
}
